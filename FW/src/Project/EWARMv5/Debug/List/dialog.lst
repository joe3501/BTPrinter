###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     19/May/2015  10:28:21 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\T6\FW\src\App\dialog.c                                #
#    Command line =  E:\T6\FW\src\App\dialog.c -lcN                           #
#                    E:\T6\FW\src\Project\EWARMv5\Debug\List\ -o              #
#                    E:\T6\FW\src\Project\EWARMv5\Debug\Obj\ --no_cse         #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "D:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    5.4\arm\INC\DLib_Config_Full.h" -I                       #
#                    E:\T6\FW\src\Project\EWARMv5\..\ -I                      #
#                    E:\T6\FW\src\Project\EWARMv5\..\..\App\ -I               #
#                    E:\T6\FW\src\Project\EWARMv5\..\..\Drivers\ -I           #
#                    E:\T6\FW\src\Project\EWARMv5\..\..\FatFs\ -I             #
#                    E:\T6\FW\src\Project\EWARMv5\..\..\Lib\inc\ -I           #
#                    E:\T6\FW\src\Project\EWARMv5\..\..\uCOS\uC-CPU\ -I       #
#                    E:\T6\FW\src\Project\EWARMv5\..\..\uCOS\uC-LIB\ -I       #
#                    E:\T6\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Ports\   #
#                    -I E:\T6\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Sourc #
#                    e\ -I E:\T6\FW\src\Project\EWARMv5\..\..\uCOS\uC-Probe\  #
#                    -I E:\T6\FW\src\Project\EWARMv5\..\..\usb_lib\ -I        #
#                    "D:\Program Files\IAR Systems\Embedded Workbench         #
#                    5.4\arm\INC\" -Ol                                        #
#    List file    =  E:\T6\FW\src\Project\EWARMv5\Debug\List\dialog.lst       #
#    Object file  =  E:\T6\FW\src\Project\EWARMv5\Debug\Obj\dialog.o          #
#                                                                             #
#                                                                             #
###############################################################################

E:\T6\FW\src\App\dialog.c
      1          
      2          #include "dialog.h"
      3          #include "keypad.h"
      4          #include "pic.h"
      5          #include "stm32f10x_lib.h"
      6          #include "ucos_ii.h"
      7          #include "Terminal_Para.h"
      8          #include "calendar.h"
      9          #include "keypad.h"
     10          #include <stdlib.h>
     11          #include <stdio.h>
     12          #include <string.h>
     13          #include "gui.h"
     14          #include "keypad.h"
     15          #include "power_detect.h"
     16          #include  "usb_pwr.h"
     17          #include "app.h"
     18          #include "lcd.h"
     19          #include "YFBT07.h"
     20          
     21          /* Private variables ---------------------------------------------------------*/
     22          				
     23          static unsigned char			menu_all;
     24          static unsigned char			menu_pagecnt;			//当前窗体一页可以显示的菜单项
     25          static 	unsigned int			user_zone_height;
     26          
     27          static unsigned char			now_id;
     28          static unsigned char			howrun;
     29          static unsigned char			dlg_state;
     30          //static TProcessBar				process_bar;				//进度条
     31          
     32          static unsigned char			**pContent;
     33          //static int						last_charge_state;			//上次的充电状态
     34          
     35          static unsigned char			the_last_key;				//输入一个编辑框最后一个键值时的标记
     36          
     37          static int							SCommand;
     38          TbgTask						SbgTask;					// 后台任务回调函数
     39          static int							SParam1;
     40          static int							SParam2;
     41          static void							*SParam3;
     42          static void							*SParam4;
     43          static unsigned char				SReturn;					// 任务的返回值
     44          static int							SStatus;
     45          static int							lowpower_detect_cnt;
     46          static int							last_power_level;
     47          
     48          typedef struct 
     49          {
     50          	unsigned char valid_flag;			//当前保存的信息是否有效标记
     51          	unsigned char dlg_id;				//当前窗体的ID
     52          	unsigned char menu_start;			//绘制当前窗体的起始菜单项
     53          	unsigned char menu_current_item;	//当前选择的菜单项
     54          }TDRAWCONTEXT;
     55          
     56          static TDRAWCONTEXT		draw_context[2];	//最多有两级目录需要回退
     57          
     58          unsigned char			display_menu_item_array[5];		//界面当前显示的菜单项
     59          unsigned char			menu_current_item;				//当前菜单项
     60          unsigned char			menu_start;	
     61          unsigned char			icon_draw_flag;					//图标栏已经绘制了的标记 
     62          /* Global variables -----------------------------------------------------------*/
     63          unsigned char				g_editValue[MAX_EDIT][MAX_EDITNUM];//编辑框的全局变量
     64          
     65          unsigned char				max_dlg;
     66          unsigned char				next_dlg_id;
     67          //unsigned char				content_font_size;	//显示窗体内容时所用的字体大小
     68          
     69          TDialog						g_dlg;			
     70          OS_EVENT					*pBGCommand;				//控制后台任务的命令
     71          //unsigned char				auto_run_flag;				//控制窗体不需要获取到按键消息也可以进入按键处理的流程的标记。
     72          
     73          //由于需要在窗口回调中修改中文属性的编辑框的首选输入法，所以需要将下面三个变量设置为全局的属性。
     74          unsigned char				update_input_method_mode;	//更新输入法图标的模式
     75          unsigned char				input_method;				//当前输入法
     76          unsigned char				last_input_method;			//上一次使用的输入法
     77          unsigned char				max_edit;					//当前窗体包含的可编辑编辑框的总数
     78          unsigned char				all_edit;					//当前窗体包含的所有编辑框的总数
     79          unsigned char				edit_res_rebuild_flag;		//表示当前窗体的编辑框资源链表需要在运行时动态创建，链表创建于内存中，需要动态创建编辑框资源链表的窗体
     80          														//必须在窗体CREATE阶段的回调接口中标记。
     81          //unsigned char				default_input_method_patch;	//编辑框的首选输入法是否需要另外指定
     82          unsigned char				number_edit_patch;			//数字属性的编辑框中是否允许通过*号键输入小数点
     83          
     84          unsigned char		same_key_times;				///连续按同一个按键的次数
     85          
     86          //TEditRes					edit_res_rebuild[MAX_EDIT];	//动态创建的编辑框资源链表,在窗体CREATE阶段的回调接口中创建此链表。
     87          
     88          unsigned char				tempx;
     89          unsigned short				tempy;
     90          
     91          unsigned char			update_icon_cnt;
     92          unsigned short			edit_display_x_patch;
     93          
     94          unsigned int			lowpower_flag;
     95          int						bluetooth_match_cmd_cnt;
     96          int						bluetooth_state_cnt;
     97          
     98          		
     99          
    100          //TDRAW_ITEM	draw_content[MAX_CASH_ITEM];	//有些窗体在DRAW阶段回调时绘制的窗体内容需要缓存起来的缓存空间，由于处理中文输入法时需要将窗体的内容刷掉,如果需要增加缓存的内容可以改变此缓存空间的大小
    101          TRollDisplayItem	roll_display_table[3];	//需要滚动显示的内容
    102          unsigned char		roll_display_item_cnt;	//需要滚动显示的个数
    103          unsigned char		roll_update_cnt;
    104          unsigned char		roll_data_buffer[22];
    105          
    106          unsigned char		dlg_return_from_child;			//从子窗体返回此窗体运行的标记
    107          
    108          /* External Variable -----------------------------------------------------------*/
    109          extern const TActionList		dlg_actionlist[];
    110          extern OS_EVENT					*pKeyOSQ;					// 按键消息
    111          extern TkeyValue_Ascii			keyValue_Ascii_Tbl[];
    112          extern TTerminalPara			g_param;			//全局终端参数
    113          extern TypedefDateTime			currentDateTime;	
    114          extern unsigned char			gFontSize;			// 字号
    115          extern unsigned char			g_language;			// 文字类型
    116          extern unsigned char			edit_state;			//编辑框状态
    117          //extern unsigned char			current_operator;			// 当前登录到系统的操作员
    118          extern unsigned int				input_update_flag;			//是否需要更新输入的标记
    119          extern unsigned char			last_input_key;				//最近一次输入的按键
    120          extern vu32 bDeviceState;
    121          extern unsigned int				scan_start;
    122          extern unsigned char			no_update_icon_flg;
    123          extern unsigned char			usb_cable_state;
    124          //extern unsigned char	input_valid_num;				//输入的有效位数
    125          extern unsigned int				pos_state;
    126          extern unsigned char			need_refresh_signal;
    127          extern unsigned char			task_exit_flag;
    128          extern int						bluetooth_module_state;
    129          
    130          //extern unsigned char scanner_power_on_flag;
    131          //extern unsigned int  scanner_timeout;
    132          extern unsigned int	charge_state_cnt;
    133          
    134          extern unsigned char			need_refresh_edit_index_tbl[];	
    135          
    136          extern void EnterLowPowerMode(void);
    137          extern void ExitLowPowerMode(void);
    138          extern void	u_disk_proc(void);
    139          
    140          static int exp10(unsigned char e)
    141          {
    142          	unsigned char i;
    143          	int	res = 1;
    144          
    145          	if (e>10)
    146          	{
    147          		return 1;
    148          	}
    149          
    150          	for (i = 0; i < e;i++)
    151          	{
    152          		res *= 10;
    153          	}
    154          
    155          	return res;
    156          }
    157          /**
    158          * @brief 检查按键是否数字键和清除键
    159          */
    160          int is_key_num(unsigned char key)
    161          {
    162          	if(key==KEY_NUM1 || key==KEY_NUM2 || key==KEY_NUM3 || 
    163          		key==KEY_NUM4 || key==KEY_NUM5 || key==KEY_NUM6 || 
    164          		key==KEY_NUM7 || key==KEY_NUM8 || key==KEY_NUM9 || 
    165          		key==KEY_NUM0 ||key==KEY_ENTER || 
    166          		key==KEY_UP || key==KEY_DOWN )
    167          		return 0;
    168          	return -1;
    169          }
    170          
    171          /**
    172          * @brief 检查按键是否是键盘上的实际按键
    173          */
    174          int is_key_keypad(unsigned char key)
    175          {
    176          	if(key==KEY_SCAN || key==KEY_UP || key==KEY_DOWN || key==KEY_LEFT || key == KEY_RIGHT
    177          		|| key==KEY_LEFT_SHOTCUT || key==KEY_ESC || key==KEY_ENTER || key==KEY_RIGHT_SHOTCUT )
    178          		return 0;
    179          	return -1;
    180          }
    181          
    182          /**
    183          * @brief 初始化对话框模块
    184          */
    185          int dlg_init(void)
    186          {
    187          	//enote_tip_flag = 0;
    188          	icon_draw_flag = 0;
    189          	//content_font_size = 16;			//大部分窗体内容都是用16号字体，需要改变字体大小来显示窗体内容时，在串口创建时的回调函数中修改此变量即可。
    190          	//auto_run_flag = 0;				//大部分的窗体都是正常的流程，在获取到按键消息之后才进入按键处理的流程
    191          	lowpower_detect_cnt = 0;
    192          	last_power_level = 4;
    193              charge_state_cnt = 0;
    194          	pBGCommand						= OSSemCreate(0);
    195          	return 0;
    196          }
    197          
    198          /**
    199          * @brief 将数字转成键值
    200          */
    201          unsigned char i2key(unsigned char i)
    202          {
    203          	if(i==0)	return KEY_NUM0;
    204          	if(i==1)	return KEY_NUM1;
    205          	if(i==2)	return KEY_NUM2;
    206          	if(i==3)	return KEY_NUM3;
    207          	if(i==4)	return KEY_NUM4;
    208          	if(i==5)	return KEY_NUM5;
    209          	if(i==6)	return KEY_NUM6;
    210          	if(i==7)	return KEY_NUM7;
    211          	if(i==8)	return KEY_NUM8;
    212          	if(i==9)	return KEY_NUM9;
    213          	if(i==11)	return KEY_NUM1;
    214          	if(i==12)   return KEY_NUM2;
    215          	if(i==13)   return KEY_NUM3;
    216          	if(i==14)   return KEY_NUM4;
    217          	return KEY_NUM0;			// 不应到这里哦
    218          }
    219          
    220          /**
    221          * @brief 等待消息,可能是按键、定时器或其他系统消息
    222          * @param[in] unsigned int type
    223          * @return int 
    224          */
    225          static unsigned char *dlg_getmessage(unsigned int type, int timeout)
    226          {
    227          	unsigned char					*pKey = (unsigned char*)0;
    228          	unsigned char					err;
    229          
    230          	pKey							= OSQPend(pKeyOSQ, timeout, &err);
    231          
    232          	return pKey;
    233          
    234          }
    235          
    236          
    237          //清空消息队列里的消息
    238          static void flush_message(void)
    239          {
    240          	OSQFlush(pKeyOSQ);
    241          	return;
    242          }
    243          
    244          
    245          /**
    246          * @brief 计算一个字符串的显示长度
    247          * @param[in] unsigned char *str  需要计算的字符串指针
    248          * @note 由于中文和英文的字模宽度比不在刚好是2:1，所以需要单独一个函数判断一个字符串的显示长度。
    249          */
    250          int disp_len(unsigned char *str)
    251          {
    252          	return strlen(str)*6;
    253          }
    254          
    255          /**
    256          * @brief 重新刷新窗体在DRAW阶段回调中绘制的窗体内容
    257          */
    258          void refresh_draw_content(void)
    259          {
    260          #if 0 
    261          	int i;
    262          	for (i = 0; i<MAX_CASH_ITEM; i++)
    263          	{
    264          		if (draw_content[i].content[0] != 0)
    265          		{
    266          			gui_TextOut(draw_content[i].x,draw_content[i].y,draw_content[i].content,0,1);
    267          		}
    268          	}
    269          #endif
    270          }
    271          
    272          
    273          /**
    274          * @brief 初始化编辑框属性
    275          * @param[in] TEdit *pEdit 要显示的Edit对柄
    276          */
    277          void edit_init(TEdit *pEdit)
    278          {
    279          	unsigned char i = 0;
    280          	unsigned char	j = 0;
    281          	TEditRes	*pEditRes;
    282          
    283          	pEditRes = pEdit->pRes;	
    284          	max_edit = 0;
    285          	all_edit = 0;
    286          
    287          	//创建窗体时，编辑框都已经被清0了
    288          	//memset(pEdit->active,0,MAX_EDIT);
    289          	//memset(pEdit->max,0,MAX_EDIT);
    290          	//memset(pEdit->now,0,MAX_EDIT);
    291          
    292          	do 
    293          	{
    294          		if((pEditRes->style&0x0F) == EDIT_IP)				// ip地址定长为15   [0]123.456.789.abc[15]
    295          		{
    296          			pEdit->display_max[i]		= 15;
    297          			pEdit->input_max[i]			= 15;
    298          			pEdit->now[i]				= 0;
    299          		}
    300          		else if((pEditRes->style&0x0F) == EDIT_MONEY)			//			[8]1234567.2[0]
    301          		{
    302          			pEdit->display_max[i]		= 9;		//规定最多可以输入9位的交易金额
    303          			pEdit->input_max[i]			= 9;
    304          			pEdit->now[i]				= 0;
    305          		}
    306          		else													// 普通					[5]654321[0]
    307          		{
    308          			pEdit->display_max[i]  = pEditRes->display_max_num;
    309          			pEdit->input_max[i]  = pEditRes->input_max_num;
    310          			pEdit->now[i]	= 0;
    311          		}
    312          
    313          		if((pEditRes->style & EDIT_READONLY) == 0)
    314          		{
    315          			pEdit->active[i] = 1;
    316          		}
    317          
    318          		if((pEditRes->style & EDIT_READONLY) == 0)
    319          		{
    320          			max_edit++; //此窗体中包含的总的非只读编辑框的个数
    321          
    322          			//找到第一个非只读的编辑框
    323          			if ((j&0x80) != 0x80)
    324          			{
    325          				j = i;
    326          				j |= 0x80;
    327          			}
    328          		}
    329          
    330          		//编辑框中的字体默认为系统设置的字体大小及颜色
    331          		pEdit->view[i].bg_color = gui_GetBGColor();
    332          		pEdit->view[i].txt_color = gui_GetTextColor();
    333          		pEdit->view[i].font_size = 12;
    334          
    335          		pEdit->display_patch[i] = 0;
    336          
    337          		pEditRes = pEditRes->next;							//指向下一个编辑框的资源
    338                  i++;
    339          	} while (pEditRes != 0);
    340          
    341          	all_edit = i;
    342          	pEdit->current_edit = (j&0x7f);	//默认第一个非只读编辑框为当前编辑框
    343          	pEdit->blink				= 0;
    344          	
    345          
    346          	//pEdit->value				= &g_editValue[0];
    347          	// edit清零
    348          	memset(g_editValue, 0x00, MAX_EDITNUM*MAX_EDIT);
    349          	last_input_key = 0;		//最近一次输入的按键清0
    350          	input_update_flag = 0;
    351          	edit_state = EDIT_STATE_INIT_STATUS;
    352          	the_last_key = 0;
    353          	input_method = _123_INPUT;
    354          }
    355          /**
    356          * @brief 获取窗体当前编辑框的属性
    357          * @param[in] TEdit *pEdit 要显示的Edit对柄
    358          */
    359          static void edit_get_attribute (TEdit *pEdit,TEditAttribute * edit_attr)
    360          {
    361          	TEditRes	* pEditRes;
    362          	unsigned char	i = 0;
    363          
    364          	pEditRes = pEdit->pRes;
    365          
    366          	do 
    367          	{
    368          		if (i == pEdit->current_edit)
    369          		{
    370          			break;
    371          		}
    372          		i ++;
    373          		pEditRes = pEditRes->next;
    374          	} while (pEditRes != 0);
    375          
    376          	edit_attr->x = pEditRes->x;
    377          	edit_attr->y = pEditRes->y;
    378          	edit_attr->style = pEditRes->style;
    379          	if (g_dlg.pRes->style & STYLE_CHILDWINDOW)		//注意子窗体中的编辑框的位置是相对于子窗体位置的相对坐标
    380          	{
    381          		edit_attr->x += DEFAULT_CHILDWINDOW_X; 
    382          		edit_attr->y += DEFAULT_CHILDWINDOW_Y;
    383          	}
    384          }
    385          
    386          /**
    387          * @brief 将键值转换为输出的金额字符串
    388          * @param[in] unsigned char *keyvalue 要转换的键值
    389          * @note 先输入的键值先输出
    390          */
    391          #if 0
    392          static void edit_to_amount(unsigned char* keyvalue ,unsigned char * out,unsigned char len)
    393          {
    394          	unsigned char i,j = 0;
    395          	if(len < 3)
    396          	{
    397          		out[0] = '0';
    398          		out[1] = '.';
    399          		for(i=0; i<len; i++)
    400          		{
    401          			out[2+i] = *key2ascii(keyvalue[i]);
    402          		}
    403          
    404          		if (len == 0)
    405          		{
    406          			out[2] = '0';
    407          			out[3] = '0';
    408          		}
    409          
    410          		if (len == 1)
    411          		{
    412          			out[3] = out[2];
    413          			out[2] = '0';
    414          		}
    415          
    416          		out[4] = 0;
    417          	}
    418          	else
    419          	{
    420          		for (i=0;i<len;i++)
    421          		{
    422          			if (i == len - 2)
    423          			{
    424          				j = 1;
    425          				out[i] = '.';
    426          			}
    427          			out[i+j] = *key2ascii(keyvalue[i]);
    428          		}
    429          		out[len+1] = 0;
    430          	}
    431          }
    432          #endif
    433          /**
    434          * @brief 设置某一个编辑框中显示的字体大小
    435          * @param[in] unsigned char size			字体大小
    436          * @param[in] unsigned char edit_index	编辑框索引
    437          * @note 设置的字体大小只是在此窗体的生命期内有效,在窗体的DRAW阶段之后的回调接口中调用才会生效
    438          */
    439          void edit_set_Font(TEdit *pEdit,unsigned char size,unsigned char edit_index)
    440          {
    441          	if ((size == 12)||(size == 16)||(size == 24))
    442          	{
    443          		pEdit->view[edit_index].font_size = size;
    444          	}
    445          	return;
    446          }
    447          
    448          /**
    449          * @brief 设置某一个编辑框中显示的字体的背景色
    450          * @param[in] unsigned short color		颜色
    451          * @param[in] unsigned char edit_index	编辑框索引
    452          * @note 设置的字体大小只是在此窗体的生命期内有效,在窗体的DRAW阶段之后的回调接口中调用才会生效
    453          */
    454          void edit_set_BgColor(TEdit *pEdit,unsigned short color,unsigned char edit_index)
    455          {
    456          	pEdit->view[edit_index].bg_color = color;
    457          	return;
    458          }
    459          
    460          /**
    461          * @brief 设置某一个编辑框中显示的字体的背景色
    462          * @param[in] unsigned short color		颜色
    463          * @param[in] unsigned char edit_index	编辑框索引
    464          * @note 设置的字体大小只是在此窗体的生命期内有效,在窗体的DRAW阶段之后的回调接口中调用才会生效
    465          */
    466          void edit_set_TextColor(TEdit *pEdit,unsigned short color,unsigned char edit_index)
    467          {
    468          	pEdit->view[edit_index].txt_color = color;
    469          	return;
    470          }
    471          /**
    472          * @brief edit刷新编辑框的显示
    473          * @param[in] unsigned char mode  0:刷新当前窗体的所有的编辑框   1:刷新指定的编辑框
    474          * @note 输入后，EditValue中填的是键值，而不是ascii，显示时需要转换
    475          * @note
    476          */
    477          void edit_refresh(TEdit *pEdit,unsigned char mode,unsigned char edit_index)
    478          {
    479          	int								i,j;
    480          	TEditAttribute					edit_attr;			//当前编辑框的属性
    481          	unsigned char					current_edit,edit_save;
    482          	int								disp_len;
    483          	TEditRes						* pEditRes;
    484          	unsigned char					amount[10];
    485              unsigned char					str[38];
    486          	unsigned int					x,y;
    487          	unsigned char					offset;
    488          
    489          
    490          	pEditRes = pEdit->pRes;
    491          	edit_save = pEdit->current_edit;	//保存当前编辑框
    492          
    493          	pEdit->current_edit = 0;
    494          
    495          	do 
    496          	{
    497          		j = 0;
    498          		current_edit = pEdit->current_edit;
    499          		edit_get_attribute(pEdit,&edit_attr);		//获取当前编辑框的相关属性
    500          		//if ((edit_attr.style & 0x80) == EDIT_MUL_LINE)
    501          		//{
    502          		//	edit_display_x_patch = 0;
    503          		//}
    504          
    505          		//pEdit->display_patch[current_edit] = 0;
    506          
    507          		if (edit_attr.y + 13*((pEdit->display_max[current_edit]-1)/20) > GUI_HEIGHT - SHOTCUT_HEIGNT - 12)
    508          		{
    509          			if(0 == mode)
    510          			{
    511          				break;
    512          			}
    513          			else
    514          			{
    515          				//编辑框的纵坐标大于显示区域
    516          				edit_attr.y = ICON_HEIGHT + 18 + edit_attr.y - (GUI_HEIGHT - SHOTCUT_HEIGNT );
    517          			}
    518          		}
    519          
    520          
    521          		if ((mode == 0) || (edit_index == current_edit))
    522          		{ 
    523          			if((edit_attr.style & 0x07) == EDIT_IP)				// 顺序排列 0.1.2.3.4.5.6
    524          			{
    525          				///STEP2:清除显示
    526          				memset(str,' ',(GUI_WIDTH - edit_attr.x)/(gFontSize/2));
    527          				str[(GUI_WIDTH - edit_attr.x)/(gFontSize/2)] = 0;
    528          				gui_TextOut(edit_attr.x, edit_attr.y, str, 1,1);
    529          
    530          				///STEP3:显示输出
    531          				for(i=0; i<pEdit->now[current_edit]; i++)									/// 
    532          				{
    533          					if ((i==3) ||(i==6)||(i==9))
    534          					{
    535          						j = 12*(i/3);
    536          					}
    537          					gui_TextOut(edit_attr.x + i*gFontSize/2 + j, edit_attr.y, key2ascii(g_editValue[current_edit][i]), 0,1);
    538          				}
    539          				///STEP4:下划线
    540          				if(edit_attr.style & EDIT_UNDERLINE)
    541          				{
    542          					gui_LineH(edit_attr.x, edit_attr.y + gFontSize-1, 3 * gFontSize/2, TXT_COLOR,1);
    543          					gui_LineH(edit_attr.x + 4 * gFontSize/2, edit_attr.y + gFontSize-1, 3 * gFontSize/2, TXT_COLOR,1);
    544          					gui_LineH(edit_attr.x + 8 * gFontSize/2, edit_attr.y + gFontSize-1, 3 * gFontSize/2, TXT_COLOR,1);
    545          					gui_LineH(edit_attr.x + 12 * gFontSize/2, edit_attr.y + gFontSize-1, 3 * gFontSize/2, TXT_COLOR,1);
    546          				}
    547          
    548          				//STEP5:显示分隔符
    549          				gui_TextOut(edit_attr.x + 3*gFontSize/2, edit_attr.y, ".", 0,1);
    550          				gui_TextOut(edit_attr.x + 7*gFontSize/2, edit_attr.y, ".", 0,1);
    551          				gui_TextOut(edit_attr.x + 11*gFontSize/2, edit_attr.y, ".", 0,1);
    552          			}
    553          			else if(((edit_attr.style & 0x07) == EDIT_PSW)||((edit_attr.style & 0x07) == EDIT_PSW_S))		
    554          			{
    555          				///STEP2:清除显示
    556          				memset(str,' ',(GUI_WIDTH - edit_attr.x)/(gFontSize/2));
    557          				str[(GUI_WIDTH - edit_attr.x)/(gFontSize/2)] = 0;
    558          				gui_TextOut(edit_attr.x, edit_attr.y, str, 1,1);
    559          
    560          
    561          				///STEP3:显示输出
    562          				for(i=0; i<pEdit->now[current_edit]; i++)									/// * * * * * *
    563          					gui_TextOut(edit_attr.x + i*gFontSize/2, edit_attr.y, "*", 0,1);
    564          
    565          				///STEP4:下划线
    566          				if(edit_attr.style & EDIT_UNDERLINE)
    567          					gui_LineH(edit_attr.x, edit_attr.y + gFontSize-1, pEdit->display_max[current_edit] * gFontSize/2, TXT_COLOR,1);
    568          			}
    569          			else if((edit_attr.style & 0x07) == EDIT_NUM)
    570          			{
    571          				/// STEP2:清除显示
    572          				memset(str,' ',pEdit->display_max[current_edit]);
    573          				str[pEdit->display_max[current_edit]] = 0;
    574          				gui_TextOut(edit_attr.x, edit_attr.y, str, (((edit_attr.style & 0x10) == EDIT_NO_BLINK)?2:1),1);
    575          
    576          				if ((edit_attr.style & 0x10) == EDIT_NO_BLINK)
    577          				{
    578          					gui_TextOut(4, edit_attr.y, "                    ", 2,1);
    579          				}
    580          
    581          				/// STEP3:输出字符
    582          				offset = pEdit->now[current_edit]<pEdit->display_max[current_edit]?0:(pEdit->now[current_edit]-pEdit->display_max[current_edit]);
    583          				for(i=0; i<(pEdit->now[current_edit]<pEdit->display_max[current_edit]?pEdit->now[current_edit]:pEdit->display_max[current_edit]); i++)
    584          				{
    585          					if((edit_attr.style & 0x10) == EDIT_NO_BLINK)
    586          					{
    587          						gui_TextOut(edit_attr.x + ((g_dlg.edit.display_max[current_edit]-1)-i)*gFontSize/2, edit_attr.y, key2ascii(g_editValue[current_edit][g_dlg.edit.now[current_edit] - i -1]), 2,1);
    588          					}
    589          					else
    590          					{
    591          						gui_TextOut(edit_attr.x + i*gFontSize/2, edit_attr.y, key2ascii(g_editValue[current_edit][offset+i]), 0,1);
    592          					}				
    593          				}
    594          
    595          				if(((edit_attr.style & 0x10) == EDIT_NO_BLINK)&&(pEdit->now[current_edit] == 0))
    596          				{
    597          					gui_TextOut(edit_attr.x+(g_dlg.edit.display_max[current_edit]-1)*gFontSize/2, edit_attr.y, "0", 2,1);
    598          				}
    599          				/// STEP4:下划线
    600          				if(edit_attr.style & EDIT_UNDERLINE)
    601          					gui_LineH(edit_attr.x, edit_attr.y + gFontSize+1, pEdit->display_max[current_edit] * gFontSize/2, TXT_COLOR,1);
    602          
    603          			}
    604          			else if((edit_attr.style & 0x07) == EDIT_MONEY)		// 倒序排列
    605          			{
    606          				// STEP2:清除显示
    607          				memset(str,' ',pEdit->display_max[current_edit]);
    608          				str[pEdit->display_max[current_edit]] = 0;
    609          				gui_TextOut(edit_attr.x, edit_attr.y, str, 1,1);
    610          
    611          				// STEP3显示输出
    612          
    613          				// 输出字符,从最后一字节往前显示,注意加上小数点和货币符号
    614          				if(edit_attr.style & EDIT_READONLY)
    615          				{
    616          					disp_len	= 0;
    617          					while(g_editValue[current_edit][disp_len] != 0x00)
    618          						disp_len++;
    619          				}
    620          				else
    621          					disp_len				= pEdit->now[current_edit];
    622          
    623          				//edit_to_amount(g_editValue[current_edit],amount,disp_len);
    624          				//gui_TextOut(edit_attr.x + (pEdit->max[current_edit] - strlen((char const*)amount))*gFontSize/2,edit_attr.y,amount,0);
    625          				//for(i=0; i<disp_len; i++)
    626          				{
    627          					gui_TextOut(edit_attr.x, edit_attr.y, g_editValue[current_edit], 0,1);			
    628          				}
    629          
    630          				// STEP4:下划线
    631          				if(edit_attr.style & EDIT_UNDERLINE)
    632          					gui_LineH(edit_attr.x, edit_attr.y + gFontSize+1, pEdit->display_max[current_edit] * gFontSize/2, TXT_COLOR,1);
    633          			}
    634          			else if ((edit_attr.style & 0x07) == EDIT_CHINESE || (edit_attr.style & 0x07) == EDIT_ALPHA)		
    635          			{
    636          				/// STEP2:清除显示
    637          				memset(str,' ',pEdit->display_max[current_edit]+pEdit->display_patch[current_edit]/6);
    638          				str[pEdit->display_max[current_edit]+pEdit->display_patch[current_edit]/6] = 0;
    639          				gui_TextOut(edit_attr.x, edit_attr.y, str, 1,1);
    640                                          
    641          
    642          				//if((edit_attr.style & 0x80) == EDIT_MUL_LINE)
    643          				//{
    644          				//	gui_FillRect(0,edit_attr.y + gFontSize,GUI_WIDTH,gFontSize*4,BG_COLOR);	
    645          				//}
    646          
    647          				//for(i=0; i<pEdit->max[current_edit]; i++)
    648          				//	gui_TextOut(edit_attr.x + i*gFontSize/2, edit_attr.y, " ", 1);
    649          
    650          				/// STEP3:输出字符,
    651          				offset = pEdit->now[current_edit]<pEdit->display_max[current_edit]?0:(pEdit->now[current_edit]-pEdit->display_max[current_edit]);
    652          				//判断是否将一个汉字的前半字节截断了
    653          				for (i=0;i<offset;i++)
    654          				{
    655          					if (g_editValue[current_edit][i] > 0x80)
    656          					{
    657          						i++;
    658          					}
    659          				}
    660          
    661          				if(i>offset)
    662          				{
    663          					offset++;
    664          				}
    665          
    666          				gui_TextOut(edit_attr.x, edit_attr.y, &g_editValue[current_edit][offset], 0,1);
    667          
    668          				pEdit->display_patch[current_edit] = edit_display_x_patch;
    669          				edit_display_x_patch = 0;
    670          
    671          				/// STEP4:下划线
    672          				if(edit_attr.style & EDIT_UNDERLINE)
    673          					gui_LineH(edit_attr.x, edit_attr.y + gFontSize+1, pEdit->display_max[current_edit] * gFontSize/2 + pEdit->display_patch[current_edit], TXT_COLOR,1);
    674          
    675          			}
    676          		}
    677          
    678          		//if(pEdit->max[current_edit] == (pEdit->now[current_edit] + 1) || pEdit->max[current_edit] == pEdit->now[current_edit])
    679          		{
    680          			//清除可能还在闪烁的光标
    681          			x = edit_attr.x + pEdit->display_max[current_edit]*gFontSize/2+pEdit->display_patch[current_edit];
    682          			y = edit_attr.y;
    683          
    684          			while(x >= GUI_WIDTH)
    685          			{
    686          				x -= GUI_WIDTH;
    687          				y += 13;
    688          			}
    689          
    690          			gui_LineV(x,y+1,11,BG_COLOR);
    691          		}
    692          
    693          	
    694          
    695          		if ((mode == 1)&&(edit_index == current_edit))
    696          		{
    697          			//只需要刷新了要刷新的编辑框即可，跳出
    698          			break;
    699          		}
    700          
    701          		pEdit->current_edit++;
    702          		pEditRes = pEditRes->next;
    703          	} while (pEditRes != 0);
    704          
    705          	pEdit->current_edit = edit_save;		//恢复当前的编辑框
    706          	return;
    707          }
    708          
    709          /**
    710          * @brief edit刷新编辑框的显示
    711          * @param[in] unsigned char mode  0:刷新当前窗体的所有的编辑框   1:刷新指定的编辑框
    712          * @param[out] unsigned char *buffer  将原来编辑框中的键值保存到虚拟键盘的缓冲区
    713          * @note 输入后，EditValue中填的是键值，而不是ascii，显示时需要转换
    714          * @note
    715          */
    716          unsigned char edit_refresh_ext(TEdit *pEdit)
    717          {
    718          	int								i,j;
    719          	TEditAttribute					edit_attr;			//当前编辑框的属性
    720          	unsigned char					current_edit;
    721          	int								disp_len;
    722          	TEditRes						* pEditRes;
    723          	unsigned char					amount[10];
    724          	unsigned char					str[38];
    725          	unsigned int					x,y;
    726          	unsigned char					offset;
    727          	unsigned char					virtual_keypad_type;
    728          
    729          
    730          	pEditRes = pEdit->pRes;
    731          
    732          	current_edit = pEdit->current_edit;
    733          	edit_get_attribute(pEdit,&edit_attr);		//获取当前编辑框的相关属性
    734          	edit_attr.x = 0;
    735          	edit_attr.y = 0;
    736          	edit_attr.style &= ~EDIT_UNDERLINE;
    737          	gui_SetTextColor(TXT_COLOR);
    738          
    739          	{ 
    740          		if((edit_attr.style & 0x07) == EDIT_IP)				// 顺序排列 0.1.2.3.4.5.6
    741          		{
    742          			///STEP2:清除显示
    743          			memset(str,' ',(GUI_WIDTH - edit_attr.x)/(gFontSize/2));
    744          			str[(GUI_WIDTH - edit_attr.x)/(gFontSize/2)] = 0;
    745          			gui_TextOut(edit_attr.x, edit_attr.y, str, 1,1);
    746          
    747          			///STEP3:显示输出
    748          			for(i=0; i<pEdit->now[current_edit]; i++)									/// 
    749          			{
    750          				if ((i==3) ||(i==6)||(i==9))
    751          				{
    752          					j = 12*(i/3);
    753          				}
    754          				gui_TextOut(edit_attr.x + i*gFontSize/2 + j, edit_attr.y, key2ascii(g_editValue[current_edit][i]), 0,1);
    755          			}
    756          			///STEP4:下划线
    757          			//if(edit_attr.style & EDIT_UNDERLINE)
    758          			//{
    759          			//	gui_LineH(edit_attr.x, edit_attr.y + gFontSize-1, 3 * gFontSize/2, TXT_COLOR);
    760          			//	gui_LineH(edit_attr.x + 4 * gFontSize/2, edit_attr.y + gFontSize-1, 3 * gFontSize/2, TXT_COLOR);
    761          			//	gui_LineH(edit_attr.x + 8 * gFontSize/2, edit_attr.y + gFontSize-1, 3 * gFontSize/2, TXT_COLOR);
    762          			//	gui_LineH(edit_attr.x + 12 * gFontSize/2, edit_attr.y + gFontSize-1, 3 * gFontSize/2, TXT_COLOR);
    763          			//}
    764          
    765          			//STEP5:显示分隔符
    766          			gui_TextOut(edit_attr.x + 3*gFontSize/2, edit_attr.y, ".", 0,1);
    767          			gui_TextOut(edit_attr.x + 7*gFontSize/2, edit_attr.y, ".", 0,1);
    768          			gui_TextOut(edit_attr.x + 11*gFontSize/2, edit_attr.y, ".", 0,1);
    769          			virtual_keypad_type = VIRTUAL_KEYPAD_TYPE_NUM;
    770          		}
    771          		else if(((edit_attr.style & 0x07) == EDIT_PSW)||((edit_attr.style & 0x07) == EDIT_PSW_S))		
    772          		{
    773          			///STEP2:清除显示
    774          			memset(str,' ',(GUI_WIDTH - edit_attr.x)/(gFontSize/2));
    775          			str[(GUI_WIDTH - edit_attr.x)/(gFontSize/2)] = 0;
    776          			gui_TextOut(edit_attr.x, edit_attr.y, str, 1,1);
    777          
    778          
    779          			///STEP3:显示输出
    780          			for(i=0; i<pEdit->now[current_edit]; i++)									/// * * * * * *
    781          				gui_TextOut(edit_attr.x + i*gFontSize/2, edit_attr.y, "*", 0,1);
    782          
    783          			///STEP4:下划线
    784          			//if(edit_attr.style & EDIT_UNDERLINE)
    785          			//	gui_LineH(edit_attr.x, edit_attr.y + gFontSize-1, pEdit->display_max[current_edit] * gFontSize/2, TXT_COLOR);
    786          			virtual_keypad_type = VIRTUAL_KEYPAD_TYPE_ALPHA;
    787          		}
    788          		else if((edit_attr.style & 0x07) == EDIT_NUM)
    789          		{
    790          			/// STEP2:清除显示
    791          			memset(str,' ',pEdit->display_max[current_edit]);
    792          			str[pEdit->display_max[current_edit]] = 0;
    793          			gui_TextOut(edit_attr.x, edit_attr.y, str, (((edit_attr.style & 0x10) == EDIT_NO_BLINK)?2:1),1);
    794          
    795          			if ((edit_attr.style & 0x10) == EDIT_NO_BLINK)
    796          			{
    797          				gui_TextOut(4, edit_attr.y, "                    ", 2,1);
    798          			}
    799          
    800          			/// STEP3:输出字符
    801          			offset = pEdit->now[current_edit]<pEdit->display_max[current_edit]?0:(pEdit->now[current_edit]-pEdit->display_max[current_edit]);
    802          			for(i=0; i<(pEdit->now[current_edit]<pEdit->display_max[current_edit]?pEdit->now[current_edit]:pEdit->display_max[current_edit]); i++)
    803          			{
    804          				if((edit_attr.style & 0x10) == EDIT_NO_BLINK)
    805          				{
    806          					gui_TextOut(edit_attr.x + ((g_dlg.edit.display_max[current_edit]-1)-i)*gFontSize/2, edit_attr.y, key2ascii(g_editValue[current_edit][g_dlg.edit.now[current_edit] - i -1]), 2,1);
    807          				}
    808          				else
    809          				{
    810          					gui_TextOut(edit_attr.x + i*gFontSize/2, edit_attr.y, key2ascii(g_editValue[current_edit][offset+i]), 0,1);
    811          				}				
    812          			}
    813          
    814          			if(((edit_attr.style & 0x10) == EDIT_NO_BLINK)&&(pEdit->now[current_edit] == 0))
    815          			{
    816          				gui_TextOut(edit_attr.x+(g_dlg.edit.display_max[current_edit]-1)*gFontSize/2, edit_attr.y, "0", 2,1);
    817          			}
    818          			/// STEP4:下划线
    819          			//if(edit_attr.style & EDIT_UNDERLINE)
    820          			//	gui_LineH(edit_attr.x, edit_attr.y + gFontSize+1, pEdit->display_max[current_edit] * gFontSize/2, TXT_COLOR);
    821          			virtual_keypad_type = VIRTUAL_KEYPAD_TYPE_NUM;
    822          		}
    823          		else if((edit_attr.style & 0x07) == EDIT_MONEY)		// 倒序排列
    824          		{
    825          			// STEP2:清除显示
    826          			memset(str,' ',pEdit->display_max[current_edit]);
    827          			str[pEdit->display_max[current_edit]] = 0;
    828          			gui_TextOut(edit_attr.x, edit_attr.y, str, 1,1);
    829          
    830          			// STEP3显示输出
    831          
    832          			// 输出字符,从最后一字节往前显示,注意加上小数点和货币符号
    833          			if(edit_attr.style & EDIT_READONLY)
    834          			{
    835          				disp_len	= 0;
    836          				while(g_editValue[current_edit][disp_len] != 0x00)
    837          					disp_len++;
    838          			}
    839          			else
    840          				disp_len				= pEdit->now[current_edit];
    841          
    842          			//edit_to_amount(g_editValue[current_edit],amount,disp_len);
    843          			//gui_TextOut(edit_attr.x + (pEdit->max[current_edit] - strlen((char const*)amount))*gFontSize/2,edit_attr.y,amount,0);
    844          			//for(i=0; i<disp_len; i++)
    845          			{
    846          				gui_TextOut(edit_attr.x, edit_attr.y, g_editValue[current_edit], 0,1);			
    847          			}
    848          
    849          			// STEP4:下划线
    850          			//if(edit_attr.style & EDIT_UNDERLINE)
    851          			//	gui_LineH(edit_attr.x, edit_attr.y + gFontSize+1, pEdit->display_max[current_edit] * gFontSize/2, TXT_COLOR);
    852          			virtual_keypad_type = VIRTUAL_KEYPAD_TYPE_NUM;
    853          		}
    854          		//else if ((edit_attr.style & 0x07) == EDIT_CHINESE || (edit_attr.style & 0x07) == EDIT_ALPHA)		
    855          		else if ((edit_attr.style & 0x07) == EDIT_ALPHA)		
    856          		{
    857          			/// STEP2:清除显示
    858          			memset(str,' ',pEdit->display_max[current_edit]+pEdit->display_patch[current_edit]/6);
    859          			str[pEdit->display_max[current_edit]+pEdit->display_patch[current_edit]/6] = 0;
    860          			gui_TextOut(edit_attr.x, edit_attr.y, str, 1,1);
    861          
    862          
    863          			//if((edit_attr.style & 0x80) == EDIT_MUL_LINE)
    864          			//{
    865          			//	gui_FillRect(0,edit_attr.y + gFontSize,GUI_WIDTH,gFontSize*4,BG_COLOR);	
    866          			//}
    867          
    868          			//for(i=0; i<pEdit->max[current_edit]; i++)
    869          			//	gui_TextOut(edit_attr.x + i*gFontSize/2, edit_attr.y, " ", 1);
    870          
    871          			/// STEP3:输出字符,
    872          			offset = pEdit->now[current_edit]<pEdit->display_max[current_edit]?0:(pEdit->now[current_edit]-pEdit->display_max[current_edit]);
    873          			//判断是否将一个汉字的前半字节截断了
    874          			for (i=0;i<offset;i++)
    875          			{
    876          				if (g_editValue[current_edit][i] > 0x80)
    877          				{
    878          					i++;
    879          				}
    880          			}
    881          
    882          			if(i>offset)
    883          			{
    884          				offset++;
    885          			}
    886          
    887          			gui_TextOut(edit_attr.x, edit_attr.y, &g_editValue[current_edit][offset], 0,1);
    888          
    889          			pEdit->display_patch[current_edit] = edit_display_x_patch;
    890          			edit_display_x_patch = 0;
    891          
    892          			/// STEP4:下划线
    893          			//if(edit_attr.style & EDIT_UNDERLINE)
    894          			//	gui_LineH(edit_attr.x, edit_attr.y + gFontSize+1, pEdit->display_max[current_edit] * gFontSize/2 + pEdit->display_patch[current_edit], TXT_COLOR);
    895          			virtual_keypad_type = VIRTUAL_KEYPAD_TYPE_ALPHA;
    896          		}
    897          	}
    898          
    899          	//if(pEdit->max[current_edit] == (pEdit->now[current_edit] + 1) || pEdit->max[current_edit] == pEdit->now[current_edit])
    900          	{
    901          		//清除可能还在闪烁的光标
    902          		x = edit_attr.x + pEdit->display_max[current_edit]*gFontSize/2+pEdit->display_patch[current_edit];
    903          		y = edit_attr.y;
    904          
    905          		while(x >= GUI_WIDTH)
    906          		{
    907          			x -= GUI_WIDTH;
    908          			y += 13;
    909          		}
    910          
    911          		gui_LineV(x,y+1,11,BG_COLOR);
    912          	}
    913          
    914          	return virtual_keypad_type;
    915          }
    916          
    917          
    918          /**
    919          * @brief 虚拟键盘的处理函数
    920          * @note 输入后，EditValue中填的是键值，而不是ascii，显示时需要转换
    921          * @param[in] unsigned char type:虚拟键盘的类型  数字型  和 字母型
    922          * @param[in] unsigned char key:键值 0:初始化键盘
    923          */
    924          unsigned char virtual_keypad_proc(unsigned char type,unsigned char key)
    925          {
    926          	static unsigned char	x,y,start_y;
    927                  unsigned char           i,j;
    928          	unsigned char		str[2],tmp[2];
    929          	unsigned char		key_array_1[2][5] = {{'0','1','2','3','4'},
    930          											  {'5','6','7','8','9'}
    931          											 };
    932          	unsigned char		key_array_2[11][9] = {{'0','1','2','3','4','5','6','7','8'},
    933          											{'9','A','B','C','D','E','F','G','H'},
    934          											{'I','J','K','L','M','N','O','P','Q'},
    935          											{'R','S','T','U','V','W','X','Y','Z'},
    936          											{'a','b','c','d','e','f','g','h','i'},
    937          											{'j','k','l','m','n','o','p','q','r'},
    938          											{'s','t','u','v','w','x','y','z','!'},
    939          											{'"','#','$','%','&','\'','(',')','*'},
    940          											{'+',',','-','.','/',':',';','<','='},
    941          											{'>','?','@','[','\\',']','^','_','`'},
    942          											{'{','|','}','~',' ',' ',' ',' ',' '}
    943          										   };
    944          
    945          	if (key == 0)
    946          	{
    947          		x = 0;
    948          		y = 0;
    949          		start_y = 0;
    950          	}
    951          	else if (key == KEY_UP)
    952          	{
    953          		if (type == VIRTUAL_KEYPAD_TYPE_NUM)
    954          		{
    955          			y = (y == 1)?0:1;
    956          		}
    957          		else if(type == VIRTUAL_KEYPAD_TYPE_ALPHA)
    958          		{
    959          			if(x > 4)
    960          			{
    961          				if(y == 0)
    962          					y = 9;
    963          				else
    964          					y--;
    965          			}
    966          			else
    967          			{
    968          				if(y == 0)
    969          					y = 10;
    970          				else
    971          					y--;
    972          			}
    973          
    974          			if((start_y == 0)&&(y == 9 || y == 10))
    975          			{
    976          				start_y = 8;
    977          			}
    978          			else
    979          			{
    980          				if(y < start_y)  
    981          					start_y --;
    982          			}
    983          		}
    984          	}
    985          	else if (key == KEY_DOWN)
    986          	{
    987          		if (type == VIRTUAL_KEYPAD_TYPE_NUM)
    988          		{
    989          			y = (y == 1)?0:1;
    990          		}
    991          		else if(type == VIRTUAL_KEYPAD_TYPE_ALPHA)
    992          		{
    993          			if(x > 4)
    994          			{
    995          				if(y == 9)
    996          					y = 0;
    997          				else
    998          					y++;
    999          			}
   1000          			else
   1001          			{
   1002          				if(y == 10)
   1003          					y = 0;
   1004          				else
   1005          					y++;
   1006          			}
   1007          
   1008          			if(y == 0)
   1009          			{
   1010          				start_y = 0;
   1011          			}
   1012          			else
   1013          			{
   1014          				if((y - start_y)>2)  
   1015          					start_y ++;
   1016          			}
   1017          		}
   1018          	}
   1019          	else if (key == KEY_LEFT)
   1020          	{
   1021          		if (type == VIRTUAL_KEYPAD_TYPE_NUM)
   1022          		{
   1023          			if(x == 0)
   1024          			{
   1025          				y = (y == 1)?0:1;
   1026          				x = 4;
   1027          			}
   1028          			else
   1029          			{
   1030          				x--;
   1031          			}
   1032          		}
   1033          		else if(type == VIRTUAL_KEYPAD_TYPE_ALPHA)
   1034          		{
   1035          			if(x == 0)
   1036          			{
   1037          				if(y == 0)
   1038          				{
   1039          					y = 10;
   1040          					x = 4;
   1041          				}
   1042          				else
   1043          				{
   1044          					y--;
   1045          					x = 8;
   1046          				}
   1047          			}
   1048          			else
   1049          			{
   1050          				x--;
   1051          			}
   1052          
   1053          			if((start_y == 0)&&(y == 10))
   1054          			{
   1055          				start_y = 8;
   1056          			}
   1057          			else
   1058          			{
   1059          				if(y < start_y)  
   1060          					start_y --;
   1061          			}
   1062          		}
   1063          	}
   1064          	else if (key == KEY_RIGHT)
   1065          	{
   1066          		if (type == VIRTUAL_KEYPAD_TYPE_NUM)
   1067          		{
   1068          			if(x == 4)
   1069          			{
   1070          				y = (y == 1)?0:1;
   1071          				x = 0;
   1072          			}
   1073          			else
   1074          			{
   1075          				x++;
   1076          			}
   1077          		}
   1078          		else if(type == VIRTUAL_KEYPAD_TYPE_ALPHA)
   1079          		{
   1080          			if((x == 8)&&(y<10))
   1081          			{
   1082          				x = 0;
   1083          				y++;
   1084          			}
   1085          			else
   1086          			{
   1087          				if((x == 4)&&(y == 10))
   1088          				{
   1089          					x = 0;
   1090          					y = 0;
   1091          				}
   1092          				else
   1093          				{
   1094          					x++;
   1095          				}
   1096          			}
   1097          
   1098          			if(y == 0)
   1099          			{
   1100          				start_y = 0;
   1101          			}
   1102          			else
   1103          			{
   1104          				if((y - start_y)>2)  
   1105          					start_y ++;
   1106          			}
   1107          		}
   1108          	}
   1109          	else if (key == KEY_ENTER || key == KEY_SCAN)
   1110          	{
   1111          		if (type == VIRTUAL_KEYPAD_TYPE_NUM)
   1112          		{
   1113          			str[0] = key_array_1[y][x];
   1114          		}
   1115          		else if(type == VIRTUAL_KEYPAD_TYPE_ALPHA)
   1116          		{
   1117          			str[0] = key_array_2[y][x];
   1118          		}
   1119          
   1120          		str[1] = 0;
   1121          		edit_stoe(str,1,tmp);
   1122          		return tmp[0];
   1123          	}
   1124          
   1125          	if (type == VIRTUAL_KEYPAD_TYPE_NUM)
   1126          	{
   1127          		for (i = 0; i < 10;i++)
   1128          		{
   1129          			str[0] = key_array_1[i/5][i%5];
   1130          			str[1] = 0;
   1131          			if ((5*y+x) == i)
   1132          			{
   1133          				gui_SetTextColor(BG_COLOR);
   1134          			}
   1135          			else
   1136          			{
   1137          				gui_SetTextColor(TXT_COLOR);
   1138          			}
   1139          			gui_TextOut((i%5)*12+6,13*((i/5) + 1),str,0,0);
   1140          		}
   1141          
   1142          		gui_refresh(0,0,LCD_WIDTH,LCD_HEIGHT);
   1143          	}
   1144          	else if (type == VIRTUAL_KEYPAD_TYPE_ALPHA)
   1145          	{
   1146          		for(i = 0; i < 3;i++)
   1147          		{
   1148          			for(j = 0; j < 9;j++)
   1149          			{
   1150          				str[0] = key_array_2[start_y+i][j];
   1151          				str[1] = 0;
   1152          				if ((start_y+i) == y && j == x)
   1153          				{
   1154          					gui_SetTextColor(BG_COLOR);
   1155          				}
   1156          				else
   1157          				{
   1158          					gui_SetTextColor(TXT_COLOR);
   1159          				}
   1160          				gui_TextOut(j*12+6,13*(i + 1),str,0,0);
   1161          			}
   1162          		}
   1163          
   1164          		gui_refresh(0,0,LCD_WIDTH,LCD_HEIGHT);
   1165          	}
   1166          	return 0;
   1167          }
   1168          //
   1169          /**
   1170          * @brief edit处理一个按键消息
   1171          * @note 输入后，EditValue中填的是键值，而不是ascii，显示时需要转换
   1172          * @param[in] int key输入的键值,其中:
   1173          *            KEY_CLEAR 删除前一个输入字符
   1174          *            KEY_ENTER 刷新显示
   1175          *            KEY_NUM0..KEY_NUM9 输入
   1176          */
   1177          static void edit_proc(TEdit *pEdit, unsigned char key,unsigned char virtual_keypad_flag)
   1178          {
   1179          	TEditAttribute					edit_attr;			//当前编辑框的属性
   1180          	unsigned char					current_edit;
   1181          	unsigned char					if_update_cursor;
   1182          	unsigned char					key_code[11];
   1183          	unsigned char					i;
   1184          
   1185          	current_edit = pEdit->current_edit;
   1186          	
   1187          
   1188          	edit_get_attribute(pEdit,&edit_attr);		//获取当前编辑框的相关属性
   1189          
   1190          	if((edit_attr.style & 0x07) == EDIT_IP)				/// 顺序排列 0.1.2.3.4.5.6
   1191          	{
   1192          		///STEP1:逻辑处理
   1193          		if((edit_attr.style & EDIT_READONLY)==0)
   1194          		{
   1195          			if(key==KEY_CLEAR)
   1196          			{
   1197          				if(pEdit->now[current_edit])
   1198          				{
   1199          					if (pEdit->now[current_edit] == 4 || pEdit->now[current_edit] ==8 || pEdit->now[current_edit] == 12)
   1200          					{
   1201          						pEdit->now[current_edit]--;
   1202          						g_editValue[current_edit][pEdit->now[current_edit]] = 0x00;
   1203          					}
   1204          					pEdit->now[current_edit]--;
   1205          					g_editValue[current_edit][pEdit->now[current_edit]] = 0x00;
   1206          				}
   1207          			}
   1208          			else if (KEY_ENTER == key || KEY_UP == key || KEY_DOWN == key)
   1209          			{
   1210          
   1211          			}
   1212          			else if (KEY_FUN4 == key)
   1213          			{
   1214          				pEdit->now[current_edit] = 0;
   1215          				memset((void*)g_editValue[current_edit],0,MAX_EDITNUM);
   1216          			}
   1217          			else
   1218          			{
   1219          				/// 允许输入
   1220          				if(pEdit->now[current_edit] < pEdit->input_max[current_edit])	
   1221          					g_editValue[current_edit][pEdit->now[current_edit]++]	= key;
   1222          				if (pEdit->now[current_edit] == 3 || pEdit->now[current_edit] == 7 || pEdit->now[current_edit] == 11)
   1223          				{
   1224          					g_editValue[current_edit][pEdit->now[current_edit]++]	= KEY_juhao;
   1225          				}
   1226          			}
   1227          		}
   1228          	}
   1229          	else if(((edit_attr.style & 0x07) == EDIT_PSW)||((edit_attr.style & 0x07) == EDIT_PSW_S))
   1230          	{
   1231          		///STEP1:逻辑处理
   1232          		if((edit_attr.style & EDIT_READONLY)==0)
   1233          		{
   1234          			if(key==KEY_CLEAR)
   1235          			{
   1236          				if(pEdit->now[current_edit])
   1237          				{
   1238          					pEdit->now[current_edit]--;
   1239          					g_editValue[current_edit][pEdit->now[current_edit]] = 0x00;
   1240          				}
   1241          			}
   1242          			else if (KEY_ENTER == key || KEY_UP == key || KEY_DOWN == key)
   1243          			{
   1244          
   1245          			}
   1246          			else if (KEY_FUN4 == key)
   1247          			{
   1248          				pEdit->now[current_edit] = 0;
   1249          				memset((void*)g_editValue[current_edit],0,MAX_EDITNUM);
   1250          			}
   1251          			else
   1252          			{
   1253          				/// 允许输入
   1254          				if(pEdit->now[current_edit] < pEdit->input_max[current_edit])
   1255          					g_editValue[current_edit][pEdit->now[current_edit]++]	= key;
   1256          			}
   1257          		}
   1258          	}
   1259          	else if((edit_attr.style & 0x07) == EDIT_NUM)		/// 倒序排列 6.5.4.3.2.1.0
   1260          	{
   1261          		/// STEP1:逻辑处理
   1262          		if((edit_attr.style & EDIT_READONLY)==0)
   1263          		{
   1264          			if(key==KEY_CLEAR)
   1265          			{
   1266          				if(pEdit->now[current_edit])
   1267          				{
   1268          					pEdit->now[current_edit]--;
   1269          					g_editValue[current_edit][pEdit->now[current_edit]] = 0x00;
   1270          				}
   1271          			}
   1272          			else if (KEY_ENTER == key || KEY_UP == key || KEY_DOWN == key)
   1273          			{
   1274          
   1275          			}
   1276          			else if (KEY_FUN4 == key)
   1277          			{
   1278          				pEdit->now[current_edit] = 0;
   1279          				memset((void*)g_editValue[current_edit],0,MAX_EDITNUM);
   1280          			}
   1281          			else
   1282          			{
   1283          				//if (number_edit_patch)
   1284          				//{
   1285          				//	if(KEY_xing == key)
   1286          				//	{
   1287          				//		key = KEY_juhao;
   1288          				//	}
   1289          				//	if(pEdit->now[current_edit] < pEdit->max[current_edit])
   1290          				//		g_editValue[current_edit][pEdit->now[current_edit]++]	= key;
   1291          				//}
   1292          				//else
   1293          				{
   1294          					if ((KEY_xing != key) && (KEY_jing != key))
   1295          					{
   1296          						if ((KEY_NUM1 == key)&&(number_edit_patch))
   1297          						{
   1298          							if ((key == last_input_key)&&(input_update_flag < 3)&&(pEdit->now[current_edit]>1))
   1299          							{
   1300          								same_key_times++;
   1301          								if ((same_key_times%2) == 1)
   1302          								{
   1303          									if (pEdit->now[current_edit] > 1)
   1304          									{
   1305          										for(i = 0;i < pEdit->now[current_edit];i++)
   1306          										{
   1307          											if (g_editValue[current_edit][i] == KEY_juhao)
   1308          											{
   1309          												break;
   1310          											}
   1311          										}
   1312          									}
   1313          
   1314          									if (i == pEdit->now[current_edit])
   1315          									{
   1316          										g_editValue[current_edit][pEdit->now[current_edit]-1]	= KEY_juhao;
   1317          									}
   1318          									else
   1319          									{
   1320          										same_key_times = 0;
   1321          										if(pEdit->now[current_edit] < pEdit->input_max[current_edit])
   1322          											g_editValue[current_edit][pEdit->now[current_edit]++]	= key;
   1323          									}
   1324          								}
   1325          								else
   1326          								{
   1327          									g_editValue[current_edit][pEdit->now[current_edit]-1]	= KEY_NUM1;
   1328          								}
   1329          							}
   1330          							else
   1331          							{
   1332          								same_key_times = 0;
   1333          								if(pEdit->now[current_edit] < pEdit->input_max[current_edit])
   1334          									g_editValue[current_edit][pEdit->now[current_edit]++]	= key;
   1335          							}
   1336          						}
   1337          						else
   1338          						{
   1339                                      same_key_times = 0;
   1340          							if(pEdit->now[current_edit] < pEdit->input_max[current_edit])
   1341          								g_editValue[current_edit][pEdit->now[current_edit]++]	= key;
   1342          						}
   1343          						
   1344          					}
   1345          				}
   1346          				
   1347          			}
   1348          		}
   1349          	}
   1350          	else if((edit_attr.style & 0x07) == EDIT_MONEY)		// 倒序排列
   1351          	{
   1352          		// STEP1:逻辑处理
   1353          		if((edit_attr.style & EDIT_READONLY)==0)
   1354          		{
   1355          			if(key==KEY_CLEAR)			// $ 12345.67
   1356          			{
   1357          				if(pEdit->now[current_edit])
   1358          				{
   1359          					pEdit->now[current_edit]--;
   1360          					g_editValue[current_edit][pEdit->now[current_edit]] = 0x00;
   1361          				}
   1362          			}
   1363          			else if (KEY_ENTER == key || KEY_UP == key || KEY_DOWN == key)
   1364          			{
   1365          
   1366          			}
   1367          			else if (KEY_FUN4 == key)
   1368          			{
   1369          				pEdit->now[current_edit] = 0;
   1370          				memset((void*)g_editValue[current_edit],0,MAX_EDITNUM);
   1371          			}
   1372          			else
   1373          			{
   1374          				if((pEdit->now[current_edit] == 1) && (g_editValue[current_edit][0] == '0') && (key != KEY_xing))
   1375          				{
   1376          					// 如果编辑框的第一个是0，那么第二个输入的按键除了小数点之外，其余都需要取代第一个0
   1377          					g_editValue[current_edit][0] = *key2ascii(key);
   1378          				}
   1379          				else if (key == KEY_xing)
   1380          				{
   1381          					if (pEdit->now[current_edit] == 0)
   1382          					{
   1383          						g_editValue[current_edit][0] = *key2ascii(KEY_NUM0);
   1384          						g_editValue[current_edit][1] = *key2ascii(KEY_juhao);
   1385          						pEdit->now[current_edit] = 2;
   1386          					}
   1387          					else
   1388          					{
   1389          						for (i = 0;i < pEdit->now[current_edit];i++)
   1390          						{
   1391          							if (g_editValue[current_edit][i] == '.')
   1392          							{
   1393          								break;
   1394          							}
   1395          						}
   1396          
   1397          						if (i == pEdit->now[current_edit])
   1398          						{
   1399          							//表明前面没有输入了小数点，可以继续输入小数点了
   1400          							if(pEdit->now[current_edit] < pEdit->input_max[current_edit])			// 扣除一位小数点,能存9位数字
   1401          								g_editValue[current_edit][pEdit->now[current_edit]++] = *key2ascii(KEY_juhao);
   1402          						}
   1403          					}
   1404          				}
   1405          				else
   1406          				{
   1407          					if(pEdit->now[current_edit] < pEdit->input_max[current_edit])			// 扣除一位小数点,能存9位数字
   1408          						g_editValue[current_edit][pEdit->now[current_edit]++] = *key2ascii(key);
   1409          				}
   1410          			}
   1411          		}
   1412          	}
   1413          	else if ((edit_attr.style & 0x07) == EDIT_ALPHA)	//定义为ALPHA属性的编辑框，可以使用三种输入法输入
   1414          	{
   1415          		if((edit_attr.style & EDIT_READONLY)==0)
   1416          		{
   1417          			if(key==KEY_CLEAR)
   1418          			{
   1419          				if(pEdit->now[current_edit])
   1420          				{
   1421          					pEdit->now[current_edit]--;
   1422          					g_editValue[current_edit][pEdit->now[current_edit]] = 0x00;
   1423          				}
   1424          			}
   1425          			else if (KEY_ENTER == key || KEY_UP == key || KEY_DOWN == key)
   1426          			{
   1427          
   1428          			}
   1429          			else if (KEY_FUN4 == key)
   1430          			{
   1431          				pEdit->now[current_edit] = 0;
   1432          				memset((void*)g_editValue[current_edit],0,MAX_EDITNUM);
   1433          			}
   1434          			else
   1435          			{
   1436          				/// 允许输入
   1437          				if((pEdit->now[current_edit] < pEdit->input_max[current_edit]) || (1 == the_last_key))
   1438          				{
   1439          					if_update_cursor = edit_alpha_proc(key,input_method,key_code);
   1440          					if (0 == if_update_cursor)
   1441          					{
   1442          						pEdit->now[current_edit] --;
   1443          					}
   1444          					else 
   1445          					{
   1446          						if(1 == the_last_key)
   1447          						{
   1448          							the_last_key = 0;
   1449          							return;
   1450          						}
   1451          					}
   1452          					strcpy((char*)&g_editValue[current_edit][pEdit->now[current_edit]],(char const*)key_code);
   1453          					pEdit->now[current_edit] ++;
   1454          					if (pEdit->now[current_edit] == pEdit->input_max[current_edit])
   1455          					{
   1456          						//输到最后一位了
   1457          						the_last_key = 1;		//标记输入了最后一位，处于等待按同一个键切换的状态
   1458          					}
   1459          				}
   1460          			}
   1461          		}
   1462          	}
   1463          	//else if ((edit_attr.style & 0x07) == EDIT_CHINESE)		///定义为CHINESE属性的编辑框，可以使用四种输入法输入
   1464          	//{
   1465          	//	if((edit_attr.style & EDIT_READONLY)==0)
   1466          	//	{
   1467          	//		//if ((edit_state == EDIT_STATE_ZD_NAME_SELECT)||(edit_state == EDIT_STATE_ZD_VALUE_SELECT))
   1468          	//		if (edit_state == EDIT_STATE_ZD_VALUE_SELECT)
   1469          	//		{
   1470          	//			//进入字典输入功能的处理
   1471          	//			edit_ZD_proc(key,key_code);
   1472          	//			if (edit_state == EDIT_STATE_CODE_GOT)
   1473          	//			{
   1474          	//				if (pEdit->now[current_edit] + strlen((char const*)key_code) <= pEdit->input_max[current_edit])
   1475          	//				{
   1476          	//					strcpy((char*)&g_editValue[current_edit][pEdit->now[current_edit]],(char const*)key_code);
   1477          	//					pEdit->now[current_edit] += strlen((char const*)key_code);
   1478          	//				}
   1479           //                   input_method = PINYIN_INPUT;
   1480          	//			}
   1481          	//		}
   1482          	//		else
   1483          	//		{
   1484          	//			if ((EDIT_STATE_INIT_STATUS == edit_state || EDIT_STATE_CODE_GOT == edit_state)&&(KEY_CLEAR == key))
   1485          	//			{
   1486          	//				//在没有进入中文输入状态时按取消键，清除前面输入的键值
   1487          	//				if(pEdit->now[current_edit])
   1488          	//				{
   1489          	//					if (g_editValue[current_edit][pEdit->now[current_edit]-1] < 0x80)
   1490          	//					{
   1491          	//						//说明前面输入的是一个ASCII字符
   1492          	//						pEdit->now[current_edit]--;
   1493          	//					}
   1494          	//					else
   1495          	//					{
   1496          	//						//说明前面输入的是一个汉字，需要减去2个编码
   1497          	//						pEdit->now[current_edit] -= 2;
   1498          	//					}
   1499          	//					g_editValue[current_edit][pEdit->now[current_edit]] = 0x00;
   1500          	//				}
   1501          	//			}
   1502          	//			else if ((EDIT_STATE_INIT_STATUS == edit_state || EDIT_STATE_CODE_GOT == edit_state)&&(KEY_FUN4 == key))
   1503          	//			{
   1504          	//				//在没有进入中文输入状态时按F4键，清除前面所有输入的键值
   1505          	//				pEdit->now[current_edit] = 0;
   1506          	//				memset((void*)g_editValue[current_edit],0,MAX_EDITNUM);
   1507          	//			}
   1508          	//			else if ((EDIT_STATE_INIT_STATUS == edit_state)&&(KEY_ENTER == key || KEY_UP == key || KEY_DOWN == key))
   1509          	//			{
   1510          	//				//非中文输入法状态时，KEY_ENTER、KEY_UP、KEY_DOWN、KEY_ESC都是不产生任何作用的
   1511          	//				//什么都不做
   1512          	//			}
   1513          	//			else
   1514          	//			{
   1515          	//				if ((input_method == PINYIN_INPUT)&&((pEdit->now[current_edit]+1) == pEdit->input_max[current_edit]))
   1516          	//				{
   1517          	//					//最后只剩下一个字符的位置时，不能再输入中文了
   1518          	//				}
   1519          	//				else if((pEdit->now[current_edit] < pEdit->input_max[current_edit]) || (key == KEY_CLEAR) || (1 == the_last_key))
   1520          	//				{
   1521          	//					if_update_cursor = edit_chinese_proc(key,input_method,key_code);
   1522          	//					if ((edit_state == EDIT_STATE_CODE_GOT)&&(key != KEY_CLEAR))
   1523          	//					{
   1524          	//						//如果已经获取到键值的编码,直接将键值对应的可显示编码COPY到保存键值的缓冲区
   1525          	//						if (0 == if_update_cursor)
   1526          	//						{
   1527          	//							pEdit->now[current_edit] -= strlen((char const*)key_code);
   1528          	//						}
   1529          	//						else 
   1530          	//						{
   1531          	//							if(1 == the_last_key)
   1532          	//							{
   1533          	//								the_last_key = 0;
   1534          	//								return;
   1535          	//							}
   1536          	//						}
   1537          	//						strcpy((char*)&g_editValue[current_edit][pEdit->now[current_edit]],(char const*)key_code);
   1538          	//						pEdit->now[current_edit] += strlen((char const*)key_code);
   1539          
   1540          	//						if ((pEdit->now[current_edit] == pEdit->input_max[current_edit])&&(input_method != PINYIN_INPUT))
   1541          	//						{
   1542          	//							//输到最后一位了
   1543          	//							the_last_key = 1;		//标记输入了最后一位，处于等待按同一个键切换的状态
   1544          	//						}
   1545          	//					}
   1546          
   1547          	//					if (input_method != PINYIN_INPUT)
   1548          	//					{
   1549          	//						edit_state = EDIT_STATE_INIT_STATUS;
   1550          	//					}
   1551          	//				}
   1552          	//			}
   1553          	//		}
   1554          	//	}
   1555          	//}
   1556          
   1557          
   1558          	last_input_key = key;
   1559          
   1560          	if ((edit_state != EDIT_STATE_PY_SELECT)&&(edit_state != EDIT_STATE_HZ_SELECT)&&(edit_state != EDIT_STATE_ZD_NAME_SELECT)&&(edit_state != EDIT_STATE_ZD_VALUE_SELECT))
   1561          	{
   1562          		//处于这两个状态下，不需要刷新编辑框
   1563          		if (virtual_keypad_flag)
   1564          		{
   1565          			edit_refresh_ext(pEdit);
   1566          		}
   1567          		else
   1568          		{
   1569          			edit_refresh(pEdit,1,current_edit);
   1570          		}
   1571          	}
   1572          
   1573          }
   1574          
   1575          /**
   1576          * @brief 处理编辑框光标
   1577          */
   1578          static void edit_blink(TEdit *pEdit,unsigned char virtual_keypad_flag)
   1579          {
   1580          	TEditAttribute					edit_attr;			//当前编辑框的属性
   1581          	unsigned char					current_edit;
   1582          	unsigned char cur_pos;
   1583          	unsigned short					i,x,y;
   1584          	//unsigned short		patch = 0;
   1585          	unsigned char		offset;
   1586          
   1587          	current_edit = pEdit->current_edit;
   1588          
   1589          	if (pEdit->now[current_edit] < pEdit->display_max[current_edit])
   1590          	{
   1591          		cur_pos = pEdit->now[current_edit];
   1592          	}
   1593          	else
   1594          	{
   1595          		cur_pos = pEdit->display_max[current_edit];	
   1596          		offset = pEdit->now[current_edit] - pEdit->display_max[current_edit];
   1597          
   1598          		for (i=0;i<offset;i++)
   1599          		{
   1600          			if (g_editValue[current_edit][i] > 0x80)
   1601          			{
   1602          				i++;
   1603          			}
   1604          		}
   1605          
   1606          		if (i>offset)
   1607          		{
   1608          			cur_pos--;
   1609          		}
   1610          	}
   1611          	
   1612          	
   1613          	edit_get_attribute(pEdit,&edit_attr);		//获取当前编辑框的相关属性
   1614          	//if ((edit_attr.style & 0x80) == EDIT_MUL_LINE)
   1615          	//{
   1616          	//	patch = edit_display_x_patch;
   1617          	//}
   1618          	if (virtual_keypad_flag)
   1619          	{
   1620          		edit_attr.x = 0;
   1621          		edit_attr.y = 0;
   1622          	}
   1623          	x = edit_attr.x + cur_pos*gFontSize/2 + pEdit->display_patch[current_edit];
   1624          	y = edit_attr.y;
   1625          
   1626          
   1627          	if (edit_attr.y + 13 *((pEdit->display_max[current_edit]-1)/20) > GUI_HEIGHT - SHOTCUT_HEIGNT - 12)
   1628          	{
   1629          		//编辑框的纵坐标大于显示区域
   1630          		y = ICON_HEIGHT + 18 + edit_attr.y - (GUI_HEIGHT - SHOTCUT_HEIGNT );
   1631          	}
   1632          
   1633          	while(x >= GUI_WIDTH)
   1634          	{
   1635          		x -= GUI_WIDTH;
   1636          		y += 13;
   1637          	}
   1638          
   1639          	if(((edit_attr.style & 0x10) != EDIT_NO_BLINK)&&(edit_state == EDIT_STATE_CODE_GOT || edit_state == EDIT_STATE_INIT_STATUS))
   1640          	{
   1641          		//需要闪烁光标的编辑框
   1642          		if(pEdit->blink)
   1643          		{
   1644          			// 清光标
   1645          			pEdit->blink		= 0;
   1646          			//gui_FillRect(x,y,pEdit->view[current_edit].font_size/6,pEdit->view[current_edit].font_size-2,BG_COLOR);
   1647          			gui_LineV(x,y+1,11,BG_COLOR);
   1648          		}
   1649          		else
   1650          		{
   1651          			// 画光标
   1652          			pEdit->blink		= 1;
   1653          			//gui_FillRect(x,y,pEdit->view[current_edit].font_size/6,pEdit->view[current_edit].font_size-2,TXT_COLOR);
   1654          			gui_LineV(x,y+1,11,TXT_COLOR);
   1655          		}
   1656          	}
   1657          	
   1658          }
   1659          
   1660          
   1661          /**
   1662          * @brief 是否包含处于激活状态的编辑框
   1663          * @return 0:不包含   1:包含
   1664          */
   1665          static int edit_is_active(TEdit *pEdit)
   1666          {
   1667          	unsigned char	i;
   1668          	for (i = 0; i < MAX_EDIT;i++)
   1669          	{
   1670          		if (pEdit->active[i] != 0)
   1671          		{
   1672          			return 1;
   1673          		}
   1674          	}
   1675          
   1676          	return 0;
   1677          }
   1678          
   1679          /**
   1680          * @brief 使能某一个编辑框
   1681          */
   1682          void edit_enable(TEdit *pEdit,int index)
   1683          {
   1684          	if (index > 7)
   1685          	{
   1686          		return;
   1687          	}
   1688          
   1689          	pEdit->active[index] = 1;
   1690          }
   1691          
   1692          /**
   1693          * @brief 使某一个编辑框失效
   1694          */
   1695          void edit_disable(TEdit *pEdit,int index)
   1696          {
   1697          	if (index > 7)
   1698          	{
   1699          		return;
   1700          	}
   1701          
   1702          	pEdit->active[index] = 0;
   1703          }
   1704          
   1705          /**
   1706          * @brief 输入法的切换
   1707          */
   1708          static void input_method_switch(TEdit *pEdit)
   1709          {
   1710          	TEditAttribute					edit_attr;			//当前编辑框的属性
   1711          
   1712          	edit_get_attribute(pEdit,&edit_attr);		//获取当前编辑框的相关属性
   1713          	
   1714          	input_method++;
   1715          
   1716          	if ((edit_attr.style & 0x07) == EDIT_ALPHA)
   1717          	{
   1718          		if (input_method > _123_INPUT)
   1719          		{
   1720          			input_method = ABC_INPUT;
   1721          		}
   1722          	}
   1723          	else if ((edit_attr.style & 0x07) == EDIT_CHINESE)
   1724          	{
   1725          		if (input_method > _123_INPUT)
   1726          		{
   1727          			if (LANG_ENGLISH == g_language)
   1728          			{
   1729          				input_method = ABC_INPUT;
   1730          			}
   1731          			else
   1732          			{
   1733          				input_method = PINYIN_INPUT;
   1734          			}
   1735          		}
   1736          	}
   1737          	else
   1738          	{
   1739          		//其余属性的编辑框，输入法不允许切换
   1740          		input_method--;
   1741          	}
   1742          
   1743          	input_update_flag = 3;
   1744          	return;
   1745          }
   1746          
   1747          /**
   1748          * @brief 光标在编辑框之间的切换
   1749          */
   1750          void edit_switch(TEdit *pEdit,unsigned char key)
   1751          {
   1752          	unsigned char					i;
   1753          	unsigned char					current_edit;
   1754          	TEditAttribute					edit_attr;			//当前编辑框的属性
   1755          	unsigned char cur_pos,offset;
   1756          
   1757          	current_edit = pEdit->current_edit;
   1758          	if (pEdit->now[current_edit] < pEdit->display_max[current_edit])
   1759          	{
   1760          		cur_pos = pEdit->now[current_edit];
   1761          	}
   1762          	else
   1763          	{
   1764          		cur_pos = pEdit->display_max[current_edit];	
   1765          		offset = pEdit->now[current_edit] - pEdit->display_max[current_edit];
   1766          
   1767          		for (i=0;i<offset;i++)
   1768          		{
   1769          			if (g_editValue[current_edit][i] > 0x80)
   1770          			{
   1771          				i++;
   1772          			}
   1773          		}
   1774          
   1775          
   1776          		if (i>offset)
   1777          		{
   1778          			cur_pos--;
   1779          		}
   1780          	}
   1781          
   1782          	//需要先清除原来的光标
   1783          	edit_get_attribute(pEdit,&edit_attr);		//获取当前编辑框的相关属性
   1784          
   1785          	if((edit_attr.style & 0x07) == EDIT_MONEY)
   1786          	{
   1787          		cur_pos = pEdit->display_max[current_edit]-1;
   1788          	}
   1789          
   1790          	if((edit_attr.style & 0x10) != EDIT_NO_BLINK)
   1791          	{
   1792          		// 清光标
   1793          		//gui_LineH(edit_attr.x + cur_pos*gFontSize/2, edit_attr.y+gFontSize-3 , gFontSize/2, BG_COLOR);
   1794          		//gui_LineH(edit_attr.x + cur_pos*gFontSize/2, edit_attr.y+gFontSize-2 , gFontSize/2, BG_COLOR);
   1795          		//gui_FillRect(edit_attr.x + cur_pos*gFontSize/2,edit_attr.y,gFontSize/6,gFontSize-2,BG_COLOR);
   1796          		//gui_ClearLineV(edit_attr.x+cur_pos*8,edit_attr.y+1,11,TXT_COLOR);
   1797          		if (edit_attr.y + 13 * ((pEdit->display_max[current_edit] - 1)/20) > GUI_HEIGHT - SHOTCUT_HEIGNT - 12)
   1798          		{
   1799          			//编辑框的纵坐标大于显示区域
   1800          			edit_attr.y = ICON_HEIGHT + 18 + edit_attr.y - (GUI_HEIGHT - SHOTCUT_HEIGNT );
   1801          		}
   1802                            
   1803                   gui_LineV(edit_attr.x+cur_pos*gFontSize/2+pEdit->display_patch[current_edit],edit_attr.y+1,11,BG_COLOR);
   1804          	}
   1805          
   1806          
   1807          	if (KEY_UP == key)
   1808          	{
   1809          		//上翻键
   1810          		for(i = 0;i<all_edit;i++)
   1811          		{
   1812          			if (current_edit == 0)
   1813          			{
   1814          				current_edit = all_edit - 1; 
   1815          			}
   1816          			else
   1817          			{
   1818          				current_edit--;
   1819          			}
   1820          
   1821          			if (pEdit->active[current_edit] != 1)
   1822          			{
   1823          				if (current_edit == 0)
   1824          				{
   1825          					current_edit = all_edit - 1; 
   1826          				}
   1827          				else
   1828          				{
   1829          					current_edit--;
   1830          				}
   1831          
   1832          				if (pEdit->active[current_edit] == 1)
   1833          				{
   1834          					break;
   1835          				}
   1836          			}
   1837          			else
   1838          			{
   1839          				break;
   1840          			}
   1841          		}
   1842          	}
   1843          
   1844          	if (KEY_DOWN == key)
   1845          	{
   1846          		//下翻键
   1847          		for(i = 0;i<all_edit;i++)
   1848          		{
   1849          			if (current_edit == all_edit - 1)
   1850          			{
   1851          				current_edit = 0; 
   1852          			}
   1853          			else
   1854          			{
   1855          				current_edit++;
   1856          			}
   1857          
   1858          			if (pEdit->active[current_edit] != 1)
   1859          			{
   1860          				if (current_edit == all_edit - 1)
   1861          				{
   1862          					current_edit = 0; 
   1863          				}
   1864          				else
   1865          				{
   1866          					current_edit++;
   1867          				}
   1868          
   1869          				if (pEdit->active[current_edit] == 1)
   1870          				{
   1871          					break;
   1872          				}
   1873          			}
   1874          			else
   1875          			{
   1876          				break;
   1877          			}
   1878          		}
   1879          	}
   1880          	pEdit->current_edit = current_edit;
   1881          	pEdit->blink = 0;		//立即绘制新编辑框的光标
   1882          	last_input_key = 0;		//最近输入的按键清0
   1883          	return;
   1884          }
   1885          
   1886          /**
   1887          * @brief 光标直接跳转到指定的编辑框
   1888          */
   1889          void edit_switch_ext(TEdit *pEdit,unsigned char edit_index)
   1890          {
   1891          	unsigned char					i;
   1892          	unsigned char					current_edit;
   1893          	TEditAttribute					edit_attr;			//当前编辑框的属性
   1894          	unsigned char cur_pos,offset;
   1895          
   1896          	current_edit = pEdit->current_edit;
   1897          
   1898          	if (pEdit->now[current_edit] < pEdit->display_max[current_edit])
   1899          	{
   1900          		cur_pos = pEdit->now[current_edit];
   1901          	}
   1902          	else
   1903          	{
   1904          		cur_pos = pEdit->display_max[current_edit];	
   1905          		offset = pEdit->now[current_edit] - pEdit->display_max[current_edit];
   1906          		for (i=0;i<offset;i++)
   1907          		{
   1908          			for (i=0;i<offset;i++)
   1909          			{
   1910          				if (g_editValue[current_edit][i] > 0x80)
   1911          				{
   1912          					i++;
   1913          				}
   1914          			}
   1915          
   1916          			if(i>offset)
   1917          			{
   1918          				offset++;
   1919          			}
   1920          		}
   1921          
   1922          		if (i>offset)
   1923          		{
   1924          			cur_pos--;
   1925          		}
   1926          	}
   1927          	
   1928          	//需要先清除原来的光标
   1929          	edit_get_attribute(pEdit,&edit_attr);		//获取当前编辑框的相关属性
   1930          
   1931          	if((edit_attr.style & 0x07) == EDIT_MONEY)
   1932          	{
   1933          		cur_pos = pEdit->display_max[current_edit]-1;
   1934          	}
   1935          
   1936          	if((edit_attr.style & 0x10) != EDIT_NO_BLINK)
   1937          	{
   1938          		// 清光标
   1939          		//gui_LineH(edit_attr.x + cur_pos*gFontSize/2, edit_attr.y+gFontSize-3 , gFontSize/2, BG_COLOR);
   1940          		//gui_LineH(edit_attr.x + cur_pos*gFontSize/2, edit_attr.y+gFontSize-2 , gFontSize/2, BG_COLOR);
   1941          		//gui_FillRect(edit_attr.x + cur_pos*gFontSize/2,edit_attr.y,gFontSize/6,gFontSize-2,BG_COLOR);
   1942          		gui_LineV(edit_attr.x+cur_pos*gFontSize/2,edit_attr.y+1,11,BG_COLOR);
   1943          	}
   1944          
   1945          	pEdit->current_edit = edit_index;
   1946          	pEdit->blink = 0;		//立即绘制新编辑框的光标
   1947          	last_input_key = 0;		//最近输入的按键清0
   1948          	return;
   1949          }
   1950          /**
   1951          * @brief edit设置显示的字符,将pValue设置到g_editValue中
   1952          */
   1953          void edit_setvalue(TEdit *pEdit, unsigned char *pValue,unsigned char edit_index)
   1954          {
   1955          	int						i;
   1956          	if (edit_index > (MAX_EDITNUM - 1))
   1957          	{
   1958          		return;
   1959          	}
   1960          	pEdit->now[edit_index] = 0;
   1961          	memset(g_editValue[edit_index],0,MAX_EDITNUM);
   1962          
   1963          	for(i=0; i<pEdit->input_max[edit_index] && pValue[i]!=0x00; i++)
   1964          	{
   1965          		g_editValue[edit_index][i]		= pValue[i];
   1966          		pEdit->now[edit_index]++;
   1967          	}
   1968          	g_editValue[edit_index][i]			= 0x00;
   1969          }
   1970          
   1971          /**
   1972          * @brief 将edit中的值转成整型
   1973          * @note 注意edit中的值，是键值而不是ascii
   1974          */
   1975          int edit_atoi(unsigned char *pValue)
   1976          {
   1977          	int						i;
   1978          	int						value = 0;
   1979          
   1980          	for(i=0; ;i++)
   1981          	{
   1982          		if( *pValue == 0x00 )
   1983          			return value;
   1984          		value				*= 10;
   1985          		value				+= *(key2ascii(*pValue)) - '0';
   1986          		pValue ++;
   1987          	}
   1988          	//return value;
   1989          }
   1990          
   1991          
   1992          /**
   1993          * @brief 将edit中的值转成放大100倍之后的整数，为了支持小数点后2位
   1994          * @note 注意edit中的值，是键值而不是ascii
   1995          */
   1996          int edit_atoi_100X(unsigned char *pValue)
   1997          {
   1998          	int						i;
   1999          	int						value = 0;
   2000          	unsigned char			dot_pos = 0;
   2001          
   2002          	for(i=0; ;i++)
   2003          	{
   2004          		if ((i == dot_pos + 3)&&(dot_pos != 0))
   2005          		{
   2006          			return value;
   2007          		}
   2008          		if( *pValue == 0x00 )
   2009          		{
   2010          			if ((i == dot_pos + 2)&&(dot_pos != 0))
   2011          			{	
   2012          				return value*10;
   2013          			}
   2014          			return value*100;
   2015          		}
   2016          
   2017          		if (*pValue == KEY_juhao)
   2018          		{
   2019          			dot_pos = i;
   2020          			pValue++;
   2021          			continue;
   2022          		}
   2023          
   2024          		value				*= 10;
   2025          		value				+= *(key2ascii(*pValue)) - '0';
   2026          		pValue ++;
   2027          	}
   2028          	//return value;
   2029          }
   2030          
   2031          /**
   2032          * @brief 将edit中的值转成浮点数
   2033          * @note 注意edit中的值，是键值而不是ascii
   2034          */
   2035          float edit_atof(unsigned char *pValue)
   2036          {
   2037          #if 0
   2038          	int						i;
   2039          	float					value = 0;
   2040          	float					q;
   2041          	unsigned char			got_dot_flag = 0;
   2042          
   2043          	//input_valid_num = 4;		//默认保留小数点后4位
   2044          	for(i=0; ;i++)
   2045          	{
   2046          		if( *pValue == 0x00 )
   2047          		{
   2048          			return value;
   2049          		}
   2050          		if (*pValue != KEY_juhao)
   2051          		{
   2052          			if (got_dot_flag == 0)
   2053          			{
   2054          				value				*= 10;
   2055          				value				+= *(key2ascii(*pValue)) - '0';
   2056          			}
   2057          			else
   2058          			{
   2059          				value += (*(key2ascii(*pValue)) - '0')*q;
   2060          				q *= 0.1;
   2061          			}
   2062          			
   2063          		}
   2064          		else
   2065          		{
   2066          			got_dot_flag = 1;
   2067          			q = 0.1;
   2068          		}
   2069          		pValue ++;
   2070          	}
   2071          #endif
   2072          	
   2073          	int						i;
   2074          	int						zs = 0;
   2075          	int						xs = 0;
   2076          	float					value = 0;
   2077          	unsigned char			xs_len = 0;
   2078          	unsigned char			got_dot_flag = 0;
   2079          
   2080          
   2081          	for(i=0; ;i++)
   2082          	{
   2083          		if( *pValue == 0x00 )
   2084          		{
   2085          			while (xs_len)
   2086          			{
   2087          				value += (float)(xs%10)/exp10(xs_len);
   2088          				xs /= 10;
   2089          				xs_len--; 
   2090          			}
   2091          			
   2092          			return (value+zs);
   2093          		}
   2094          
   2095          		if (*pValue != KEY_juhao)
   2096          		{
   2097          			if (got_dot_flag)
   2098          			{
   2099          				xs *= 10;
   2100          				xs += *(key2ascii(*pValue)) - '0';
   2101          				xs_len++;
   2102          			}
   2103          			else
   2104          			{
   2105          				zs *= 10;
   2106          				zs += *(key2ascii(*pValue)) - '0';
   2107          			}
   2108          		}
   2109          		else
   2110          		{
   2111          			got_dot_flag = 1;
   2112          		}
   2113          		pValue ++;
   2114          	}
   2115          }
   2116          
   2117          /**
   2118          * @brief 将整型转成键值，放到编辑框里
   2119          */
   2120          unsigned char edit_itoa(unsigned int value, unsigned char *pValue)
   2121          {
   2122          	unsigned char						i,j;
   2123          	unsigned char						tmp[10];
   2124          
   2125          	if( 0 == value)
   2126          	{
   2127          		pValue[0] = i2key(0);
   2128          		pValue[1] = 0;
   2129          		return 1;
   2130          	}
   2131          	else
   2132          	{
   2133          		for(i=0; value;i++)
   2134          		{
   2135          			tmp[i]			= i2key( value % 10);
   2136          			value				/= 10;
   2137          		}
   2138          
   2139          		for (j = 0;j < i;j++)
   2140          		{
   2141          			pValue[j] = tmp[i-1-j];
   2142          		}
   2143          
   2144          		pValue[j] = 0;
   2145          	}
   2146          
   2147          	return i;
   2148          }
   2149          
   2150          /**
   2151          * @brief 将被放大100倍的整型转成键值，放到编辑框里
   2152          */
   2153          unsigned char edit_itoa_100X(unsigned int value, unsigned char *pValue)
   2154          {
   2155          	unsigned char						i,j;
   2156          	unsigned char						tmp[10],buf[10];
   2157          
   2158          	if( 0 == value)
   2159          	{
   2160          		pValue[0] = i2key(0);
   2161          		pValue[1] = 0;
   2162          		return 1;
   2163          	}
   2164          	else
   2165          	{
   2166          		if (value%100)
   2167          		{
   2168          			for(i=0; value;i++)
   2169          			{
   2170          				tmp[i]			= i2key( value % 10);
   2171          				value				/= 10;
   2172          			}
   2173          
   2174          			if (i == 1)
   2175          			{
   2176          				tmp[i++] = KEY_NUM0;
   2177          				tmp[i++] = KEY_juhao;
   2178          				tmp[i++] = KEY_NUM0;
   2179          			}
   2180          			else if (i == 2)
   2181          			{
   2182          				tmp[i++] = KEY_juhao;
   2183          				tmp[i++] = KEY_NUM0;
   2184          			}
   2185          			else
   2186          			{
   2187          				memcpy(buf,tmp+2,8);
   2188          				tmp[2] = KEY_juhao;
   2189          				memcpy(tmp+3,buf,7);
   2190          
   2191          				i += 1;
   2192          			}
   2193          		}
   2194          		else
   2195          		{
   2196          			value /=100;
   2197          			for(i=0; value;i++)
   2198          			{
   2199          				tmp[i]			= i2key( value % 10);
   2200          				value				/= 10;
   2201          			}
   2202          		}
   2203          
   2204          		for (j = 0;j < i;j++)
   2205          		{
   2206          			pValue[j] = tmp[i-1-j];
   2207          		}
   2208          
   2209          		pValue[j] = 0;
   2210          	}
   2211          
   2212          	return i;
   2213          }
   2214          
   2215          /**
   2216          * @brief 将浮点数转成键值，放到编辑框里
   2217          */
   2218          //unsigned char edit_ftoa(float value, unsigned char *pValue)
   2219          //{
   2220          //
   2221          //}
   2222          /**
   2223          * @brief 将字符串，转为edit中的值（键值）
   2224          */
   2225          void edit_stoe(unsigned char *indata, unsigned int inlen,unsigned char *outdata)
   2226          {
   2227          	unsigned int						i;
   2228          	unsigned int						j;
   2229          
   2230          	for(i=0; i<inlen; i++)
   2231          	{
   2232          		j = 0;
   2233          		while (keyValue_Ascii_Tbl[j].asciivalue != 0) 
   2234          		{
   2235          			if (indata[i] == *(keyValue_Ascii_Tbl[j].asciivalue)) 
   2236          			{
   2237          				outdata[i] = keyValue_Ascii_Tbl[j].keyvalue;
   2238          				break;
   2239          			}
   2240          			j++;
   2241          		}
   2242          	}
   2243          	outdata[inlen]			= 0;
   2244          
   2245          }
   2246          
   2247          /**
   2248          * @brief 将edit中的转为字符串
   2249          */
   2250          void edit_etos(unsigned char *indata, unsigned char *outdata, int len)
   2251          {
   2252          	//	unsigned char			c;
   2253          	int						i;
   2254          
   2255          	for(i=0; i<len; i++)
   2256          	{       
   2257          		outdata[i] = *(key2ascii(indata[i]));
   2258          	}
   2259          	outdata[len] = 0x00;		// 结束符
   2260          }
   2261          
   2262          /**
   2263          * @brief 从edit中取得现有值
   2264          */
   2265          void edit_getvalue(TEdit *pEdit, unsigned char *pValue)
   2266          {
   2267          	int						i;
   2268          
   2269          	for(i=0; i<pEdit->now[pEdit->current_edit]; i++)
   2270          	{
   2271          		pValue[i]			= g_editValue[pEdit->current_edit][i];
   2272          	}
   2273          	pValue[i]				= 0x00;
   2274          }
   2275          /**
   2276          ***************************************************************************
   2277          *@brief	获取当前语言的内容字符串,unicode编码
   2278          *@param[in] 
   2279          *@return 
   2280          *@warning
   2281          *@see	
   2282          *@note 
   2283          ***************************************************************************
   2284          */
   2285          static unsigned char **get_content(void)
   2286          {
   2287          	TDialogRes						* res;
   2288          	res								= g_dlg.pRes;
   2289          
   2290          	if(g_language == 0)
   2291          		return res->pContent_en;
   2292          	else if(g_language == 1)
   2293          		return res->pContent_scn;
   2294          	else
   2295          		return res->pContent_tcn;
   2296          }
   2297          /**
   2298          * @brief 更新显示时间,每隔一秒由中断调用
   2299          * @param[in] xpos
   2300          * @param[in] ypos
   2301          * @note 时间的显示颜色反显了，所以显示时间的位置必须以深色为背景的区域
   2302          * @return none
   2303          */
   2304          void dlg_updatetime(unsigned short xpos,unsigned short ypos)
   2305          {
   2306          	unsigned char		str[6];
   2307          	GetDateTime();
   2308          	sprintf((char*)str,"%02d:%02d",currentDateTime.hour,currentDateTime.min);
   2309          	if (need_refresh_signal)
   2310          	{
   2311          		gui_TextOut_ext(CENTER_ALIGN, ypos,str,0,1);
   2312          	}
   2313          	else
   2314          	{
   2315          		gui_TextOut(xpos, ypos,str,0,1);
   2316          	}
   2317          }
   2318          /**
   2319          * @brief 注册进度条
   2320          * @param[in] unsigned char style	进度条的类型
   2321          * @param[in] unsigned short x		进度条的坐标x
   2322          * @param[in] unsigned short y		进度条的坐标y
   2323          * @param[in] unsigned short max		进度条的最大值
   2324          */
   2325          void process_bar_regist(unsigned char style,unsigned short x,unsigned short y,unsigned short max)
   2326          {
   2327          #if 0
   2328          	process_bar.style = style;
   2329          	process_bar.pos_x = x;
   2330          	process_bar.pos_y = y;
   2331          	process_bar.max_value = max;
   2332          	process_bar.current_value = 0;
   2333          	process_bar.active = 1;
   2334          #endif
   2335          }
   2336          
   2337          /**
   2338          * @brief 注销进度条
   2339          */
   2340          void process_bar_cancle(void)
   2341          {
   2342          	//process_bar.active = 0;
   2343          }
   2344          
   2345          /**
   2346          * @brief 更新进度条
   2347          */
   2348          void process_bar_update(void)
   2349          {
   2350          #if 0
   2351          	int i;
   2352          
   2353          	if (process_bar.current_value < 0xFFFF)
   2354          	{
   2355          		process_bar.current_value ++;
   2356          	}
   2357          	else
   2358          	{
   2359          		process_bar.current_value =  0;
   2360          	}
   2361          	
   2362          	if (process_bar.style == PROCESS_BAR_STYLE_1)
   2363          	{
   2364          		//形态1的进度条,同最大值无关
   2365          		//for (i = 0;i < 4;i++)
   2366          		//{
   2367          		//	gui_DrawRect(process_bar.pos_x+i*12,process_bar.pos_y,4,8,TXT_COLOR);
   2368          		//}
   2369          
   2370          		i = process_bar.current_value%5;
   2371          		if (i == 0)
   2372          		{
   2373          			gui_FillRect(process_bar.pos_x,process_bar.pos_y,4*10,4,BG_COLOR);
   2374          		}
   2375          		else
   2376          		{
   2377          			gui_FillRect(process_bar.pos_x+(i-1)*8,process_bar.pos_y,4,4,TXT_COLOR);
   2378          		}
   2379          	}
   2380          	else if (process_bar.style == PROCESS_BAR_STYLE_2)
   2381          	{
   2382          		//@todo...
   2383          	}
   2384          #endif 
   2385          }
   2386          
   2387          /**
   2388          * @brief 更新图标,GPRS信号强度，电池电量，充电提示，通信状态
   2389          * @param[in] int mode 0:不需要取实际的网络信号强度    1:需要取实际的网络信号强度
   2390          * @return 0:不需要重新绘制原界面  1:低电事件    2:重新绘制原界面
   2391          * @note 因为在显示开机画面时如果也需要取实际的网络信号强度的话，可能因为GPRS模块的响应比较慢，导致开机显示主界面时
   2392          *		 会有一个明显的停顿感
   2393          */
   2394          int dlg_update_icon(int mode,unsigned char refresh_flag)
   2395          {
   2396          	int	powerlevel;
   2397          	int csq;
   2398          	int i,needpoweroff = 0;
   2399          	unsigned char * key;
   2400          	unsigned int	lowpower_cnt = 0;
   2401          
   2402          	//if (need_refresh_signal)
   2403          	//{
   2404          	//	
   2405          	//}
   2406          	if (g_param.transfer_mode == TRANSFER_MODE_BLUETOOTH)
   2407          	{
   2408          
   2409          		gui_PictureOut(24,0,PIC_BLUETOOTH,refresh_flag);
   2410          
   2411          		if (YFBT07_Connect_state())
   2412          		{	
   2413          			//连接状态
   2414          			bluetooth_match_cmd_cnt = 0;
   2415          			gui_PictureOut(0,0,PIC_ANT5,refresh_flag);
   2416          		}
   2417          		else
   2418          		{
   2419          			gui_PictureOut(0,0,PIC_ANT1,refresh_flag);
   2420          			//如果是处于未连接状态，那么就间隔2分钟发送一次匹配命令
   2421          			if (bluetooth_module_state == 0)
   2422          			{
   2423          				bluetooth_state_cnt = 0;
   2424          				if (bluetooth_match_cmd_cnt == 60)
   2425          				{
   2426          					bluetooth_match_cmd_cnt = 0;
   2427          					YFBT07_Enter_Match_Mode();
   2428          				}
   2429          				if (bluetooth_match_cmd_cnt%8 == 0)
   2430          				{
   2431          					YFBT07_SendKey("\x0d",1);
   2432          				}
   2433          				bluetooth_match_cmd_cnt ++;
   2434          			}
   2435          			else
   2436          			{
   2437          				if(bluetooth_state_cnt == 20)
   2438          				{
   2439          					bluetooth_state_cnt = 0;
   2440          					bluetooth_module_state = YFBT07_check();
   2441          				}
   2442          				bluetooth_state_cnt++;
   2443          			}
   2444          		}
   2445          	}
   2446          	else if (g_param.transfer_mode == TRANSFER_MODE_KEYBOARD)
   2447          	{
   2448          		if (bDeviceState == CONFIGURED)
   2449          		{
   2450          			gui_PictureOut(0,0,PIC_KEYPAD_C,refresh_flag);
   2451          		}
   2452          		else
   2453          		{
   2454          			gui_PictureOut(0,0,PIC_KEYPAD_D,refresh_flag);
   2455          		}
   2456          	}
   2457          	else if (g_param.transfer_mode == TRANSFER_MODE_VIRTUAL_COMM)
   2458          	{
   2459          		if (bDeviceState == CONFIGURED)
   2460          		{
   2461          			gui_PictureOut(0,0,PIC_COMM_C,refresh_flag);
   2462          		}
   2463          		else
   2464          		{
   2465          			gui_PictureOut(0,0,PIC_COMM_D,refresh_flag);
   2466          		}
   2467          	}
   2468          	else if (g_param.transfer_mode == TRANSFER_MODE_U_DISK)
   2469          	{
   2470          		gui_PictureOut(0,0,PIC_UDISK,refresh_flag);
   2471          	}
   2472          
   2473          
   2474          	// 显示电池电量
   2475          	if (USBLink_Insert_Detect())
   2476          	{		
   2477          		//没有插入外接USB电源
   2478          		powerlevel					= GetPowerVoltageClass();
   2479          		if (powerlevel == (last_power_level+1))
   2480          		{
   2481          			powerlevel = last_power_level;
   2482          		}
   2483          		last_power_level = powerlevel;
   2484          		//powerlevel = 4;
   2485          		if (powerlevel >= 1)
   2486          		{
   2487          			lowpower_detect_cnt = 0;
   2488          			lowpower_cnt = 0;
   2489          			lowpower_flag = 0;
   2490          		}
   2491          		switch(powerlevel)
   2492          		{
   2493          		case 4:	gui_PictureOut(GUI_WIDTH-24,0, PIC_BAT0,refresh_flag);	break;
   2494          		case 3: gui_PictureOut(GUI_WIDTH-24,0, PIC_BAT1,refresh_flag);	break;
   2495          		case 2: gui_PictureOut(GUI_WIDTH-24,0, PIC_BAT2,refresh_flag);	break;
   2496          		case 1: gui_PictureOut(GUI_WIDTH-24,0, PIC_BAT3,refresh_flag);	break;
   2497          		default:	//电池电量低
   2498          			gui_PictureOut(GUI_WIDTH-24,0, PIC_BAT4,refresh_flag);
   2499          			lowpower_detect_cnt++;
   2500          		}
   2501          
   2502          		if ((lowpower_detect_cnt > 3)&&(lowpower_detect_cnt<8))
   2503          		{	
   2504          			//gui_PictureOut(GUI_WIDTH-24,0, PIC_BAT4);
   2505          			//Beep(BEEP_DELAY*2);
   2506          			//gui_FillRect(0, ICON_HEIGHT+1, GUI_WIDTH, USERZONE_HEIGHT, BG_COLOR);
   2507          			//gui_TextOut(16, 60,"系统电量不足...",0);
   2508          			//gui_TextOut(18, 72,"请保存当前数据!",0);
   2509          			//OSTimeDlyHMSM(0,0,1,0);
   2510          			lowpower_flag ++;
   2511          			return 1;
   2512          		}
   2513          
   2514          		if (lowpower_detect_cnt >= 8)
   2515          		{
   2516          			OSSchedLock();		//不要再进行任务调度了
   2517          			while (USBLink_Insert_Detect())
   2518          			{
   2519          				lowpower_cnt++;
   2520          				gui_PictureOut(GUI_WIDTH-24,0, PIC_BAT4,refresh_flag);
   2521          				Beep(BEEP_DELAY*2);
   2522          				for (i = 0;i < 1000000;i++);		//延时一小段时间
   2523          				gui_FillRect(0, ICON_HEIGHT+1, GUI_WIDTH, USERZONE_HEIGHT, BG_COLOR,refresh_flag);
   2524          				gui_TextOut_ext(CENTER_ALIGN, 26,"系统电量不足...",0,refresh_flag);
   2525          				//@English
   2526          				gui_TextOut_ext(CENTER_ALIGN, 39,"请插入外部电源!",0,refresh_flag);
   2527          				//@English
   2528          				key = keypad_getkey();
   2529          				if ((*key) == KEY_POWER) 
   2530          				{
   2531          					needpoweroff++;	
   2532          				}
   2533          				else
   2534          				{
   2535          					needpoweroff = 0;
   2536          				}
   2537          
   2538          				if (needpoweroff > 3) 
   2539          				{
   2540          					Lcd_Clear(BG_COLOR);
   2541          					gui_TextOut_ext(CENTER_ALIGN, 26, "POWER OFF",0,refresh_flag);                         
   2542          					while(*(keypad_getkey()) == KEY_POWER)
   2543          					{
   2544          						;
   2545          					}
   2546          					//释放POWER键之后，先清屏再关机
   2547          					Lcd_Clear(BG_COLOR);
   2548          					PowerOff();      ///关机
   2549          				}
   2550          
   2551          				if (lowpower_cnt > 100)
   2552          				{
   2553          					//如果连续低电报警100次，还没有插入外接电源或者关机，那么就强制关机。
   2554          					Lcd_Clear(BG_COLOR);
   2555          					PowerOff();      ///关机
   2556          				}
   2557          			}
   2558          			gui_PictureOut(GUI_WIDTH-24,0, PIC_BAT_SHAN,refresh_flag);	//显示充电图标
   2559          			OSSchedUnlock();		//任务调度解锁
   2560          			return 2;
   2561          
   2562          
   2563          		}
   2564          	}
   2565          	else
   2566          	{
   2567          		lowpower_flag = 0;
   2568          		//插入了USB外接电源
   2569          		if (ChargeState_Detect())		//充电完成
   2570          		{
   2571                                  charge_state_cnt = 0;
   2572          			gui_PictureOut(GUI_WIDTH-24,0, PIC_CHARGE,refresh_flag);		//显示外接电源图标 	
   2573          		}
   2574          		else		//正在充电
   2575          		{
   2576          			gui_PictureOut(GUI_WIDTH-24,0, PIC_BAT4,refresh_flag);
   2577          			OSTimeDlyHMSM(0,0,0,200);
   2578          			gui_PictureOut(GUI_WIDTH-24,0, PIC_BAT_SHAN,refresh_flag);	//显示充电图标
   2579          		}
   2580          	}
   2581          
   2582          	return 0;
   2583          }
   2584          
   2585          /**
   2586          * @brief 显示对话框中编辑框的输入法ICON
   2587          */
   2588          void show_input_method_icon(unsigned short x,unsigned short y,TEdit *pEdit,unsigned char mode)
   2589          {
   2590          	TEditAttribute		edit_attr;
   2591          	unsigned short		save_txt_color;
   2592          
   2593          
   2594          	save_txt_color =  gui_GetTextColor();
   2595          	if(0 == mode)
   2596          	{
   2597          		//第一次创建的编辑框时
   2598          		//gui_FillRect(x,y,12*6,16,BG_COLOR);
   2599          		last_input_method = 0;
   2600          
   2601          		//2013-03-12，决定将所有编辑框的默认首选输入法都修改为数字输入法。
   2602          
   2603          		//获取当前编辑框的属性
   2604          		//edit_get_attribute(pEdit,&edit_attr);
   2605          		//if((edit_attr.style & 0x07) == EDIT_CHINESE)
   2606          		//{
   2607          		//	//允许输入中文的编辑框需要切换输入法，pingyin、ABC、abc、123
   2608          		//	if (LANG_ENGLISH == g_language)
   2609          		//	{
   2610          		//		input_method = ABC_INPUT;
   2611          		//		if ((default_input_method_patch)&&(default_input_method_patch != PINYIN_INPUT))
   2612          		//		{
   2613          		//			input_method = default_input_method_patch;
   2614          		//		}
   2615          		//	}
   2616          		//	else
   2617          		//	{
   2618          		//		input_method = PINYIN_INPUT;
   2619          		//		if (default_input_method_patch)
   2620          		//		{
   2621          		//			input_method = default_input_method_patch;
   2622          		//		}
   2623          		//	}
   2624          		//}
   2625          		//else if((edit_attr.style & 0x07) == EDIT_ALPHA)
   2626          		//{
   2627          		//	//允许输入字母的编辑框需要切换输入法，ABC、abc、123
   2628          		//	input_method = ABC_INPUT;
   2629          		//	if (default_input_method_patch)
   2630          		//	{
   2631          		//		input_method = default_input_method_patch;
   2632          		//	}
   2633          		//}
   2634          		//else
   2635          		//{
   2636          		//	input_method = _123_INPUT;
   2637          		//}
   2638          
   2639          		input_method = _123_INPUT;
   2640          	}
   2641          
   2642          
   2643          	if (last_input_method != input_method)
   2644          	{
   2645          		//if (PINYIN_INPUT == last_input_method)
   2646          		{
   2647          			gui_FillRect(x,y,25,12,BG_COLOR,1);
   2648          		}
   2649          		//gui_SetTextColor(BG_COLOR);
   2650          		//只有当上一次使用的输入法与当前输入法不同时才需要重新刷新输入法ICON
   2651          		switch (input_method)
   2652          		{
   2653          		case _123_INPUT:
   2654          			gui_TextOut(x,y,"123",1,1);
   2655          			break;
   2656          		case ABC_INPUT:
   2657          			gui_TextOut(x,y,"ABC",1,1);
   2658          			break;
   2659          		case abc_INPUT:
   2660          			gui_TextOut(x,y,"abc",1,1);
   2661          			break;
   2662          		case PINYIN_INPUT:
   2663          			//gui_TextOut(x,y,"PY",1);
   2664          			gui_TextOut(x,y,"拼音",1,1);
   2665          			break;
   2666          		default:
   2667          			break;
   2668          		}
   2669          		
   2670          		gui_SetTextColor(save_txt_color);
   2671          		last_input_method = input_method;
   2672          	}
   2673          	return;
   2674          }
   2675          
   2676          /**
   2677          * @brief 将对话框pRes所属的菜单,从第index项开始显示出来
   2678          * @param[in] unsigned char highlight_current_item_flag  是否需要高亮当前选择项的标记
   2679          * @note 本函数不对指针进行检查
   2680          */
   2681          void show_menu(unsigned char highlight_current_item_flag)
   2682          {
   2683          	TDialogRes					*pRes;
   2684          	unsigned char						i,tmp_line = 0;
   2685              unsigned short                                    y;
   2686          	unsigned char			dis_str[17];	
   2687                  
   2688          
   2689          	pRes						= g_dlg.pRes;
   2690          	pContent					= get_content(); //pRes->pContent;
   2691          
   2692          	// 清空剩余空间
   2693          	tempy					= 0;
   2694          	if(g_dlg.pRes->style & STYLE_ICON || g_dlg.pRes->style & STYLE_TITLE)
   2695          	{
   2696          		tempy				+= ICON_HEIGHT+1;
   2697          	}
   2698          
   2699          	y = tempy;
   2700          
   2701          	gui_FillRect(0,tempy,GUI_WIDTH-24,user_zone_height, BG_COLOR,0);
   2702          
   2703          
   2704          	/** @note 要注意，内容只能在客户区域中输出，受CLIENT_HEIGHT和字体高度限制 */
   2705          	pContent					+= menu_start+1;		// 跳过第一行和第二行内容，第一行是标题，第二行是快捷键
   2706          
   2707          	i = 0;
   2708          	memset((void*)display_menu_item_array,0,sizeof(display_menu_item_array));
   2709          	while(pContent[tmp_line] && (tempy + gFontSize<= CLIENT_HEIGHT - SHOTCUT_HEIGNT) )
   2710          	{
   2711          		memset(dis_str,0x20,16);
   2712          		dis_str[16] = 0;
   2713          		memcpy(dis_str,pContent[tmp_line],strlen(pContent[tmp_line]));
   2714          		if(((menu_current_item - menu_start) == tmp_line)&&(highlight_current_item_flag == 1))
   2715          		{
   2716          			gui_SetTextColor(BG_COLOR);		//当前选中的菜单反色显示
   2717          		}
   2718          		else
   2719          		{
   2720          			gui_SetTextColor(TXT_COLOR);
   2721          		}
   2722          		gui_TextOut(0, tempy, dis_str,0,0);
   2723          		display_menu_item_array[i++] = menu_start+tmp_line;
   2724          		tmp_line++;
   2725          		tempy					+= gFontSize+1;		//行距为1
   2726          	}
   2727          
   2728          	//if (page_change_tag)
   2729          	//{
   2730          	//	//不考虑某一个界面需要显示两个箭头的情况，也就是说不支持某一个窗体需要分三屏显示
   2731          	//	if (menu_start == 2)
   2732          	//	{
   2733          	//		//需要显示下翻页的图标
   2734          	//		gui_PictureOut(56,CLIENT_HEIGHT-SHOTCUT_HEIGNT,PIC_DOWN);
   2735          	//	}
   2736          	//	else
   2737          	//	{
   2738          	//		//需要显示上翻页的图标
   2739          	//		gui_PictureOut(56,CLIENT_HEIGHT-SHOTCUT_HEIGNT,PIC_UP);
   2740          	//	}
   2741          	//}
   2742          	gui_SetTextColor(TXT_COLOR);
   2743          	gui_refresh(0,0,GUI_WIDTH+2,GUI_HEIGHT);
   2744          }
   2745          
   2746          /**
   2747          ***************************************************************************
   2748          *@brief	创建一个对话框
   2749          *@param[in] 
   2750          *@return 0 正确
   2751          *       -1 错误
   2752          *@warning
   2753          *@see	
   2754          *@note 
   2755          ***************************************************************************
   2756          */
   2757          static void dlg_create(void)
   2758          {
   2759          	if( now_id > max_dlg )
   2760          	{
   2761          		// 出错了，正常情况下id不可能超过 DLG_MAX
   2762          		// 这里添加错误时的提示代码
   2763          		while(1);
   2764          
   2765          	}
   2766          
   2767          	g_dlg.jmplst				= dlg_actionlist[now_id-1].jmplst;
   2768          	g_dlg.pRes					= dlg_actionlist[now_id-1].dlgres;
   2769          	g_dlg.callback				= dlg_actionlist[now_id-1].callback;
   2770          	g_dlg.active				= 1;			// 此域暂时没用
   2771          	g_dlg.name					= dlg_actionlist[now_id-1].name;
   2772          
   2773          	memset((unsigned char*)&g_dlg.edit, 0, sizeof(TEdit));
   2774          }
   2775          /**
   2776          ***************************************************************************
   2777          *@brief	检查是否需要跳转到其他状态
   2778          *@param[in] 
   2779          *@return 
   2780          *@warning
   2781          *@see	
   2782          *@note 
   2783          ***************************************************************************
   2784          */
   2785          static int check_and_jump(unsigned char key)
   2786          {
   2787          	unsigned char					i;
   2788          
   2789          	for( i=0; ;i++ )
   2790          	{
   2791          		if( g_dlg.jmplst[i].key == 0x00 )
   2792          		{
   2793          			return -1;
   2794          		}
   2795          
   2796          		if( g_dlg.jmplst[i].key == key )
   2797          		{
   2798          			if( g_dlg.callback )
   2799          			{
   2800          				g_dlg.callback(DLGCB_DESTORY,&key);
   2801          			}
   2802          			return key;
   2803          		}
   2804          	}
   2805          }
   2806          
   2807          /**
   2808          * @brief 运行一个对话框，并处理对话框绘制及按键等
   2809          * @param[in] TDialog *pDlg 要运行的对话框句柄
   2810          * @param[in] unsigned int mode
   2811          *        bit0   0:normal startup
   2812          *               1:startup without refresh
   2813          * @return 该对话框退出时返回的按键
   2814          */
   2815          static unsigned char dlg_run(unsigned char mode)
   2816          {
   2817          	int						starty;
   2818          	int						ret;
   2819          	unsigned char			i,j,k;
   2820          	unsigned int			update_cursor_cnt = 0;
   2821          	unsigned short			op_timeout;		//背光关闭或者操作的延时
   2822          	unsigned char			*pKey, key;
   2823          	unsigned short			tmp_y;
   2824          	unsigned char			tmp_str[5];
   2825          	unsigned char			highlight_flag;	//显示菜单时是否需要高亮当前选择项的标志
   2826          	unsigned char			virtual_keypad_type;
   2827          	//unsigned char			virtual_keypad_buffer[31];
   2828          	unsigned char			return_from_edit_proc_state_flag;	//标记当前是从虚拟键盘跳回的状态标志
   2829          	static unsigned int			time_out;
   2830          
   2831          	dlg_state						= DLG_INIT;
   2832          	//default_input_method_patch		= 0;
   2833          	number_edit_patch				= 0;
   2834          	highlight_flag	= 1;		//默认需要高亮，只有包含了编辑框的窗体不需要
   2835          	return_from_edit_proc_state_flag = 0;
   2836          	
   2837          	switch(g_param.operate_timeout)
   2838          	{
   2839          	case 1:	//30S
   2840          		time_out = 119; 
   2841          		break;
   2842          	case 2:	//1分钟
   2843          		time_out = 238;
   2844          		break;
   2845          	case 3: //2分钟
   2846          		time_out = 476;
   2847          		break;
   2848          	case 4: //5分钟
   2849          		time_out = 1190;
   2850          		break;
   2851          	default:	//10分钟
   2852          		time_out = 2380;
   2853          	}
   2854          
   2855          	while(1)
   2856          	{
   2857          		switch(dlg_state)
   2858          		{
   2859          			/* *************************************************************************** */
   2860          			/* 对话框初始化部分 */
   2861          			/* *************************************************************************** */
   2862          		case DLG_INIT:
   2863          
   2864          			// ************回调接口一************
   2865          			// 处理窗口创建前的事情
   2866          			// 如有些窗体经状态机跳转，则可以在此处直接返回
   2867          			update_icon_cnt = 0;
   2868          			task_exit_flag = 0;
   2869          			scan_start = 0;
   2870          			roll_display_item_cnt = 0;
   2871          			roll_update_cnt = 0;
   2872          			gui_SetTextColor(TXT_COLOR);
   2873          			if(g_dlg.callback)
   2874          			{
   2875          				// 此处执行窗口创建回调
   2876          				howrun				= (g_dlg.callback)(DLGCB_CREATE,&key);
   2877          
   2878          				// 此处可能返回
   2879          				if(howrun == RUN_NEXT)
   2880          					return key;
   2881          
   2882          				if(howrun == RUN_PREV)
   2883          					return KEY_ESC;
   2884          
   2885          				if (howrun == RUN_EDIT_PROC)
   2886          				{
   2887          					dlg_state = DLG_EDIT_PROC1;
   2888          					break;
   2889          				}
   2890          			}
   2891          	
   2892          			starty					= 0;			// 输出的y坐标
   2893          			edit_state = EDIT_STATE_INIT_STATUS;	//初始化编辑框状态 
   2894          			user_zone_height = GUI_HEIGHT-SHOTCUT_HEIGNT;
   2895          
   2896          			//如果窗体需要延时返回，那么此处标记
   2897          			if( g_dlg.pRes->delay )
   2898          			{
   2899          				g_dlg.delay				= g_dlg.pRes->delay;
   2900          			}
   2901          			else
   2902          			{
   2903          				g_dlg.delay				= -1;
   2904          			}
   2905          
   2906          			op_timeout = 0;
   2907          
   2908          			// ==========================================================================================================
   2909          			// 处理图标栏，固定长度
   2910          			if( g_dlg.pRes->style & STYLE_ICON )
   2911          			{
   2912          				starty				+= ICON_HEIGHT+1;
   2913          				user_zone_height -= ICON_HEIGHT+1;
   2914          
   2915          
   2916          				//如果前面已经有窗体绘制了图标栏就不需要刷新了
   2917          				if (0 == icon_draw_flag)
   2918          				{
   2919          					// fill title
   2920          					gui_FillRect(0,0,GUI_WIDTH,ICON_HEIGHT, BG_COLOR,0);
   2921          					gui_LineH(0,ICON_HEIGHT,GUI_WIDTH,TXT_COLOR,0);
   2922          					//Update ICON
   2923          					dlg_update_icon(0,0);
   2924          					//gui_refresh(0,0,GUI_WIDTH,ICON_HEIGHT);
   2925          					icon_draw_flag = 1;
   2926          				}
   2927          
   2928          				//显示位于ICON栏的标题，标题固定可以显示4个汉字
   2929          				//pContent			= get_content();
   2930          				//gui_FillRect(0,0,12*5,12, BG_COLOR,1);
   2931          				//gui_TextOut(0, 0, pContent[0],0,1);			//标题栏的内容是窗体第一行内容
   2932          			}
   2933          			else
   2934          			{
   2935          				//没有图标栏的窗体，图标栏被清掉了
   2936          				icon_draw_flag = 0;
   2937          
   2938          				if( g_dlg.pRes->style & STYLE_TITLE )
   2939          				{
   2940          					starty				+= ICON_HEIGHT+1;
   2941          					user_zone_height -= ICON_HEIGHT+1;
   2942          					gui_FillRect(0,0,GUI_WIDTH,ICON_HEIGHT, BG_COLOR,0);
   2943          					gui_LineH(0,ICON_HEIGHT,GUI_WIDTH,TXT_COLOR,0);
   2944          					pContent			= get_content();
   2945          					gui_TextOut(0, 0, pContent[0],0,0);			//标题栏的内容是窗体第一行内容
   2946          				}
   2947          			}
   2948          
   2949          			if (0 == mode)
   2950          			{
   2951          				//如果是新创建的窗体,先清屏
   2952          				gui_FillRect(0,starty,GUI_WIDTH,user_zone_height, BG_COLOR,0);
   2953          			}
   2954          
   2955          			//初始化窗体中的编辑框
   2956          			if((g_dlg.pRes->pEdit)&&(return_from_edit_proc_state_flag == 0))
   2957          			{
   2958          				//如果有的窗体的编辑框资源链表在编译阶段是确定不了的，只有在运行时才能确定下来，那么可以在窗体CREATE阶段的回调函数中设置一个标记，表明
   2959          				//此窗体的编辑框资源需要在运行时动态创建，而不是从编译时的资源链表中装载。
   2960          				if (edit_res_rebuild_flag)
   2961          				{
   2962          					//g_dlg.edit.pRes = edit_res_rebuild;			//指向动态创建的编辑框资源链表
   2963          				}
   2964          				else
   2965          				{
   2966          					g_dlg.edit.pRes		= g_dlg.pRes->pEdit;		// 告诉edit，他的资源属性是什么,此处指向的编辑框链表是在编译时已经确定的
   2967          				}
   2968          
   2969          				edit_init(&g_dlg.edit);
   2970          				update_input_method_mode = 0;
   2971          			}
   2972          
   2973          			//处理需要在界面最下面一栏显示快捷菜单
   2974          
   2975          			pContent			= get_content();
   2976          			gui_FillRect(0,CLIENT_HEIGHT-SHOTCUT_HEIGNT,GUI_WIDTH,SHOTCUT_HEIGNT, BG_COLOR,0);
   2977          			if( g_dlg.pRes->style & STYLE_SHORTCUT )
   2978          			{	
   2979          				gui_TextOut(0, CLIENT_HEIGHT-SHOTCUT_HEIGNT, pContent[1],0,0);			//快捷栏的内容是窗体第二行内容
   2980          			}
   2981          
   2982          
   2983          			
   2984          			tmp_y = starty;
   2985          			dlg_state				= DLGCB_DRAW;		// 对话框进入绘制窗体状态（不包括绘制图标及标题栏）
   2986          
   2987          			break;
   2988          
   2989          		case DLGCB_DRAW:
   2990          			// ==========================================================================================================
   2991          			// 显示对话框内容
   2992          			//
   2993                      pContent			= get_content();
   2994          			starty					= tmp_y;
   2995          			menu_all				= 0;
   2996          
   2997          			tempx					= 2;
   2998          			menu_pagecnt			= 0;
   2999          
   3000          			gui_SetTextColor(TXT_COLOR);
   3001          
   3002          			if ((draw_context[0].valid_flag == 1) && (draw_context[0].dlg_id == g_dlg.pRes->id))
   3003          			{
   3004          				menu_start		  = draw_context[0].menu_start;
   3005          				menu_current_item = draw_context[0].menu_current_item;
   3006          			}
   3007          			else if ((draw_context[1].valid_flag == 1) && (draw_context[1].dlg_id == g_dlg.pRes->id))
   3008          			{
   3009          				menu_start		  = draw_context[1].menu_start;
   3010          				menu_current_item = draw_context[1].menu_current_item;
   3011          			}
   3012          			else
   3013          			{
   3014          				menu_start		  = 1;
   3015          				menu_current_item = 1;
   3016          			}
   3017          			
   3018          			while(pContent[tempx])
   3019          			{
   3020          				// 统计每页的菜单项数
   3021          				if( starty + gFontSize <= CLIENT_HEIGHT - SHOTCUT_HEIGNT)
   3022          				{
   3023          					starty			+= gFontSize+1;
   3024          					menu_pagecnt	++;
   3025          				}
   3026          
   3027          				// 统计菜单总项数
   3028          				menu_all			++;							// 菜单项加一
   3029          				tempx				++;
   3030          			}
   3031          
   3032          			if(g_dlg.pRes->pEdit)
   3033          			{
   3034          				highlight_flag = 0;
   3035          			}
   3036          
   3037          			// 显示菜单
   3038          			if( pContent[1] )
   3039          			{
   3040          				show_menu(highlight_flag);
   3041          			}
   3042          
   3043          			// ==========================================================================================================
   3044          			// ************ 回调接口二 ************
   3045          			// 此处处理标准绘制所绘制不到的元素
   3046          			if((g_dlg.callback)&&(return_from_edit_proc_state_flag == 0))
   3047          			{
   3048          				// 执行补绘回调
   3049          				howrun				= (g_dlg.callback)(DLGCB_DRAW,&key);
   3050          				// 此处可能返回
   3051          				if(howrun == RUN_NEXT)
   3052          					return key;
   3053          
   3054          				if(howrun == RUN_PREV)
   3055          					return KEY_ESC;
   3056          			}
   3057          
   3058          			//检查是否是提示窗体，这种窗体没有回调函数,蜂鸣器响声
   3059          			if(g_dlg.pRes->style & STYLE_TIP)
   3060          			{
   3061          				Beep(BEEP_DELAY);
   3062          			}
   3063          
   3064          			// 编辑框刷新显示
   3065          			if(g_dlg.pRes->pEdit)
   3066          			{
   3067          				edit_refresh(&g_dlg.edit,0,0);//刷新所有编辑框
   3068          				//if (edit_is_active(&g_dlg.edit))
   3069          				//{
   3070          				//	//如果包含了可以编辑的编辑框，显示当前编辑框的默认输入法状态
   3071          				//	show_input_method_icon(54,GUI_HEIGHT-SHOTCUT_HEIGNT,&g_dlg.edit,update_input_method_mode);
   3072          				//}
   3073          			}
   3074          
   3075          			dlg_return_from_child = 0;
   3076          			flush_message();		//将界面完整画出来之前按下的按键都清掉
   3077          
   3078          			// 显示按扭
   3079          			dlg_state				= DLG_PROC;		// 对话框进入循环状态
   3080          
   3081          			break;
   3082          
   3083          			/* *************************************************************************** */
   3084          			/* 对话框运行部分 */
   3085          			/* *************************************************************************** */
   3086          		case DLG_PROC:
   3087          			// 取得按键，或等待其他消息
   3088          			if(g_dlg.edit.active ||  (g_dlg.pRes->style & STYLE_ICON) != 0 || g_dlg.delay != -1)
   3089          			{
   3090          				pKey				= dlg_getmessage(0, 25);	//有编辑框的界面，需要更新图标的界面
   3091          			}
   3092          			else
   3093          			{
   3094          				//不需要处理非按键事物的窗体，就堵在此处一直等待按键事件的发生
   3095          				pKey				= dlg_getmessage(0, 0);
   3096          			}
   3097          
   3098          
   3099          			if( pKey == 0 )
   3100          			{
   3101          				if((g_dlg.pRes->style & STYLE_ICON)&&(no_update_icon_flg == 0))
   3102          				{
   3103          					//包含了ICON的界面需要更新ICON和界面时间
   3104          					// 更新时间
   3105          					dlg_updatetime(52, 0);
   3106          					// 更新图标
   3107          					if(++update_icon_cnt >= 5)
   3108          					{
   3109          						update_icon_cnt	= 0;
   3110          						ret = dlg_update_icon(1,1);
   3111          						if (ret == 1)
   3112          						{
   3113          							//dlg_state				= DLG_INIT;			//重新绘制此窗体
   3114          							//break;
   3115          							key = KEY_LOW_POWER;      //相当于按下了退出键
   3116          							goto dlg_handle_key;
   3117          						}
   3118          						else if (ret == 2)
   3119          						{
   3120          							dlg_state				= DLG_INIT;			//重新绘制此窗体
   3121          							break;
   3122          						}
   3123          					}
   3124          				}
   3125          
   3126          				if ((USBLink_Insert_Detect() == 0)&&(g_param.transfer_mode == TRANSFER_MODE_U_DISK)&&(bDeviceState == CONFIGURED))
   3127          				{
   3128          					u_disk_proc();
   3129          				}
   3130          
   3131          				//2012.02.15 joe.zhou增加
   3132          				//如果窗体注册了一个进度条，那么需要更新进度条
   3133          				//if (process_bar.active)
   3134          				//{
   3135          				//	//如果进度条已经被激活，那么需要更新进度条
   3136          				//	process_bar_update();
   3137          				//}
   3138          
   3139          				//包含了非只读属性的编辑框的窗体需要闪烁光标
   3140          				if(edit_is_active(&g_dlg.edit))
   3141          				{
   3142          					input_update_flag++;
   3143          					if ((input_update_flag >= 3)&&(the_last_key == 1))
   3144          					{
   3145          						the_last_key = 0;//标记最后一个按键输入结束
   3146          					}
   3147          					if(++update_cursor_cnt >= 3)
   3148          					{
   3149          						update_cursor_cnt = 0;
   3150          						edit_blink(&g_dlg.edit,0);
   3151          					}	
   3152          				}
   3153          
   3154          				//2013.01.31 joe.zhou增加
   3155          				//包含了需要滚动显示的窗体需要对显示内容进行滚动显示
   3156          				roll_update_cnt++;
   3157          				if (roll_update_cnt>2)
   3158          				{
   3159          					roll_update_cnt = 0;
   3160          					for (i=0;i<roll_display_item_cnt;i++)
   3161          					{
   3162          						if ((roll_display_table[i].display_data[roll_display_table[i].offset] > 0x80)&&(roll_display_table[i].offset < strlen(roll_display_table[i].display_data)))
   3163          						{
   3164          							roll_display_table[i].offset += 2;
   3165          						}
   3166          						else
   3167          						{
   3168          							roll_display_table[i].offset++;
   3169          						}
   3170          
   3171          						if ( roll_display_table[i].offset >= (strlen(roll_display_table[i].display_data)+roll_display_table[i].display_len) )
   3172          						{
   3173          							roll_display_table[i].offset = 0;			
   3174          						}
   3175          
   3176          						if ( roll_display_table[i].offset > strlen(roll_display_table[i].display_data))
   3177          						{
   3178          							memset(roll_data_buffer,0x20,roll_display_table[i].display_len);
   3179          							k = roll_display_table[i].display_len-roll_display_table[i].offset+strlen(roll_display_table[i].display_data);
   3180          							memcpy(roll_data_buffer+k,roll_display_table[i].display_data,roll_display_table[i].offset-strlen(roll_display_table[i].display_data));
   3181          							roll_data_buffer[roll_display_table[i].display_len] = 0;
   3182          							for (j = k;j < roll_display_table[i].display_len;j++)
   3183          							{
   3184          								if (roll_data_buffer[j] > 0x80)
   3185          								{
   3186          									j++;
   3187          								}
   3188          							}
   3189          
   3190          							if (j > roll_display_table[i].display_len)
   3191          							{
   3192          								roll_data_buffer[roll_display_table[i].display_len-1] = 0x20;
   3193          							}
   3194          						}
   3195          						else
   3196          						{
   3197          							if (strlen(roll_display_table[i].display_data+roll_display_table[i].offset) > roll_display_table[i].display_len)
   3198          							{
   3199          								memcpy(roll_data_buffer,roll_display_table[i].display_data+roll_display_table[i].offset,roll_display_table[i].display_len);
   3200          								roll_data_buffer[roll_display_table[i].display_len] = 0;
   3201          								for (j = 0;j < roll_display_table[i].display_len;j++)
   3202          								{
   3203          									if (roll_data_buffer[j] > 0x80)
   3204          									{
   3205          										j++;
   3206          									}
   3207          								}
   3208          
   3209          								if (j > roll_display_table[i].display_len)
   3210          								{
   3211          									roll_data_buffer[roll_display_table[i].display_len-1] = 0;
   3212          								}
   3213          							}
   3214          							else
   3215          							{
   3216          								strcpy(roll_data_buffer,roll_display_table[i].display_data+roll_display_table[i].offset);
   3217          								memset(roll_data_buffer+strlen(roll_display_table[i].display_data+roll_display_table[i].offset),0x20,roll_display_table[i].display_len-strlen(roll_display_table[i].display_data+roll_display_table[i].offset));
   3218          								roll_data_buffer[roll_display_table[i].display_len] = 0;
   3219          							}
   3220          						}
   3221          
   3222          						gui_TextOut(roll_display_table[i].x,roll_display_table[i].y,roll_data_buffer,0,1);
   3223          					}
   3224          				}
   3225          
   3226          				//设定了延时的窗体需要处理窗口延时自动返回上一级窗体
   3227          				if( g_dlg.pRes->delay)
   3228          				{
   3229          					if(g_dlg.pRes->style & STYLE_TIP)
   3230          					{
   3231          						if( op_timeout == 4)
   3232          						{
   3233          							op_timeout = 0;
   3234          							if(g_dlg.callback)
   3235          							{
   3236          								// 执行退出回调
   3237          								howrun			= (g_dlg.callback)(DLGCB_DESTORY,&key);
   3238          							}
   3239          							return  KEY_ESC;		//相当于按下了退出键
   3240          						}
   3241          						else
   3242          						{
   3243          							op_timeout++;
   3244          						}
   3245          					}
   3246          					else
   3247          					{
   3248          						if (g_param.operate_timeout)
   3249          						{
   3250          							//设定了延时时间的界面，根据界面设定的延时，延时时间到之后，相当于按下了ESC键
   3251          							if( op_timeout == (g_param.operate_timeout*200 + g_param.operate_timeout*80/4) )  //2800
   3252          							{
   3253          								op_timeout = 0;
   3254          								key = KEY_ESC;      //相当于按下了退出键
   3255          								goto dlg_handle_key;		
   3256          							}
   3257          							else
   3258          							{
   3259          								op_timeout++;
   3260          							}
   3261          						}
   3262          					}
   3263          				}
   3264          				else
   3265          				{
   3266          					//没有设定延时的界面，需要在延时间到之后关闭屏幕背光，进入低功耗模式
   3267          					if ((g_param.operate_timeout)&&(USBLink_Insert_Detect() == 1))	//外部供电时，设备不会进入低功耗模式
   3268          					//if (g_param.operate_timeout)
   3269          					{
   3270          						if(op_timeout > time_out)		//600//延时时间到，需要关闭背光，主控进入低功耗模式
   3271          						{
   3272          							Lcd_Enter_SleepMode();
   3273          							//gui_CtrlBL(0);
   3274          							// enable Debug in Stop mode
   3275          							DBGMCU->CR |= DBGMCU_CR_DBG_STOP;	//调试时打开，否则进入低功耗时会断开与JLINK的连接
   3276          
   3277          							//if (usb_cable_state)
   3278          							//{
   3279          							//	USB_Cable_Config(0);
   3280          							//}
   3281          							EnterLowPowerMode();
   3282          							ExitLowPowerMode();
   3283          							Lcd_Exit_SleepMode();
   3284          							Calendar_Init();
   3285          
   3286          							//if (usb_cable_state)
   3287          							//{
   3288          							//	USB_Cable_Config(1);
   3289          							//}
   3290                                      goto dlg_handle_key;
   3291          						}
   3292          						else
   3293          						{
   3294          							op_timeout++;
   3295          						}
   3296          					}
   3297          				}
   3298          
   3299          				//此处提供一个接口可以让某些时候窗体没有获取到按键，也可以进入一次处理按键的流程里面去
   3300          				//if (auto_run_flag)
   3301          				//{
   3302          				//	auto_run_flag = 0;
   3303          				//	goto dlg_handle_key;
   3304          				//}
   3305          				////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
   3306          				//此段代码于20110922添加，增加一个接口给窗体，可以使窗体在DRAW完之后，没有任何按键按下之前
   3307          				//循环检测一些系统事件（比如USB设备是否被主机枚举成功、电池电量），并作出相应的反应。
   3308          				if(g_dlg.callback)
   3309          				{
   3310          					howrun				= (g_dlg.callback)(DLGCB_REFRESH,&key);
   3311          					if (howrun == RUN_NEXT)
   3312          					{
   3313          						return key;
   3314          					}
   3315          				}
   3316          				/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
   3317          
   3318          				break;
   3319          			}
   3320          
   3321          			//有获取到按键消息
   3322          			key						= *pKey;
   3323          
   3324          			if (((scan_start)&&(is_key_keypad(key) == 0))||(lowpower_flag > 0))
   3325          			{
   3326          				break;
   3327          			}
   3328          
   3329          			//////////////////////////////////////////////////////////////////////////
   3330          			//此段代码于20110922添加，由于需求将KEY_CLEAR键与KEY_ESC键的功能合二为一，
   3331          			//当前窗体没有编辑框时，按KEY_CLEAR键相当于KEY_ESC
   3332          			//如果当前窗体有编辑框时，按下KEY_CLEAR键清除输入时，如果清除到没有输入值时相当于按下了KEY_ESC.
   3333          			//if (key == KEY_CLEAR)
   3334          			//{
   3335          			//	if ((edit_state != EDIT_STATE_PY_SELECT)&&(edit_state != EDIT_STATE_HZ_SELECT))
   3336          			//	{
   3337          			//		if ((edit_is_active(&g_dlg.edit) == 0)||(g_dlg.edit.now[g_dlg.edit.current_edit] == 0))
   3338          			//		{
   3339          			//			key = KEY_ESC;
   3340          			//		}
   3341          			//	}
   3342          			//}
   3343          			//////////////////////////////////////////////////////////////////////////
   3344          
   3345          dlg_handle_key:
   3346          			//if( 0 == g_dlg.pRes->delay)
   3347          			//{
   3348          			//	if (op_timeout > (g_param.operate_timeout*200 + g_param.operate_timeout*80/5))		//如果是背光已经被关闭的状态
   3349          			//	{				
   3350          			//		gui_CtrlBL(1);		//重新开背光
   3351          			//		op_timeout		= 0;
   3352          			//		break;					//跳出，那么第一次按按键只是将关闭的背光打开
   3353          			//	}
   3354          			//}
   3355          			op_timeout		= 0;
   3356          
   3357          			// ************ 回调接口三 ************
   3358          			// 将消息，丢给用户处理：系统消息，按键消息，定时器消息
   3359          			if(g_dlg.callback)
   3360          			{
   3361          				// 将系统消息分发给应用处理,msg为入口消息，也为返回消息
   3362          				//if (((KEY_ENTER == key  || KEY_UP == key || KEY_DOWN == key)&&(edit_state != EDIT_STATE_HZ_SELECT)&&(edit_state != EDIT_STATE_PY_SELECT)&&
   3363          				//	(edit_state != EDIT_STATE_ZD_NAME_SELECT)&&(edit_state != EDIT_STATE_ZD_VALUE_SELECT))||((key != KEY_ENTER)&&(key != KEY_UP)&&(key != KEY_DOWN)))
   3364          				{
   3365          					howrun				= (g_dlg.callback)(DLGCB_RUN,&key);
   3366          					// 重新运行
   3367          					if(howrun == RUN_RERUN)
   3368          					{
   3369          						break;
   3370          					}
   3371          
   3372          					if (howrun == RUN_RETURN)
   3373          					{
   3374          						dlg_state				= DLG_DRAW;		// 对话框重新绘制
   3375          						break;
   3376          					}
   3377          
   3378          					if (howrun == RUN_EDIT_PROC)
   3379          					{
   3380          						dlg_state = DLG_EDIT_PROC1;
   3381          						break;
   3382          					}
   3383          
   3384          					// 要结束当前对话框
   3385          					if(howrun == RUN_PREV || howrun == RUN_NEXT)
   3386          					{
   3387          						// ************ 回调接口四 ************
   3388          						if(g_dlg.callback)
   3389          						{
   3390          							// 执行退出回调
   3391          							howrun			= (g_dlg.callback)(DLGCB_DESTORY,&key);
   3392          						}
   3393          						return key;
   3394          					}
   3395          				}
   3396          			}
   3397          
   3398          			//如果是数字键，则交给edit处理
   3399          			//if( (is_key_num(key) == 0) && (edit_is_active(&g_dlg.edit)))
   3400          			//{
   3401          			//	edit_proc(&g_dlg.edit, key);
   3402          			//	input_update_flag = 0;
   3403          			//}
   3404          
   3405          
   3406          			//此按键在包含了可编辑的编辑框的窗体中用来切换输入法的
   3407          #if 0
   3408          			if ((KEY_jing == key)&&(edit_is_active(&g_dlg.edit)))
   3409          			{
   3410          				input_method_switch(&g_dlg.edit);	
   3411          				show_input_method_icon(54,GUI_HEIGHT-SHOTCUT_HEIGNT,&g_dlg.edit,1);//显示当前编辑框的输入法ICON
   3412          				//如果当前编辑框状态处于中文输入法状态，而又将输入法切换为非中文输入法时，需要清除专门为中文输入法绘制的区域并重新绘制界面
   3413          				if ((edit_state != EDIT_STATE_INIT_STATUS)&&(input_method != PINYIN_INPUT))
   3414          				{
   3415          					gui_FillRect(0,CHINESE_EDIT_ZONE_Y-1,GUI_WIDTH,CHINESE_EDIT_ZONE_H+1,BG_COLOR);
   3416          					gui_FillRect(32,CLIENT_HEIGHT-SHOTCUT_HEIGNT,16,12,TXT_COLOR);
   3417          					gui_FillRect(80,CLIENT_HEIGHT-SHOTCUT_HEIGNT,16,12,TXT_COLOR);
   3418          					update_input_method_mode = 1;
   3419                              edit_state = EDIT_STATE_INIT_STATUS;
   3420          					show_menu();
   3421          					refresh_draw_content();
   3422          					if (need_refresh_edit_index_tbl[0] == 0)
   3423          					{
   3424          						edit_refresh(&g_dlg.edit,0,0);//刷新所有编辑框
   3425          					}
   3426          					else
   3427          					{
   3428          						for (i= 0;i < 4;i++)
   3429          						{
   3430          							edit_refresh(&g_dlg.edit,1,need_refresh_edit_index_tbl[i]-1);//刷新需要刷新的编辑框
   3431          						}
   3432          
   3433          						//刷新上下翻页键
   3434          						gui_PictureOut(32,CLIENT_HEIGHT-SHOTCUT_HEIGNT,PIC_UP);		//显示下翻页的图标
   3435          						gui_PictureOut(80,CLIENT_HEIGHT-SHOTCUT_HEIGNT,PIC_DOWN);		//显示下翻页的图标
   3436          					}
   3437          					
   3438          					show_input_method_icon(54,GUI_HEIGHT-SHOTCUT_HEIGNT,&g_dlg.edit,0);
   3439          					break;
   3440          				}
   3441          			}
   3442          
   3443          			//如果处于中文输入法时，编辑框已经获取到一组数字键对应的中文编码，将中文编辑框清掉（实际上可以在此处实现联想输入功能）
   3444          			if ((input_method == PINYIN_INPUT)&&(edit_state == EDIT_STATE_CODE_GOT))
   3445          			{
   3446          				//清掉拼音输入法的显示区域
   3447          				gui_FillRect(0,CHINESE_EDIT_ZONE_Y-1,GUI_WIDTH,CHINESE_EDIT_ZONE_H+1,BG_COLOR);
   3448          				gui_FillRect(32,CLIENT_HEIGHT-SHOTCUT_HEIGNT,16,12,TXT_COLOR);
   3449          				gui_FillRect(80,CLIENT_HEIGHT-SHOTCUT_HEIGNT,16,12,TXT_COLOR);
   3450          				update_input_method_mode = 1;
   3451          				edit_state = EDIT_STATE_INIT_STATUS;
   3452          				show_menu();
   3453          				refresh_draw_content();
   3454          				if (need_refresh_edit_index_tbl[0] == 0)
   3455          				{
   3456          					edit_refresh(&g_dlg.edit,0,0);//刷新所有编辑框
   3457          				}
   3458          				else
   3459          				{
   3460          					for (i= 0;i < 4;i++)
   3461          					{
   3462          						edit_refresh(&g_dlg.edit,1,need_refresh_edit_index_tbl[i]-1);//刷新需要刷新的编辑框
   3463          					}
   3464          					gui_PictureOut(32,CLIENT_HEIGHT-SHOTCUT_HEIGNT,PIC_UP);		//显示下翻页的图标
   3465          					gui_PictureOut(80,CLIENT_HEIGHT-SHOTCUT_HEIGNT,PIC_DOWN);		//显示下翻页的图标
   3466          				}
   3467          				show_input_method_icon(54,GUI_HEIGHT-SHOTCUT_HEIGNT,&g_dlg.edit,1);
   3468          				break;
   3469          
   3470          			}
   3471          
   3472          			if (EDIT_STATE_CODE_GOT == edit_state)
   3473          			{
   3474          				edit_state = EDIT_STATE_INIT_STATUS;
   3475          				break;			//20120521 增加
   3476          			}
   3477          
   3478          #endif
   3479          			// 按到上下翻页
   3480          			if((KEY_UP == key|| KEY_DOWN == key) && (edit_state == EDIT_STATE_INIT_STATUS))
   3481          			{
   3482          				//如果包含了非只读编辑框的窗体,且没有处于中文输入法状态时
   3483          				if(edit_is_active(&g_dlg.edit))
   3484          				{
   3485          					//光标跳转到下一个非只读编辑框
   3486          					edit_switch(&g_dlg.edit,key);
   3487          					//show_input_method_icon(54,GUI_HEIGHT-SHOTCUT_HEIGNT,&g_dlg.edit,0);
   3488          					update_cursor_cnt = 0x100;		//保证切换之后的编辑框的光标立即更新
   3489          				}
   3490          				else
   3491          				{
   3492          					if (menu_all > 1)
   3493          					{
   3494          						dlg_state			= DLG_PAGECHANGE;
   3495          						break;
   3496          					}
   3497          				}
   3498          			}
   3499          			// 如果是返回的按键，则返回退出
   3500          			if(((KEY_ENTER == key) &&(edit_state == EDIT_STATE_INIT_STATUS)) || KEY_ESC == key)
   3501          			{
   3502          				// ************ 回调接口四 ************
   3503          				if(g_dlg.callback)
   3504          				{
   3505          					// 执行退出回调
   3506          					howrun			= (g_dlg.callback)(DLGCB_DESTORY,&key);
   3507          				}
   3508          
   3509          				// 直接返回
   3510          				return key;
   3511          			}
   3512          
   3513          			// 查表，下一个？
   3514          			ret						= check_and_jump(key);
   3515          			if( ret != -1 )
   3516          			{
   3517          				return key;
   3518          			}
   3519          			break;
   3520          
   3521          			/* *************************************************************************** */
   3522          			/* 对话框处理翻页功能 */
   3523          			/* *************************************************************************** */
   3524          			// 菜单改变了
   3525          		case DLG_PAGECHANGE:
   3526          			if( KEY_DOWN == key)
   3527          			{	
   3528          				// 下翻页
   3529          				if (menu_current_item == menu_all)
   3530          				{
   3531          					menu_current_item = 1;
   3532          					menu_start = 1;
   3533          				}
   3534          				else
   3535          				{
   3536          					menu_current_item++;
   3537          					if (menu_current_item == (menu_start+menu_pagecnt))
   3538          					{
   3539          						menu_start ++;
   3540          					}
   3541          				}
   3542          			}
   3543          			else
   3544          			{	// 上翻页
   3545          				if (menu_current_item == 1)
   3546          				{
   3547          					menu_current_item = menu_all;
   3548          					menu_start = menu_all - menu_pagecnt + 1;
   3549          				}
   3550          				else
   3551          				{
   3552          					menu_current_item--;
   3553          					if (menu_current_item < menu_start)
   3554          					{
   3555          						menu_start--;
   3556          					}
   3557          				}
   3558          			}
   3559          
   3560          			show_menu(highlight_flag);
   3561          			if(g_dlg.callback)
   3562          			{
   3563          				// 执行回调
   3564          				howrun			= (g_dlg.callback)(DLGCB_PAGECHANGE,&key);
   3565          			}
   3566          
   3567          			dlg_state				= DLG_PROC;
   3568          			break;
   3569          
   3570          		case DLG_EDIT_PROC1:
   3571          			//跳转到处理虚拟键盘进行输入的状态
   3572          			gui_FillRect(0,0,GUI_WIDTH,GUI_HEIGHT,BG_COLOR,1);
   3573          			if (g_param.language == LANG_ENGLISH)
   3574          			{
   3575          				gui_TextOut(0,GUI_HEIGHT-ICON_HEIGHT,"Enter    Select   Del",0,1);
   3576          			}
   3577          			else
   3578          			{
   3579          				gui_TextOut(0,GUI_HEIGHT-ICON_HEIGHT,"确认    选择     删除",0,1);
   3580          			}
   3581          
   3582          			//显示可能已经设置的编辑框的值
   3583          			//strcpy(virtual_keypad_buffer,g_editValue[current_edit]);//将进入虚拟键盘之前的键值保存起来
   3584          			virtual_keypad_type = edit_refresh_ext(&g_dlg.edit);
   3585          
   3586          			//显示虚拟键盘
   3587          			virtual_keypad_proc(virtual_keypad_type,0);
   3588          			dlg_state				= DLG_EDIT_PROC2;
   3589          			break;
   3590          
   3591          		case DLG_EDIT_PROC2:
   3592          			pKey				= dlg_getmessage(0, 25);
   3593          			if (pKey == 0)
   3594          			{
   3595          				input_update_flag++;
   3596          				if ((input_update_flag >= 3)&&(the_last_key == 1))
   3597          				{
   3598          					the_last_key = 0;//标记最后一个按键输入结束
   3599          				}
   3600          				if(++update_cursor_cnt >= 3)
   3601          				{
   3602          					update_cursor_cnt = 0;
   3603          					edit_blink(&g_dlg.edit,1);
   3604          				}
   3605          
   3606          				break;
   3607          			}
   3608          
   3609          			//有获取到按键消息
   3610          			key						= *pKey;
   3611          
   3612          			if (key == KEY_ESC)
   3613          			{
   3614          				//丢弃虚拟键盘接收到的输入
   3615          				if(g_dlg.callback)
   3616          				{
   3617          					// 执行从虚拟键盘返回时的回调
   3618          					howrun			= (g_dlg.callback)(DLGCB_BACK_FROM_VIRTUAL_KEYPAD,&key);
   3619          					if(howrun == RUN_NEXT)
   3620          					{
   3621          						return key;
   3622          					}
   3623          				}
   3624          				gui_FillRect(0,0,GUI_WIDTH,GUI_HEIGHT,BG_COLOR,0);
   3625          				dlg_state				= DLGCB_CREATE;
   3626          				break;
   3627          			}
   3628          			else if (key == KEY_LEFT_SHOTCUT)
   3629          			{
   3630          				//将虚拟键盘接收到的输入放回原来窗体的编辑框中
   3631          				if(g_dlg.callback)
   3632          				{
   3633          					// 执行从虚拟键盘返回时的回调
   3634          					howrun			= (g_dlg.callback)(DLGCB_BACK_FROM_VIRTUAL_KEYPAD,&key);
   3635          					if(howrun == RUN_NEXT)
   3636          					{
   3637          						return key;
   3638          					}
   3639          				}
   3640          
   3641          				gui_FillRect(0,0,GUI_WIDTH,GUI_HEIGHT,BG_COLOR,0);
   3642          				return_from_edit_proc_state_flag = 1;
   3643          				dlg_state				= DLGCB_CREATE;
   3644          				break;
   3645          			}
   3646          			else if (key == KEY_RIGHT_SHOTCUT)
   3647          			{
   3648          				key = KEY_CLEAR;
   3649          			}
   3650          			else
   3651          			{
   3652          				key = virtual_keypad_proc(virtual_keypad_type,key);
   3653          			}
   3654          
   3655          			if(key)
   3656          			{
   3657          				edit_proc(&g_dlg.edit, key,1);
   3658          				input_update_flag = 0;
   3659          			}
   3660          
   3661          			break;
   3662          		}
   3663          	}
   3664          	//return 0;
   3665          }
   3666          
   3667          
   3668          /**
   3669          ***************************************************************************
   3670          *@brief	窗体运行主循环
   3671          *@param[in] 
   3672          *@return 
   3673          *@warning
   3674          *@see	
   3675          *@note 
   3676          ***************************************************************************
   3677          */
   3678          void dlg_loop(void)
   3679          {
   3680          
   3681          	unsigned char						ret;
   3682                  
   3683          	now_id						= 0xFF;	
   3684          
   3685          	for(;;)
   3686          	{
   3687          		if(now_id != next_dlg_id)
   3688          		{
   3689          			now_id				= next_dlg_id;
   3690          			dlg_create();
   3691          			ret					= dlg_run(0);		// run new dialog
   3692          		}
   3693          		else
   3694          		{
   3695          			ret					= dlg_run(1);		// no switch
   3696          		}
   3697          
   3698          		tempx					= 0;
   3699          		while(g_dlg.jmplst[tempx].key)
   3700          		{
   3701          			if(g_dlg.jmplst[tempx].key == ret)
   3702          			{
   3703          				next_dlg_id			= g_dlg.jmplst[tempx].dlgid;
   3704          				break;
   3705          			}
   3706          			tempx++;
   3707          		}
   3708          	}
   3709          }
   3710          
   3711          /**
   3712          * @brief 由task1调用，检测是否有后台任务需要运行，有则运行任务。并将运行结果返回。
   3713          * @note 任务如：PN532刷卡，GPRS通信等
   3714          */
   3715          void dlg_run_task(void)
   3716          {
   3717          	unsigned char					err_code;
   3718          	int								ret_code;
   3719          
   3720          	OSSemPend(pBGCommand, 0, &err_code);
   3721          
   3722          	if(err_code == OS_NO_ERR)
   3723          	{
   3724          		// 如果要启动一个任务
   3725          		if( SCommand == TASK_RUN )
   3726          		{
   3727          			SStatus						= 1;			// busy
   3728          
   3729          			if( SbgTask )
   3730          			{
   3731          				// 直接返回键值
   3732          				ret_code				= SbgTask(SParam1, SParam2, SParam3, SParam4);
   3733          			}
   3734          			else
   3735          			{
   3736          				ret_code				= -1;
   3737          			}
   3738          			SStatus						= 0;
   3739          
   3740          			// 发送命令给界面，告知程序结束
   3741          			task_send_command_to_ui(ret_code);
   3742          		}
   3743          	}
   3744          }
   3745          
   3746          
   3747          
   3748          /**
   3749          * @brief 请求运行一个后台任务
   3750          * @return 0:申请成功递交
   3751          *        -1:有任务在运行，请求失败
   3752          */
   3753          int dlg_run_bgtask(TbgTask callback, int param1, int param2, void *param3, void *param4)
   3754          {
   3755          	if( (dlg_read_bgtask_status() != 0) && callback)
   3756          	{
   3757          		if (SbgTask != callback)
   3758          		{
   3759          			//新请求的任务与后台正在运行的任务不同，那么就将后台正在运行的任务结束
   3760          			SCommand						= TASK_EXIT;
   3761          
   3762          			OSSemPost(pBGCommand);
   3763          			while(SStatus)				//等待当前后台任务结束
   3764          			{
   3765          				OSTimeDlyHMSM(0,0,0,10);
   3766          			}
   3767          		}
   3768          		else
   3769          		{
   3770          			return -1;
   3771          		}
   3772          	}
   3773          
   3774          	SbgTask							= callback;
   3775          	SParam1							= param1;
   3776          	SParam2							= param2;
   3777          	SParam3							= param3;
   3778          	SParam4							= param4;
   3779          	SStatus							= 0;
   3780          
   3781          	SCommand						= TASK_RUN;
   3782          
   3783          	OSSemPost(pBGCommand);
   3784          
   3785          	return 0;
   3786          }
   3787          
   3788          /**
   3789          * @brief 给UI调用，检查后台程序运行状态
   3790          */
   3791          int dlg_read_bgtask_status(void)
   3792          {
   3793          	return SStatus;
   3794          }
   3795          
   3796          /**
   3797          * @brief 界面发送一个命令给任务
   3798          * @return 0:命令发送成功
   3799          *        -1:命令发送失败
   3800          */
   3801          int ui_send_command_to_task(int command)
   3802          {
   3803          	SCommand						= command;
   3804          	if( OSSemPost(pBGCommand) == OS_ERR_NONE)
   3805          		return 0;
   3806          	else
   3807          		return -1;
   3808          }
   3809          
   3810          /**
   3811          * @brief 读一个来自UI的命令
   3812          * @param[in] int *command 读取一个来自主机的命令
   3813          * @return 0:成功
   3814          *        -1:无命令
   3815          */
   3816          int task_read_command_from_ui(int *command, int waitend)
   3817          {
   3818          	unsigned char						err_code;
   3819          	int									timeout;
   3820          
   3821          	if(waitend == 0)
   3822          		timeout							= 3;
   3823          	else
   3824          		timeout							= waitend;
   3825          
   3826          
   3827          	do{
   3828          		OSSemPend(pBGCommand, timeout, &err_code);	// 是否有来自前台的命令？
   3829          		if(err_code == OS_ERR_NONE )
   3830          		{
   3831          			*command					= SCommand;
   3832          			return 0;
   3833          		}
   3834          	}while(waitend);
   3835          
   3836          	return -1;
   3837          }
   3838          
   3839          
   3840          /**
   3841          * @brief 任务发送一个命令(键值)给前台ui
   3842          * @return 0:发送成功
   3843          *        -1:发送失败
   3844          */
   3845          int task_send_command_to_ui(int command)
   3846          {
   3847          	unsigned char					err_code;
   3848          	SReturn							= command;
   3849          
   3850          	err_code						= OSQPost(pKeyOSQ, (void*)&SReturn);
   3851          	if( err_code == OS_ERR_NONE)
   3852          		return 0;
   3853          	else
   3854          		return err_code;
   3855          }
   3856          
   3857          
   3858          //保存某窗体跳转时一些需要保存的信息
   3859          void saveDrawContext(void)
   3860          {
   3861          	if ((draw_context[0].valid_flag  == 1)&&(draw_context[0].dlg_id != g_dlg.pRes->id))
   3862          	{
   3863          		draw_context[1].valid_flag = 1;
   3864          		draw_context[1].dlg_id = g_dlg.pRes->id;
   3865          		draw_context[1].menu_start = menu_start;
   3866          		draw_context[1].menu_current_item = menu_current_item;
   3867          	}
   3868          	else
   3869          	{
   3870          		draw_context[0].valid_flag = 1;
   3871          		draw_context[0].dlg_id = g_dlg.pRes->id;
   3872          		draw_context[0].menu_start = menu_start;
   3873          		draw_context[0].menu_current_item = menu_current_item;
   3874          	}
   3875          }
   3876          
   3877          //保存某窗体跳转时一些需要保存的信息
   3878          void releaseDrawContext(void)
   3879          {
   3880          	if (draw_context[1].valid_flag  == 1)
   3881          	{
   3882          		if (draw_context[1].dlg_id == g_dlg.pRes->id)
   3883          		{
   3884          			draw_context[1].valid_flag = 0;
   3885          		}
   3886          	}
   3887          	else
   3888          	{
   3889          		if (draw_context[0].dlg_id == g_dlg.pRes->id)
   3890          		{
   3891          			draw_context[0].valid_flag = 0;
   3892          		}
   3893          	}
   3894          }
   3895          
   3896          void InitDrawContext(void)
   3897          {
   3898          	draw_context[0].valid_flag = 0;
   3899          	draw_context[1].valid_flag = 0;
   3900          }
   3901          
   3902          
   3903          

   Maximum stack usage in bytes:

     Function                  .cstack
     --------                  -------
     InitDrawContext                0
     check_and_jump                 8
     disp_len                       8
     dlg_create                     8
     dlg_getmessage                16
     dlg_init                       8
     dlg_loop                       8
     dlg_read_bgtask_status         0
     dlg_run                       56
     dlg_run_bgtask                24
     dlg_run_task                  16
     dlg_update_icon               24
     dlg_updatetime                32
     edit_atof                     32
     edit_atoi                     16
     edit_atoi_100X                24
     edit_blink                    32
     edit_disable                   0
     edit_enable                    0
     edit_etos                     24
     edit_get_attribute             8
     edit_getvalue                  8
     edit_init                     24
     edit_is_active                 0
     edit_itoa                     32
     edit_itoa_100X                40
     edit_proc                     48
     edit_refresh                  96
     edit_refresh_ext              80
     edit_set_BgColor               0
     edit_set_Font                  0
     edit_set_TextColor             0
     edit_setvalue                 16
     edit_stoe                     16
     edit_switch                   32
     edit_switch_ext               32
     exp10                          0
     flush_message                  8
     get_content                    0
     i2key                          0
     is_key_keypad                  0
     is_key_num                     0
     memcpy                         8
     memset                         8
     process_bar_cancle             0
     process_bar_regist             0
     process_bar_update             0
     refresh_draw_content           0
     releaseDrawContext             0
     saveDrawContext                0
     show_input_method_icon        32
     show_menu                     48
     task_read_command_from_ui     24
     task_send_command_to_ui        8
     ui_send_command_to_task        8
     virtual_keypad_proc          144


   Section sizes:

     Function/Label                                 Bytes
     --------------                                 -----
     memcpy                                           14
     memset                                           20
     menu_all                                          1
     menu_pagecnt                                      1
     user_zone_height                                  4
     now_id                                            1
     howrun                                            1
     dlg_state                                         1
     pContent                                          4
     the_last_key                                      1
     SCommand                                          4
     SbgTask                                           4
     SParam1                                           4
     SParam2                                           4
     SParam3                                           4
     SParam4                                           4
     SReturn                                           1
     SStatus                                           4
     lowpower_detect_cnt                               4
     last_power_level                                  4
     draw_context                                      8
     display_menu_item_array                           8
     menu_current_item                                 1
     menu_start                                        1
     icon_draw_flag                                    1
     g_editValue                                      64
     max_dlg                                           1
     next_dlg_id                                       1
     g_dlg                                            52
     pBGCommand                                        4
     update_input_method_mode                          1
     input_method                                      1
     last_input_method                                 1
     max_edit                                          1
     all_edit                                          1
     edit_res_rebuild_flag                             1
     number_edit_patch                                 1
     same_key_times                                    1
     tempx                                             1
     tempy                                             2
     update_icon_cnt                                   1
     edit_display_x_patch                              2
     lowpower_flag                                     4
     bluetooth_match_cmd_cnt                           4
     bluetooth_state_cnt                               4
     roll_display_table                               24
     roll_display_item_cnt                             1
     roll_update_cnt                                   1
     roll_data_buffer                                 24
     dlg_return_from_child                             1
     exp10                                            36
     is_key_num                                       88
     is_key_keypad                                    64
     dlg_init                                         40
     i2key                                           144
     dlg_getmessage                                   24
     flush_message                                    12
     disp_len                                         14
     refresh_draw_content                              2
     edit_init                                       284
     edit_get_attribute                               64
     edit_set_Font                                    30
     edit_set_BgColor                                 12
     edit_set_TextColor                               12
     edit_refresh                                   2028
     edit_refresh_ext                               1424
     virtual_keypad_proc                            1208
     x                                                 1
     y                                                 1
     start_y                                           1
     edit_proc                                      1864
     edit_blink                                      296
     edit_is_active                                   30
     edit_enable                                      12
     edit_disable                                     12
     edit_switch                                     416
     edit_switch_ext                                 224
     edit_setvalue                                   112
     edit_atoi                                        44
     edit_atoi_100X                                   98
     edit_atof                                       188
     edit_itoa                                       110
     edit_itoa_100X                                  268
     edit_stoe                                        68
     edit_etos                                        34
     edit_getvalue                                    44
     get_content                                      40
     dlg_updatetime                                   96
     process_bar_regist                                2
     process_bar_cancle                                2
     process_bar_update                                2
     dlg_update_icon                                 836
     show_input_method_icon                          228
     show_menu                                       332
     dlg_create                                      136
     check_and_jump                                   76
     dlg_run                                        3584
     time_out                                          4
     dlg_loop                                        136
     dlg_run_task                                    120
     dlg_run_bgtask                                  160
     dlg_read_bgtask_status                           12
     ui_send_command_to_task                          36
     task_read_command_from_ui                        68
     task_send_command_to_ui                          40
     saveDrawContext                                 108
     releaseDrawContext                               60
     InitDrawContext                                  20
     ??DataTable0                                      4
     ??DataTable1                                      4
     ??DataTable2                                      4
     ??DataTable3                                      4
     ??DataTable4                                      4
     ??DataTable6                                      4
     ??DataTable8                                      4
     ??DataTable10                                     4
     ??DataTable11                                     4
     ??DataTable12                                     4
     ??DataTable13                                     4
     ??DataTable14                                     4
     ??DataTable39                                     4
     ??DataTable46                                     4
     ??DataTable55                                     4
     ??DataTable60                                     4
     ??DataTable62                                     4
     ?<Constant ".">                                   2
     ?<Constant "*">                                   2
     ?<Constant "                    ">               24
     ?<Constant "0">                                   2
     ?<Constant {{48, 49, 50, 51, 52}, {53, 54, 55,   12
     ?<Constant {{48, 49, 50, 51, 52, 53, 54, 55, 5  100
     ?<Constant "%02d:%02d">                          12
     ?<Constant "\r">                                  2
     ?<Constant "\317\265\315\263\265\347\301\277\2   16
     ?<Constant "\307\353\262\345\310\353\315\342\2   16
     ?<Constant "POWER OFF">                          12
     ?<Constant "123">                                 4
     ?<Constant "ABC">                                 4
     ?<Constant "abc">                                 4
     ?<Constant "\306\264\322\364">                    8
     ?<Constant "Enter    Select   Del">              24
     ?<Constant "\310\267\310\317    \321\241\324\3   24

 
    276 bytes in section .bss
    268 bytes in section .rodata
 15 502 bytes in section .text
 
 15 468 bytes of CODE  memory (+ 34 bytes shared)
    268 bytes of CONST memory
    276 bytes of DATA  memory

Errors: none
Warnings: 23
