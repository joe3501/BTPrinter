###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     26/Sep/2015  11:37:26 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\H520B\FW\src\App\record.c                             #
#    Command line =  E:\H520B\FW\src\App\record.c -lcN                        #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\List\ -o           #
#                    E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\ --no_cse      #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    5.4\arm\INC\DLib_Config_Full.h" -I                       #
#                    E:\H520B\FW\src\Project\EWARMv5\..\ -I                   #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\App\ -I            #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Drivers\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\FatFs\ -I          #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\Lib\inc\ -I        #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-CPU\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC-LIB\ -I    #
#                    E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Ports #
#                    \ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\ #
#                    Source\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\uCOS\uC #
#                    -Probe\ -I E:\H520B\FW\src\Project\EWARMv5\..\..\usb_lib #
#                    \ -I "C:\Program Files\IAR Systems\Embedded Workbench    #
#                    5.4\arm\INC\" -Ol                                        #
#    List file    =  E:\H520B\FW\src\Project\EWARMv5\Debug\List\record.lst    #
#    Object file  =  E:\H520B\FW\src\Project\EWARMv5\Debug\Obj\record.o       #
#                                                                             #
#                                                                             #
###############################################################################

E:\H520B\FW\src\App\record.c
      1          /**
      2           * @file record.c
      3           * @brief H520B项目记录管理模块
      4           * @version 1.0
      5           * @author joe
      6           * @date 2015年09月10日
      7           * @note 利用SPI Flash 实现的FAT文件系统保存记录
      8           *
      9           * 此代码为深圳合杰电子有限公司项目代码，任何人及公司未经许可不得复制传播，或用于
     10           * 本公司以外的项目。本司保留一切追究权利。
     11           *
     12           * <h1><center>&copy; COPYRIGHT 2015 heroje</center></h1>
     13           */
     14          
     15          #include "record.h"
     16          #include "crc32.h"
     17          #include <string.h>
     18          #include "TimeBase.h"
     19          #include "ff.h"
     20          #include "hash.h"
     21          #include "JMemory.h"
     22          
     23          unsigned char			rec_module_buffer[RECORD_MAX_SIZE];	//记录模块的公用buffer	
     24          
     25          
     26          unsigned int current_node_offset;
     27          unsigned int g_rec_offset;
     28          
     29          static unsigned int	prev_node_offset;
     30          static unsigned int	next_node_offset;
     31          
     32          
     33          static unsigned int log_len;
     34          
     35          FIL						file2,file3;
     36          DIR						dir;							//文件夹
     37          
     38          
     39          #ifdef T5_SD_DEBUG
     40          FIL						debug_file;
     41          unsigned int			debug_file_status;
     42          #endif
     43          
     44          extern FIL				file1;
     45          FATFS			fs;
     46          
     47          
     48          typedef struct  
     49          {
     50          	unsigned char					magic[4];
     51          	unsigned int					xor;
     52          	unsigned int					xor_data;
     53          	unsigned int					length;
     54          	unsigned char					OEMName[16];
     55          	unsigned char					Version[16];
     56          	unsigned char					Date[16];
     57          }TPackHeader;
     58          
     59          /**
     60          * @brief 初始化哈希表文件
     61          */
     62          static int init_hash_table_file(FIL* file)
     63          {
     64          	unsigned char	buffer[512];
     65          	unsigned int	r_w_byte_cnt,i;
     66          
     67          	f_lseek(file,0);
     68          	memset(buffer,0,512);
     69          	for (i = 0; i< ((HASH_TABLE_SIZE*4)/512);i++)
     70          	{
     71          		if (f_write(file,buffer,512,&r_w_byte_cnt) != FR_OK)
     72          		{
     73          			return -1;
     74          		}
     75          
     76          		if (r_w_byte_cnt != 512)
     77          		{
     78          			return -1;
     79          		}
     80          	}
     81          
     82          	if (f_truncate(file) != FR_OK)
     83          	{
     84          		return -1;
     85          	}
     86          
     87          	f_sync(file);
     88          
     89          	return FR_OK;
     90          }
     91          
     92          /**
     93          * @brief 初始化序列号信息文件
     94          */
     95          static int init_data_info_file(FIL* file)
     96          {
     97          	unsigned char	buffer[12];
     98          	unsigned int	r_w_byte_cnt;
     99          
    100          	f_lseek(file,0);
    101          	memcpy(buffer,"info",4);
    102          	memset(buffer+4,0,8);
    103          	
    104          
    105          	if (f_write(file,buffer,12,&r_w_byte_cnt) != FR_OK)
    106          	{
    107          		return -1;
    108          	}
    109          
    110          	if (r_w_byte_cnt != 12)
    111          	{
    112          		return -1;
    113          	}
    114          
    115          	if (f_truncate(file) != FR_OK)
    116          	{
    117          		return -1;
    118          	}
    119          
    120          	f_sync(file);
    121          
    122          	return FR_OK;
    123          }
    124          
    125          /**
    126           * @brief 系统的所有记录模块的初始化
    127           * @return 0: OK   else: 错误代码
    128           * @note: 返回值不能很好的定位到具体的错误发生的位置，后续有需要再修改
    129           */
    130          int record_module_init(void)
    131          {
    132          	unsigned int		j;	
    133          	unsigned char		dir_str[35];
    134          	const unsigned char	*p_hash_table_file[3];
    135          	int ret;
    136          
    137          	f_mount(0, &fs);										// 装载文件系统
    138          
    139          reopen:
    140          	ret = f_opendir(&dir,batch_dirctory);
    141          	if( ret != FR_OK )
    142          	{
    143          		if (ret == FR_NO_FILESYSTEM)
    144          		{
    145          			//如果是还没有创建文件系统，那么就格式化文件系统
    146          			ret = f_mkfs(0,1,512);
    147          
    148          			if (ret != FR_OK)
    149          			{
    150          				return -1;
    151          			}
    152          
    153          			goto reopen;
    154          		} 
    155          
    156          		//打开记录文件失败或者无法访问SD卡,如果是该文件夹不存在，那么就创建一个新的文件夹
    157          		if (f_mkdir(batch_dirctory) != FR_OK)
    158          		{
    159          			//无法访问SD卡
    160          			return 1;	
    161          		}
    162          
    163          		if( f_opendir(&dir,batch_dirctory) != FR_OK )
    164          		{
    165          			//刚创建成功了还打不开，那就诡异了（会出现这个错误吗？？？）
    166          			return 1;
    167          		}
    168          	}
    169          
    170          	p_hash_table_file[0] = barcode_hash_table_file;
    171          	p_hash_table_file[1] = batch_inf_file;
    172          	p_hash_table_file[2] = 0;
    173          
    174          	j = 0;
    175          	while (p_hash_table_file[j])
    176          	{
    177          		strcpy((char*)dir_str,batch_dirctory);
    178          		strcat((char*)dir_str,(char const*)p_hash_table_file[j]);
    179          
    180          		if (f_open(&file1,(const char*)dir_str,FA_OPEN_ALWAYS | FA_WRITE) != FR_OK)
    181          		{
    182          			return 2;
    183          		}
    184          
    185          		if (j == 0)
    186          		{
    187          			if (file1.fsize != HASH_TABLE_SIZE*4)
    188          			{
    189          				if (init_hash_table_file(&file1) != FR_OK)
    190          				{
    191          					return 3;
    192          				}
    193          			}
    194          		}
    195          		else if (j == 1)
    196          		{
    197          			if ((file1.fsize < 12)||(file1.fsize > 12 + 4*BATCH_LIST_MAX_CNT))
    198          			{
    199          				if (init_data_info_file(&file1) != FR_OK)
    200          				{
    201          					return 3;
    202          				}
    203          			}
    204          		}
    205          
    206          		f_sync(&file1);
    207          		j++;
    208          	}
    209          
    210          	current_node_offset = 0;
    211          	return 0;
    212          }
    213          
    214          /**
    215           * @brief 读脱机记录，该记录必须存在，此函数中不作判断
    216           * @param[in] int index 记录的索引(最老的记录的索引号是1)
    217           * @return 返回记录的地址
    218           */
    219          unsigned char *record_module_read(unsigned int index)
    220          {
    221          	unsigned char	dir_str[35];
    222          	unsigned int	node_size;
    223          	unsigned char	*pBuf;
    224          	unsigned int	checkvalue;
    225          
    226          	if (index == 0)
    227          	{
    228          		return (unsigned char*)0;
    229          	}
    230          	
    231          	pBuf = rec_module_buffer;
    232          
    233          	strcpy((char*)dir_str,batch_dirctory);
    234          	strcat((char*)dir_str,(char const*)batch_list_file);
    235          	node_size = sizeof(TBATCH_NODE);
    236          
    237          
    238          	if (f_open(&file1,(char const*)dir_str,FA_OPEN_EXISTING | FA_READ) != FR_OK)
    239          	{
    240          		return (unsigned char*)0;
    241          	}
    242          
    243          	if (file1.fsize < node_size*index)
    244          	{
    245          		f_close(&file1);
    246          		return (unsigned char*)0;
    247          	}
    248          
    249          	f_lseek(&file1,node_size*(index-1));
    250          
    251          	if (f_read(&file1,pBuf,node_size,&node_size) != FR_OK)
    252          	{
    253          		f_close(&file1);
    254          		return (unsigned char*)0;
    255          	}
    256          
    257          	checkvalue = crc32(0,pBuf+4,node_size-4);
    258          	if (memcmp((unsigned char*)&checkvalue,pBuf,4))
    259          	{
    260          		//校验值不对
    261          		f_close(&file1);
    262          		return (unsigned char*)0;
    263          	}
    264          
    265          	f_close(&file1);
    266          	return pBuf;
    267          }
    268          
    269          //计算校验值并填回去
    270          static calc_check_value(unsigned char *precord)
    271          {
    272          	unsigned int		checkvalue;
    273          
    274          	//计算此份记录的校验值，放到记录的最前面4个字节
    275          	checkvalue = crc32(0,precord + 4,sizeof(TBATCH_NODE) - 4);
    276          
    277          	memcpy(precord,(unsigned char*)&checkvalue,4);
    278          }
    279          /**
    280          * @brief 增加一个脱机节点到记录文件之后更新记录文件的链表
    281          * @param[in] FIL *file						记录文件指针,已经打开的文件
    282          * @param[in] unsigned char key_type			关键字类型
    283          * @param[in] unsigned char	*p_node			要新增的节点指针	
    284          * @param[in] unsigned int	header			链表首地址
    285          * @param[in] unsigned int	node_offset		要增加节点的偏移
    286          * @return 0:成功
    287          *        else:失败
    288          * @note 只有商品信息节点是双向链表，所以增加节点时需要维护双向链表，其余节点都是单向链表
    289          */
    290          static int  update_link_info_after_addNode(FIL *file,unsigned char key_type,unsigned char*p_node,unsigned int header,unsigned int node_offset)
    291          {
    292          	unsigned int	rec_size,next_node_offset,current_offset,tmp;
    293          	unsigned char	buffer[RECORD_MAX_SIZE];		//如果一个节点的大小超过了512，那么还需要增加此临时空间
    294          
    295          	rec_size = sizeof(TBATCH_NODE);
    296          
    297          	next_node_offset = header;
    298          	while (next_node_offset)
    299          	{
    300          		current_offset = next_node_offset;
    301          		f_lseek(file,(next_node_offset-1)*rec_size);		//文件指针定位到链表首记录的偏移处，注意链表中记录的偏移是该节点结束的偏移
    302          		if (f_read(file,buffer,rec_size,&tmp) != FR_OK)
    303          		{
    304          			return -2;
    305          		}
    306          
    307          		if (key_type == 1)
    308          		{
    309          			next_node_offset = ((TBATCH_NODE*)buffer)->by_barcode_next;
    310          			if (next_node_offset == 0)
    311          			{
    312          				((TBATCH_NODE*)buffer)->by_barcode_next = node_offset;
    313          				((TBATCH_NODE*)p_node)->by_barcode_prev = current_offset;
    314          				((TBATCH_NODE*)p_node)->by_barcode_next = 0;
    315          			}
    316          		}
    317          		else
    318          		{
    319          			next_node_offset = ((TBATCH_NODE*)buffer)->by_index_next;
    320          			if (next_node_offset == 0)
    321          			{
    322          				((TBATCH_NODE*)buffer)->by_index_next = node_offset;
    323          				((TBATCH_NODE*)p_node)->by_index_prev = current_offset;
    324          				((TBATCH_NODE*)p_node)->by_index_next = 0;
    325          			}
    326          		}
    327          	}
    328          
    329          	calc_check_value(buffer);
    330          	f_lseek(file,(current_offset-1)*rec_size);		//文件指针重新定位到链表最后一个节点处
    331          	if (f_write(file,buffer,rec_size,&tmp) != FR_OK)
    332          	{
    333          		return -3;
    334          	}
    335          
    336          	if (tmp != rec_size)
    337          	{
    338          		return -3;
    339          	}
    340          
    341          	f_sync(file);
    342          	
    343          	return 0;
    344          }
    345          
    346          
    347          //将准备进行的文件操作的相关信息保存到日志文件
    348          //note : 对于每一种操作来说参数列表中的参数的含义都不相同
    349          //       op_type == OP_TYPE_ADD_NODE 时,		param1 表示记录类型, param2 表示新增节点的偏移  param3 表示新增节点的长度  param4 指向新增节点数据
    350          //		 op_type == OP_TYPE_CLEAR_NODE 时,		param1 表示记录类型, param2 无意义					param3 无意义 param4 无意义
    351          //		 op_type == OP_TYPE_DEL_NODE 时,		param1 表示记录类型, param2 表示要删除节点的偏移	param3 无意义 param4 无意义
    352          //		 op_type == OP_TYPE_REPLACE_NODE 时,	param1 表示记录类型, param2 表示要替换节点的偏移	param3 表示替换节点的长度  param4 指向新替换节点数据
    353          //		 op_type == OP_TYPE_WRITE_BIN_FILE 时,	param1 表示记录类型, param2 表示文件类型	param3 无意义  param4 无意义
    354          static int save_log_file(void *data,unsigned int len)
    355          {
    356          	unsigned int tmp;
    357          	unsigned int llen;
    358          	unsigned char tmp_buffer[530];
    359          	//将该操作保存到日志文件中
    360          	if (f_open(&file3,log_file,FA_OPEN_ALWAYS | FA_READ | FA_WRITE) != FR_OK)
    361          	{
    362          		return -1;
    363          	}
    364          
    365          	if (log_len == 0)
    366          	{
    367          		llen = len+4;
    368          	}
    369          	else
    370          	{
    371          		llen = log_len+len;
    372          	}
    373          	
    374          	f_lseek(&file3,file3.fsize-log_len);
    375          
    376          	if (log_len)
    377          	{
    378          		if (f_read(&file3,(void*)&tmp_buffer,log_len,&tmp) != FR_OK)
    379          		{
    380          			f_close(&file3);
    381          			return -1;
    382          		}
    383          
    384          		if (tmp != log_len)
    385          		{		
    386          			f_close(&file3);
    387          			return -1;
    388          		}
    389          	}
    390          	memcpy((void*)tmp_buffer,(void*)&llen,4);
    391          	if (log_len)
    392          	{
    393          		memcpy((void*)(tmp_buffer+log_len),data,len);
    394          	}
    395          	else
    396          	{
    397          		memcpy((void*)(tmp_buffer+4),data,len);
    398          	}
    399          	
    400          	f_lseek(&file3,file3.fsize-log_len);
    401          	if(f_write(&file3,tmp_buffer,llen,&tmp) != FR_OK)
    402          	{
    403          		f_close(&file3);
    404          		return -1;
    405          	}
    406          
    407          	if (tmp != llen)
    408          	{
    409          		f_close(&file3);
    410          		return -1;
    411          	}
    412          	f_close(&file3);		//关闭日志文件
    413          	log_len = llen;
    414                  return 0;
    415          }
    416          
    417          
    418          //清除日志文件最新添加的日志
    419          int clear_log_file(int mode)
    420          {
    421          	if (f_open(&file3,log_file,FA_OPEN_ALWAYS | FA_READ | FA_WRITE) != FR_OK)
    422          	{
    423          		return -1;
    424          	}
    425          
    426          	if (mode)
    427          	{
    428          		f_lseek(&file3,0);
    429          	}
    430          	else
    431          	{
    432          		if (file3.fsize >= log_len)
    433          		{
    434          			f_lseek(&file3,file3.fsize-log_len);
    435          		}
    436          	}
    437          	f_truncate(&file3);
    438          
    439          	f_close(&file3);
    440          	return 0;
    441          }
    442          
    443          /**
    444          * @brief 增加一条脱机记录
    445          * @param[in] unsigned char *precord 记录指针
    446          * @return 0:成功
    447          *        else:失败
    448          * @note 此函数已经增加断电保护
    449          */
    450          int record_add(unsigned char *precord)
    451          {
    452          	unsigned char	dir_str[35];
    453          	unsigned char	inf_file_str[35];
    454          	unsigned int	rec_offset,i;
    455          	unsigned int	node_size,tmp;
    456          	unsigned long	hash_value[2];
    457          	const unsigned char	*p_hash_table_file[3];
    458          	unsigned int		link_end;		//链表的尾地址
    459          	//const unsigned char	*target_dir;
    460          	//unsigned int		target_max_cnt;
    461          	unsigned int		invalid_node_offset = 0;
    462          	unsigned int		temp;
    463          	int					err_code = 0;
    464          	unsigned int		log_data[3];
    465          
    466          	log_len = 0;
    467          
    468          	//target_dir = batch_dirctory;
    469          	strcpy((char*)dir_str,batch_dirctory);
    470          	strcat((char*)dir_str,(char const*)batch_list_file);
    471          	node_size = sizeof(TBATCH_NODE);
    472          	hash_value[0] = HashString(((TBATCH_NODE*)precord)->barcode,0);	//计算该商品条码的hash值
    473          	hash_value[1] = 2;
    474          	p_hash_table_file[0] = barcode_hash_table_file;
    475          	p_hash_table_file[1] = batch_inf_file;
    476          	p_hash_table_file[2] = 0;
    477          	//target_max_cnt = BATCH_LIST_MAX_CNT;		
    478          
    479          	strcpy((char*)inf_file_str,batch_dirctory);
    480          	strcat((char*)inf_file_str,(char const*)batch_inf_file);
    481          
    482          	if (f_open(&file1,(char const*)inf_file_str,FA_OPEN_EXISTING | FA_READ) != FR_OK)
    483          	{
    484          		return -2;
    485          	}
    486          
    487          	if (file1.fsize > 12)
    488          	{
    489          		f_lseek(&file1,file1.fsize-4);
    490          		if ((f_read(&file1,(void*)&invalid_node_offset,4,&tmp) != FR_OK) ||(tmp != 4))		//获取保存在序列号信息文件中的某一个已经被删除节点的偏移
    491          		{
    492          			f_close(&file1);
    493          			return -4;
    494          		}
    495          	}
    496          
    497          	f_close(&file1);
    498          
    499          
    500          	//打开保存相应记录的节点文件
    501          	if (f_open(&file1,(const char*)dir_str,FA_OPEN_ALWAYS | FA_READ | FA_WRITE) != FR_OK)
    502          	{
    503          		return -2;
    504          	}
    505          
    506          	if (invalid_node_offset)
    507          	{
    508          		rec_offset = invalid_node_offset;		//如果是新增序列号节点，并且记录文件中存在已经被删除的节点，那么新增的节点
    509          	}
    510          	else
    511          	{
    512          		rec_offset = file1.fsize/node_size;		//获取记录文件当前已经保存的记录数
    513          		if (rec_offset < BATCH_LIST_MAX_CNT)
    514          		{
    515          			rec_offset += 1;	
    516          		}
    517          		else
    518          		{
    519          			//rec_offset = 1;		//如果记录数达到了上限值，那么无法增加新记录
    520          			f_close(&file1);
    521          			return -20;
    522          		}
    523          	}
    524          
    525          	g_rec_offset = rec_offset;
    526          #ifdef REC_DEBUG
    527          	debug_out("\x0d\x0a",2,1);
    528          	debug_out("Add Node:",strlen("Add Node:"),1);
    529          	debug_out((unsigned char*)&rec_offset,4,0);
    530          #endif
    531          
    532          	log_data[0] = OP_TYPE_ADD_NODE;
    533          	log_data[1] = 0;
    534          	log_data[2] = rec_offset;
    535          
    536          
    537          	if (save_log_file((void*)log_data,12))		//状态0，LOG文件中只保存了操作类型、记录类型、目标记录偏移
    538          	{
    539          		err_code = -10;
    540          		goto err_handle;
    541          	}
    542          
    543          	//计算此记录需要计算的关键字的hash值
    544          	i = 0;
    545          	while (p_hash_table_file[i])
    546          	{
    547          		strcpy((char*)dir_str,batch_dirctory);
    548          		strcat((char*)dir_str,(char const*)p_hash_table_file[i]);
    549          
    550          		//打开相应的hash_table文件
    551          		if (f_open(&file2,(const char*)dir_str,FA_OPEN_EXISTING | FA_READ | FA_WRITE) != FR_OK)
    552          		{
    553          			err_code = -4;
    554          			goto err_handle;
    555          		}
    556          
    557          		f_lseek(&file2,4*(hash_value[i]%HASH_TABLE_SIZE));		//定位到该hash值在hash表中对应的偏移处
    558          
    559          		//读取此hash值对应的链表的尾地址
    560          		if (f_read(&file2,(void*)&link_end,4,&tmp) != FR_OK)
    561          		{
    562          			err_code = -5;
    563          			goto err_handle;
    564          		}
    565          #ifdef REC_DEBUG
    566          		debug_out(" LinkEnd=",strlen(" LinkEnd="),1);
    567          		debug_out((unsigned char*)&link_end,4,0);
    568          #endif
    569          		log_data[0] = hash_value[i];
    570          		log_data[1] = link_end;
    571          		if(save_log_file((void*)log_data,8))		//状态1或者状态2
    572          		{
    573          			err_code = -10;
    574          			goto err_handle;
    575          		}
    576          		
    577          		f_lseek(&file2,4*(hash_value[i]%HASH_TABLE_SIZE));		//定位到该hash值在hash表中对应的偏移处
    578          
    579          		//更新该链表的尾节点
    580          		if (f_write(&file2,(void*)&rec_offset,4,&tmp) != FR_OK)
    581          		{
    582          			err_code = -6;
    583          			goto err_handle;
    584          		}
    585          
    586          		if (tmp != 4)
    587          		{
    588          			err_code = -6;
    589          			goto err_handle;
    590          		}
    591          
    592          		f_sync(&file2);
    593          
    594          		if (i == 1)
    595          		{
    596          			f_lseek(&file2,4);
    597          			if (f_read(&file2,(void*)&temp,4,&tmp) != FR_OK)
    598          			{
    599          				err_code = -7;
    600          				goto err_handle;
    601          			}
    602          
    603          			if (temp == 0)
    604          			{
    605          				//如果链表的首节点还是0，那么需要更新链表的首节点
    606          				f_lseek(&file2,4);
    607          				if (f_write(&file2,(void*)&rec_offset,4,&tmp) != FR_OK)
    608          				{
    609          					err_code = -8;
    610          					goto err_handle;
    611          				}
    612          
    613          				if (tmp != 4)
    614          				{
    615          					err_code = -8;
    616          					goto err_handle;
    617          				}
    618          			}
    619          		}
    620          
    621          		f_close(&file2);	//hash表文件可以关闭了
    622          
    623          		if (link_end)
    624          		{
    625          			//如果链表不是空的，那么需要更新链表的信息(如果是商品信息节点，还需要更新当前节点的信息，因为商品信息链表是双向链表)
    626          			if (update_link_info_after_addNode(&file1,(i+1),precord,link_end,rec_offset))
    627          			{
    628          				err_code = -9;
    629          				goto err_handle;
    630          			}
    631          		}
    632          
    633          		i++;
    634          	}
    635          
    636          	calc_check_value(precord);
    637          
    638          	if (save_log_file((void*)precord,node_size))
    639          	{
    640          		err_code = -8;
    641          		goto err_handle;
    642          	}
    643          
    644          	f_lseek(&file1,(rec_offset-1)*node_size);		//将文件指针移到文件末尾
    645          	if (f_write(&file1,precord,node_size,&tmp) != FR_OK)
    646          	{
    647          		err_code = -3;	 
    648          		goto err_handle;
    649          	}
    650          
    651          	if (tmp != node_size)
    652          	{
    653          		err_code = -3;	 
    654          		goto err_handle;
    655          	}
    656          
    657          	//保存节点的文件可以关闭了
    658          	f_close(&file1);	
    659          
    660          	if (invalid_node_offset)
    661          	{
    662          		if (f_open(&file1,(char const*)inf_file_str,FA_OPEN_EXISTING | FA_WRITE | FA_READ) != FR_OK)
    663          		{
    664          			return -2;
    665          		}
    666          
    667          		f_lseek(&file1,file1.fsize-4);
    668          		f_truncate(&file1);		//将记录在信息文件中的已经删除的节点偏移清掉。
    669          		f_close(&file1);
    670          	}
    671          	
    672          	clear_log_file(0);
    673          	return 0;
    674          
    675          err_handle:
    676          
    677          	f_close(&file1);
    678          	return err_code;
    679          }
    680          
    681          
    682          /**
    683          * @brief 得到脱机记录总条数
    684          * @return 0...LOGIC_RECORD_BLOCK_SIZE
    685          */
    686          int record_module_count(void)
    687          {
    688          	unsigned char dir_str[35];
    689          	unsigned char inf_file_str[35];
    690          	int		cnt;
    691          
    692          	strcpy((char*)dir_str,batch_dirctory);
    693          	strcat((char*)dir_str,(char const*)batch_list_file);
    694          
    695          	if (f_open(&file1,(const char*)dir_str,FA_OPEN_ALWAYS | FA_READ) != FR_OK)
    696          	{
    697          		return -1;
    698          	}
    699          
    700          	cnt = file1.fsize / sizeof(TBATCH_NODE);
    701          	f_close(&file1);
    702          
    703          	strcpy((char*)inf_file_str,batch_dirctory);
    704          	strcat((char*)inf_file_str,(char const*)batch_inf_file);
    705          
    706          	if (f_open(&file1,(char const*)inf_file_str,FA_OPEN_EXISTING | FA_READ) != FR_OK)
    707          	{
    708          		return -1;
    709          	}
    710          
    711          	if (cnt >= (file1.fsize - 12)/4)
    712          	{
    713          		cnt -= (file1.fsize - 12)/4;		//减去无效的节点，理论上无效的节点的偏移都记录在信息文件中，所以直接减去在信息文件中记录的无效节点个数，即表示在节点文件中还存在的节点个数。
    714          		f_close(&file1);
    715          	}
    716          	else
    717          	{
    718          		//理论上应该不会出现这种情况！万一真出现了呢？尼玛，那只能来杀手锏了，直接将记录文件全部初始化
    719          		f_close(&file1);
    720          		record_clear();
    721          		cnt = 0;
    722          	}
    723          
    724          	return cnt;
    725          }
    726          
    727          /**
    728          * @brief 清除脱机记录
    729          * @return 0：成功  -1：失败
    730          */
    731          int record_clear(void)
    732          {
    733          	unsigned char	dir_str[35];
    734          	const unsigned char	*p_hash_table_file[3];
    735          	int i;
    736          	unsigned int		log_data[2];
    737          
    738          	strcpy((char*)dir_str,batch_dirctory);
    739          	strcat((char*)dir_str,(char const*)batch_list_file);
    740          	p_hash_table_file[0] = barcode_hash_table_file;
    741          	p_hash_table_file[1] = batch_inf_file;
    742          	p_hash_table_file[2] = 0;
    743          
    744          
    745          	if (f_open(&file1,(const char*)dir_str,FA_OPEN_ALWAYS | FA_READ | FA_WRITE) != FR_OK)
    746          	{
    747          		return -1;
    748          	}
    749          
    750          	f_lseek(&file1,0);		//文件指针移动到文件开始
    751          
    752          	//将文件截断到文件开始
    753          	if (f_truncate(&file1) != FR_OK)
    754          	{
    755          		f_close(&file1);
    756          		return -2;
    757          	}
    758          
    759          	f_close(&file1);
    760          
    761          
    762          
    763          	log_data[0] = OP_TYPE_CLEAR_NODE;
    764          	log_data[1] = 0;
    765          	log_len = 0;
    766          	if (save_log_file((void*)log_data,8))		//状态0，LOG文件中只保存了操作类型、记录类型
    767          	{
    768          		return -4;
    769          	}
    770          
    771          	i = 0;
    772          	while (p_hash_table_file[i])
    773          	{
    774          		strcpy((char*)dir_str,batch_dirctory);
    775          		strcat((char*)dir_str,(char const*)p_hash_table_file[i]);
    776          
    777          		//打开相应的hash_table文件
    778          		if (f_open(&file2,(const char*)dir_str,FA_OPEN_EXISTING | FA_READ | FA_WRITE) != FR_OK)
    779          		{
    780          			return -3;
    781          		}
    782          
    783          		if (i == 0)
    784          		{
    785          			init_hash_table_file(&file2);	
    786          		}
    787          		else if(i == 1)
    788          		{
    789          			init_data_info_file(&file2);	
    790          		}
    791          		f_close(&file2);
    792                  i++;
    793          	}
    794          
    795          	clear_log_file(0);		//清除日志
    796          	return 0;
    797          }
    798          
    799          /**
    800          * @brief 根据条码关键字查询脱机记录，返回记录节点的偏移
    801          * @param[in] unsigned char *barcode				要匹配的字符串
    802          * @param[out] unsigned char *outbuf				搜索到的记录缓冲区
    803          * @return 搜索结果	=0:没有搜索到该交易记录  > 0:搜索到的记录的偏移   < 0: 错误类型
    804          * @note  
    805          */
    806          static int rec_search(unsigned char *barcode,unsigned char *outbuf)
    807          {
    808          	unsigned int hash_value,link_end,tmp;
    809          	unsigned char dir_str[35];
    810          	unsigned char	buffer[RECORD_MAX_SIZE];		//如果一个节点的大小超过了512，那么还需要增加此临时空间
    811          	unsigned int	node_size;				//节点大小
    812          
    813          	node_size = sizeof(TBATCH_NODE);
    814          	memset(outbuf,0,node_size);		//清掉返回数据的缓冲区
    815          	strcpy((char*)dir_str,batch_dirctory);
    816          
    817          
    818          	//如果要搜索的关键字类型是条码
    819          
    820          	//step1: 计算关键字的hash值
    821          	hash_value = HashString(barcode,0);	
    822          
    823          	//step2: 根据hash值查找到与该关键字具有相同hash值模值的链表尾地址
    824          	strcat((char*)dir_str,(char const*)barcode_hash_table_file);		
    825          	if (f_open(&file1,(char const*)dir_str,FA_OPEN_ALWAYS | FA_READ) != FR_OK)
    826          	{
    827          		return -1;
    828          	}
    829          
    830          	f_lseek(&file1,4*(hash_value%HASH_TABLE_SIZE));
    831          
    832          	if (f_read(&file1,(void*)&link_end,4,&tmp) != FR_OK)
    833          	{
    834          		return -2;
    835          	}	
    836          
    837          	f_close(&file1);
    838          
    839          	//根据读取出来的链表首地址查找到第一个与关键字完全匹配的记录，如果需要将完全匹配关键字的所有记录全部都读取出来，需要另外的接口来实现。
    840          
    841          	if (link_end)
    842          	{	
    843          		strcpy((char*)dir_str,batch_dirctory);
    844          		strcat((char*)dir_str,(char const*)batch_list_file);
    845          
    846          		if (f_open(&file1,(char const*)dir_str,FA_OPEN_ALWAYS | FA_READ) != FR_OK)
    847          		{
    848          			return -3;
    849          		}
    850          
    851          		while (link_end)
    852          		{
    853          			f_lseek(&file1,(link_end-1)*node_size);		//文件指针指向该节点的起始位置
    854          
    855          			if ((f_read(&file1,buffer,node_size,&tmp) != FR_OK) || (node_size != tmp))
    856          			{
    857          				return -4;
    858          			}
    859          
    860          			if (strcmp((char*)barcode,(char const*)((TBATCH_NODE*)buffer)->barcode) == 0)
    861          			{
    862          				memcpy(outbuf,buffer,node_size);
    863          				return link_end;		//搜索到链表中第一个与关键字匹配的节点
    864          			}
    865          
    866          			link_end = ((TBATCH_NODE*)buffer)->by_barcode_prev;
    867          		}
    868          	}
    869          
    870          	return 0;		//没有搜索到与关键字匹配的记录
    871          }
    872          
    873          /**
    874          * @brief 根据条码查询脱机记录，返回记录指针
    875          * @param[in] unsigned char *barcode				要匹配的字符串
    876          * @param[out] int	*index						返回该记录的索引值
    877          * @return 搜索结果	0 没有搜索到记录		else 记录指针
    878          * @note  实现的时候必须进行字符串比较
    879          */
    880          unsigned char *rec_searchby_tag(unsigned char *barcode, int *index)
    881          {
    882          	unsigned char *pBuf;
    883          
    884          	pBuf = rec_module_buffer;
    885          	*index = rec_search(barcode,pBuf);
    886          	if (*index > 0)
    887          	{
    888          		return pBuf;
    889          	}
    890          
    891          	return (unsigned char *)0;
    892          }
    893          /**
    894          * @brief 读取序列号节点
    895          * @param[in] unsigned int mode  0:第一个有效节点   1;前一个有效节点   2:后一个有效节点  3:指定节点偏移
    896          * @param[in] unsigned int offset  只有在mode = 3时才有用
    897          */
    898          unsigned char* get_node(unsigned int mode,unsigned int offset)
    899          {
    900          	unsigned int	node_offset,tmp;
    901          	unsigned char	*pRec = 0;
    902          	unsigned char   inf_file_str[35];
    903          	if (mode == 0)
    904          	{
    905          		current_node_offset = 0;
    906          		
    907          		strcpy((char*)inf_file_str,batch_dirctory);
    908          		strcat((char*)inf_file_str,(char const*)batch_inf_file);
    909          
    910          		if (f_open(&file1,(char const*)inf_file_str,FA_OPEN_EXISTING | FA_READ) != FR_OK)
    911          		{
    912          			return (unsigned char*)0;
    913          		}
    914          
    915          		f_lseek(&file1,8);
    916          		if ((f_read(&file1,(void*)&node_offset,4,&tmp) != FR_OK)||(tmp != 4))
    917          		{
    918          			f_close(&file1);
    919          			return (unsigned char*)0;
    920          		}
    921          
    922          		f_close(&file1);
    923          	}
    924          	else if (1 == mode)
    925          	{
    926          		node_offset = next_node_offset;
    927          	}
    928          	else if (2 == mode)
    929          	{
    930          		node_offset = prev_node_offset;
    931          	}
    932          	else if(3 == mode)
    933          	{
    934          		node_offset = offset;
    935          	}
    936          	else
    937          	{
    938          		return (unsigned char*)0;
    939          	}
    940          
    941          	if (node_offset)
    942          	{
    943          		current_node_offset = node_offset;
    944          
    945          		pRec = record_module_read(current_node_offset);
    946          		prev_node_offset = ((TBATCH_NODE*)pRec)->by_index_prev;
    947          		next_node_offset = ((TBATCH_NODE*)pRec)->by_index_next;
    948          	}
    949          
    950          	return pRec;
    951          }
    952          /**
    953          * @brief 删除脱机记录文件中的某一个节点
    954          * @param[in] unsigned int index	 物理偏移（索引）
    955          */
    956          int delete_one_node(unsigned int index)
    957          {
    958          	unsigned char	buffer[RECORD_MAX_SIZE];
    959          	unsigned int	tmp,temp;
    960          	unsigned short	prev,next;
    961          	unsigned int	barcode_hash_prev,barcode_hash_next;
    962          	unsigned int	hash_value;
    963          	unsigned char	inf_file_str[35];
    964          	unsigned int	node_size;
    965          	unsigned int	log_data[8];
    966          
    967          	//step1:先将该节点标记为无效节点
    968          	strcpy((char*)inf_file_str,batch_dirctory);
    969          	strcat((char*)inf_file_str,(char const*)batch_list_file);
    970          	node_size = sizeof(TBATCH_NODE);
    971          
    972          	if (f_open(&file1,(char const*)inf_file_str,FA_OPEN_EXISTING | FA_READ | FA_WRITE) != FR_OK)
    973          	{
    974          		return -2;
    975          	}
    976          
    977          	f_lseek(&file1,(index-1)*node_size);
    978          	if ((f_read(&file1,buffer,node_size,&tmp) != FR_OK)||(tmp != node_size))
    979          	{
    980          		f_close(&file1);
    981          		return -3;
    982          	}
    983          
    984          
    985          	((TBATCH_NODE*)buffer)->flag = 0x55;
    986          
    987          	prev = ((TBATCH_NODE*)buffer)->by_index_prev;
    988          	next = ((TBATCH_NODE*)buffer)->by_index_next;
    989          
    990          	barcode_hash_prev = ((TBATCH_NODE*)buffer)->by_barcode_prev;
    991          	barcode_hash_next = ((TBATCH_NODE*)buffer)->by_barcode_next;
    992          	hash_value = HashString(((TBATCH_NODE*)buffer)->barcode,0);
    993          
    994          	f_lseek(&file1,(index-1)*node_size);
    995          	if (f_write(&file1,buffer,node_size,&tmp) != FR_OK)
    996          	{
    997          		f_close(&file1);
    998          		return -4;
    999          	}
   1000          
   1001          	if (tmp != node_size)
   1002          	{
   1003          		f_close(&file1);
   1004          		return -5;
   1005          	}
   1006          
   1007          	f_sync(&file1);
   1008          
   1009          	log_data[0] = OP_TYPE_DEL_NODE;
   1010          	log_data[1] = 0;
   1011          	log_data[2] = index;
   1012          	log_data[3] = prev;
   1013          	log_data[4] = next;
   1014          	log_data[5] = barcode_hash_prev;
   1015          	log_data[6] = barcode_hash_next;
   1016          	log_data[7] = hash_value;
   1017          	log_len = 0;
   1018          	if (save_log_file((void*)log_data,32))
   1019          	{
   1020          		return -6;
   1021          	}
   1022          
   1023          	//step2:更新该节点前一个节点和后一个节点的链表信息
   1024          	if(prev)
   1025          	{
   1026          		f_lseek(&file1,(prev-1)*node_size);
   1027          		if ((f_read(&file1,buffer,node_size,&tmp) != FR_OK)||(tmp != node_size))
   1028          		{
   1029          			f_close(&file1);
   1030          			return -7;
   1031          		}
   1032          
   1033          
   1034          		((TBATCH_NODE*)buffer)->by_index_next = next;
   1035          
   1036          		calc_check_value(buffer);
   1037          
   1038          		f_lseek(&file1,(prev-1)*node_size);
   1039          		if (f_write(&file1,buffer,node_size,&tmp) != FR_OK)
   1040          		{
   1041          			f_close(&file1);
   1042          			return -8;
   1043          		}
   1044          
   1045          		if (tmp != node_size)
   1046          		{
   1047          			f_close(&file1);
   1048          			return -9;
   1049          		}
   1050          
   1051          		f_sync(&file1);
   1052          	}
   1053          
   1054          	if (next)
   1055          	{
   1056          		f_lseek(&file1,(next-1)*node_size);
   1057          		if ((f_read(&file1,buffer,node_size,&tmp) != FR_OK)||(tmp != node_size))
   1058          		{
   1059          			f_close(&file1);
   1060          			return -10;
   1061          		}
   1062          
   1063          
   1064          		((TBATCH_NODE*)buffer)->by_index_prev = prev;
   1065          
   1066          		calc_check_value(buffer);
   1067          		f_lseek(&file1,(next-1)*node_size);
   1068          		if (f_write(&file1,buffer,node_size,&tmp) != FR_OK)
   1069          		{
   1070          			f_close(&file1);
   1071          			return -11;
   1072          		}
   1073          
   1074          		if (tmp != node_size)
   1075          		{
   1076          			f_close(&file1);
   1077          			return -12;
   1078          		}
   1079          
   1080          		f_sync(&file1);
   1081          	}
   1082          
   1083          	if(barcode_hash_prev)
   1084          	{
   1085          		f_lseek(&file1,(barcode_hash_prev-1)*node_size);
   1086          		if ((f_read(&file1,buffer,node_size,&tmp) != FR_OK)||(tmp != node_size))
   1087          		{
   1088          			f_close(&file1);
   1089          			return -7;
   1090          		}
   1091          
   1092          
   1093          		((TBATCH_NODE*)buffer)->by_barcode_next = barcode_hash_next;
   1094          
   1095          		calc_check_value(buffer);
   1096          
   1097          		f_lseek(&file1,(barcode_hash_prev-1)*node_size);
   1098          		if (f_write(&file1,buffer,node_size,&tmp) != FR_OK)
   1099          		{
   1100          			f_close(&file1);
   1101          			return -8;
   1102          		}
   1103          
   1104          		if (tmp != node_size)
   1105          		{
   1106          			f_close(&file1);
   1107          			return -9;
   1108          		}
   1109          
   1110          		f_sync(&file1);
   1111          	}
   1112          
   1113          	if (barcode_hash_next)
   1114          	{
   1115          		f_lseek(&file1,(barcode_hash_next-1)*node_size);
   1116          		if ((f_read(&file1,buffer,node_size,&tmp) != FR_OK)||(tmp != node_size))
   1117          		{
   1118          			f_close(&file1);
   1119          			return -10;
   1120          		}
   1121          
   1122          
   1123          		((TBATCH_NODE*)buffer)->by_barcode_prev = barcode_hash_prev;
   1124          
   1125          		calc_check_value(buffer);
   1126          		f_lseek(&file1,(barcode_hash_next-1)*node_size);
   1127          		if (f_write(&file1,buffer,node_size,&tmp) != FR_OK)
   1128          		{
   1129          			f_close(&file1);
   1130          			return -11;
   1131          		}
   1132          
   1133          		if (tmp != node_size)
   1134          		{
   1135          			f_close(&file1);
   1136          			return -12;
   1137          		}
   1138          
   1139          		f_sync(&file1);
   1140          	}
   1141          
   1142          	//可以将节点文件关闭了
   1143          	f_close(&file1);
   1144          
   1145          	//step3:将删除的节点的偏移记录在信息文件中
   1146          
   1147          	strcpy((char*)inf_file_str,batch_dirctory);
   1148          	strcat((char*)inf_file_str,(char const*)batch_inf_file);
   1149          
   1150          	if (f_open(&file1,(char const*)inf_file_str,FA_OPEN_EXISTING | FA_READ | FA_WRITE) != FR_OK)
   1151          	{
   1152          		return -19;
   1153          	}
   1154          
   1155          	f_lseek(&file1,file1.fsize);
   1156          	if (f_write(&file1,(void*)&index,4,&tmp) != FR_OK)
   1157          	{
   1158          		f_close(&file1);
   1159          		return -20;
   1160          	}
   1161          
   1162          	if (tmp != 4)
   1163          	{
   1164          		f_close(&file1);
   1165          		return -21;
   1166          	}
   1167          
   1168          	f_sync(&file1);
   1169          
   1170          	//如果删除的节点是链表的首节点，那么还需要更新保存的链表首节点信息
   1171          	f_lseek(&file1,4);
   1172          	if ((f_read(&file1,(void*)&temp,4,&tmp) != FR_OK)||(tmp != 4))
   1173          	{
   1174          		f_close(&file1);
   1175          		return -22;
   1176          	}
   1177          
   1178          	if (temp == index)
   1179          	{
   1180          		f_lseek(&file1,4);
   1181          		temp = next;
   1182          		if (f_write(&file1,(void*)&temp,4,&tmp) != FR_OK)
   1183          		{
   1184          			f_close(&file1);
   1185          			return -23;
   1186          		}
   1187          
   1188          		if (tmp != 4)
   1189          		{
   1190          			f_close(&file1);
   1191          			return -24;
   1192          		}
   1193          
   1194          		f_sync(&file1);
   1195          	}
   1196          
   1197          	//如果删除的节点是链表的尾节点，那么还需要更新保存的链表尾节点信息
   1198          	f_lseek(&file1,8);
   1199          	if ((f_read(&file1,(void*)&temp,4,&tmp) != FR_OK)||(tmp != 4))
   1200          	{
   1201          		f_close(&file1);
   1202          		return -25;
   1203          	}
   1204          
   1205          	if (temp == index)
   1206          	{
   1207          		f_lseek(&file1,8);
   1208          		temp = prev;
   1209          		if (f_write(&file1,(void*)&temp,4,&tmp) != FR_OK)
   1210          		{
   1211          			f_close(&file1);
   1212          			return -26;
   1213          		}
   1214          
   1215          		if (tmp != 4)
   1216          		{
   1217          			f_close(&file1);
   1218          			return -27;
   1219          		}
   1220          	}
   1221          
   1222          	f_close(&file1);
   1223          
   1224          	strcpy((char*)inf_file_str,batch_dirctory);
   1225          	strcat((char*)inf_file_str,(char const*)barcode_hash_table_file);
   1226          
   1227          	if (f_open(&file1,(char const*)inf_file_str,FA_OPEN_EXISTING | FA_READ | FA_WRITE) != FR_OK)
   1228          	{
   1229          		return -28;
   1230          	}
   1231          
   1232          	f_lseek(&file1,4*(hash_value%HASH_TABLE_SIZE));
   1233          
   1234          	//获取链表的尾地址
   1235          	if (f_read(&file1,(void*)&temp,4,&tmp) != FR_OK)
   1236          	{
   1237          		f_close(&file1);
   1238          		return -29;
   1239          	}
   1240          
   1241          	if (temp == index)
   1242          	{
   1243          		f_lseek(&file1,4*(hash_value%HASH_TABLE_SIZE));
   1244          
   1245          		if (f_write(&file1,(void*)barcode_hash_prev,4,&tmp) != FR_OK)
   1246          		{
   1247          			f_close(&file1);
   1248          			return -30;
   1249          		}
   1250          	}
   1251          
   1252          	f_close(&file1);
   1253          
   1254          	clear_log_file(0);		//清除日志
   1255          
   1256          	return 0;
   1257          }
   1258          
   1259          /**
   1260          * @brief 获取某一个文件的大小
   1261          * @param[in] const unsigned char *dir		文件的路径
   1262          */
   1263          int get_file_size(const unsigned char *dir)
   1264          {
   1265          	int size;
   1266          	if (f_open(&file1,(char const*)dir,FA_OPEN_EXISTING | FA_READ) != FR_OK)
   1267          	{
   1268          		return 0;
   1269          	}
   1270          
   1271          	size = file1.fsize;
   1272          
   1273          	f_close(&file1);
   1274          
   1275          	return size;
   1276          }
   1277          
   1278          /**
   1279          * @brief 读取记录文件夹中的某一个文件
   1280          * @param[in] const unsigned char *dir		文件的路径
   1281          * @param[in] unsigned int	 offset			文件偏移
   1282          * @param[in] unsigned int	 len			数据长度
   1283          * @param[in] unsigned char *pdata			数据指针
   1284          * @return  < 0		读取文件失败
   1285          *          >= 0		读取成功,返回读取数据的实际长度
   1286          */
   1287          int read_rec_file(const unsigned char *dir,unsigned int offset,unsigned int len,unsigned char *pdata)
   1288          {
   1289          	unsigned int	tmp;
   1290          
   1291          	if (f_open(&file1,(char const*)dir,FA_OPEN_EXISTING | FA_READ) != FR_OK)
   1292          	{
   1293          		return -1;
   1294          	}
   1295          
   1296          	if(file1.fsize < offset)
   1297          	{
   1298          		f_close(&file1);
   1299          		return -2;
   1300          	}
   1301          
   1302          	f_lseek(&file1,offset);
   1303          	if (f_read(&file1,pdata,len,&tmp) != FR_OK)
   1304          	{
   1305          		f_close(&file1);
   1306          		return -3;
   1307          	}
   1308          
   1309          	f_close(&file1);
   1310          	return tmp;
   1311          }
   1312          
   1313          /**
   1314          * @brief 往记录文件夹中的某一个文件写入数据
   1315          * @param[in] const unsigned char *dir		文件的路径
   1316          * @param[in] unsigned int	 offset			文件偏移
   1317          * @param[in] unsigned int	 len			数据长度
   1318          * @param[in] unsigned char *pdata			数据指针
   1319          * @return  < 0		写入文件失败
   1320          *          >= 0		写入成功,返回写入数据的实际长度
   1321          */
   1322          int write_rec_file(const unsigned char *dir,unsigned int offset,unsigned int len,unsigned char *pdata)
   1323          {
   1324          	unsigned int	tmp;
   1325          
   1326          	if (f_open(&file1,(char const*)dir,FA_OPEN_ALWAYS | FA_READ | FA_WRITE) != FR_OK)
   1327          	{
   1328          		return -1;
   1329          	}
   1330          
   1331          	if(file1.fsize < offset)
   1332          	{
   1333          		f_close(&file1);
   1334          		return -2;
   1335          	}
   1336          
   1337          	f_lseek(&file1,offset);
   1338          	if (f_write(&file1,pdata,len,&tmp) != FR_OK)
   1339          	{
   1340          		f_close(&file1);
   1341          		return -3;
   1342          	}
   1343          
   1344          	if (tmp != len)
   1345          	{
   1346          		f_close(&file1);
   1347          		return -3;
   1348          	}
   1349          
   1350          	f_close(&file1);
   1351          	return tmp;
   1352          }
   1353          
   1354          /**
   1355          * @brief 检查记录的文件夹中的记录文件是否完整或者合法
   1356          */
   1357          int check_record_dir(void)
   1358          {
   1359          	const unsigned char	*p_rec_file[4];
   1360          	const unsigned char *p_rec_dir;
   1361          	unsigned char dir_str[35];
   1362          	unsigned int	i;
   1363          	int				ret = 0;
   1364          
   1365          	p_rec_dir = batch_dirctory;
   1366          
   1367          	p_rec_file[0] = barcode_hash_table_file;
   1368          	p_rec_file[1] = batch_inf_file;
   1369          	p_rec_file[2] = batch_list_file;
   1370          	p_rec_file[3] = 0;
   1371          
   1372          
   1373          	i = 0;
   1374          	while(p_rec_file[i])
   1375          	{
   1376          		strcpy((char*)dir_str,(char const*)p_rec_dir);
   1377          		strcat((char*)dir_str,(char const*)p_rec_file[i]);
   1378          
   1379          		if (f_open(&file1,(char const*)dir_str,FA_OPEN_EXISTING | FA_READ) != FR_OK)
   1380          		{
   1381          			//记录文件不存在
   1382          			return -2;
   1383          		}
   1384          
   1385          
   1386          		if (i==0)
   1387          		{
   1388          			if (file1.fsize != 4*HASH_TABLE_SIZE)
   1389          			{
   1390          				ret = -3;		//hash表文件大小错误
   1391          			}
   1392          		}
   1393          		else if(i == 1)
   1394          		{
   1395          			if (file1.fsize < 12 || file1.fsize > 12 + 4*BATCH_LIST_MAX_CNT)
   1396          			{
   1397          				ret = -4;
   1398          			}
   1399          		}
   1400          		else if(i == 2)
   1401          		{
   1402          			if ((file1.fsize % sizeof(TBATCH_NODE)) != 0)
   1403          			{
   1404          				ret = -5;		//商品信息记录文件不能被节点大小整除
   1405          			}
   1406          		}
   1407          
   1408          		f_close(&file1);
   1409          
   1410          		if (ret)
   1411          		{
   1412          			return ret;
   1413          		}
   1414          		i++;
   1415          	}
   1416          
   1417          	//上面检查完了记录文件夹中记录文件的存在以及每个记录文件的大小是否正确
   1418          	//还需要检查记录文件与各hash文件之间的关联性是否正确，以及记录文件内部链表的建立是否正确。
   1419          	//@todo.....
   1420          
   1421          	return 0;
   1422          }
   1423          
   1424          
   1425          /**
   1426          ***************************************************************************
   1427          *@brief	校验下载的升级文件是否正确
   1428          *@param[in] 
   1429          *@return 
   1430          *@warning
   1431          *@see	
   1432          *@note 
   1433          ***************************************************************************
   1434          */
   1435          int check_updatefile(void)
   1436          {
   1437          	UINT							rd;
   1438          	int								i;
   1439          	int								j;
   1440          	unsigned int					code_sector,code_xor,xor;
   1441          
   1442          	if( f_open(&file1, "/update.bin", FA_OPEN_EXISTING | FA_READ ) != FR_OK )
   1443          	{
   1444          		return -1;
   1445          	}
   1446          
   1447          	if( f_read(&file1, rec_module_buffer, 512, &rd) != FR_OK )
   1448          	{
   1449          		f_close(&file1);
   1450          		return -1;
   1451          	}
   1452          
   1453          	if( rec_module_buffer[0] != 'J' || rec_module_buffer[1] != 'B' || rec_module_buffer[2] != 'L' )
   1454          	{
   1455          		f_close(&file1);
   1456          		return -1;
   1457          	}
   1458          
   1459          	code_sector						= ((TPackHeader*)rec_module_buffer)->length;
   1460          	code_xor						= ((TPackHeader*)rec_module_buffer)->xor_data;
   1461          
   1462          	code_sector						/= 512;
   1463          	xor								= 0;
   1464          	for(i=0; i<code_sector; i++)
   1465          	{
   1466          		if( f_read(&file1, rec_module_buffer, 512, &rd) != FR_OK )
   1467          		{
   1468          			f_close(&file1);
   1469          			return -1;
   1470          		}
   1471          
   1472          		for(j=0; j<128; j++)
   1473          		{
   1474          			xor						^= *((unsigned int*)&rec_module_buffer[j*4]);
   1475          		}
   1476          	}
   1477          
   1478          	f_close(&file1);
   1479          
   1480          	if(xor != code_xor)
   1481          	{
   1482          		return -1;
   1483          	}
   1484          
   1485          	return 0;
   1486          }
   1487          
   1488          
   1489          /**
   1490          ***************************************************************************
   1491          *@brief 判断是否有应用升级文件的存在，如果有升级文件存在就删除应用升级文件
   1492          *@param[in] 
   1493          *@return 0 删除成功  else; 删除失败
   1494          *@warning
   1495          *@see	
   1496          *@note 
   1497          ***************************************************************************
   1498          */
   1499          int del_update_bin(void)
   1500          {
   1501          	if( f_open(&file1, "/update.bin", FA_OPEN_EXISTING | FA_READ ) != FR_OK )
   1502          	{
   1503          		return 0;
   1504          	}
   1505          
   1506          	f_close(&file1);
   1507          
   1508          	//应用升级文件存在，将升级文件删除
   1509          	if (f_unlink("/update.bin") != FR_OK)
   1510          	{
   1511          		return -1;	//删除旧的资源文件失败
   1512          	}
   1513          
   1514          	return 0;
   1515          }
   1516          
   1517          /**
   1518          * @brief ]恢复hash表的修改，包括恢复相应的节点文件的修改
   1519          * @param[in]
   1520          * @return 0:成功
   1521          *        -1:失败
   1522          */
   1523          static int recover_hash_table_modify(unsigned char hash_type,unsigned int hash_value,unsigned int linkend)
   1524          {
   1525          		unsigned char	dir_str[35],node_size;
   1526          		unsigned int	tmp;
   1527          		unsigned char   buffer[RECORD_MAX_SIZE];
   1528          
   1529          		if (hash_type == 0)
   1530          		{
   1531          			strcpy((char*)dir_str,batch_dirctory);
   1532          			strcat((char*)dir_str,(char const*)barcode_hash_table_file);
   1533          		}
   1534          		else if (hash_type == 1)
   1535          		{
   1536          			strcpy((char*)dir_str,batch_dirctory);
   1537          			strcat((char*)dir_str,(char const*)batch_inf_file);
   1538          		}
   1539          
   1540          		//打开HashTable文件
   1541          		if (f_open(&file2,(char const*)dir_str,FA_OPEN_EXISTING | FA_WRITE | FA_READ) != FR_OK)
   1542          		{
   1543          			return -3;
   1544          		}
   1545          
   1546          		f_lseek(&file2,4*(hash_value%HASH_TABLE_SIZE));
   1547          
   1548          		if (f_write(&file2,(void*)&linkend,4,&tmp) != FR_OK)
   1549          		{
   1550          			f_close(&file2);
   1551          			return -4;
   1552          		}
   1553          
   1554          		if (tmp != 4)
   1555          		{
   1556          			f_close(&file2);
   1557          			return -4;
   1558          		}
   1559          
   1560          		f_close(&file2);
   1561          
   1562          		if(linkend)
   1563          		{
   1564          			strcpy((char*)dir_str,batch_dirctory);
   1565          			strcat((char*)dir_str,batch_list_file);
   1566          			node_size = sizeof(TBATCH_NODE);
   1567          			
   1568          
   1569          			if (f_open(&file1,(char const*)dir_str,FA_OPEN_EXISTING | FA_WRITE | FA_READ) != FR_OK)
   1570          			{
   1571          				return -3;
   1572          			}
   1573          
   1574          			if(file1.fsize == 0)
   1575          			{
   1576          				f_close(&file1);
   1577          				return 0;
   1578          			}
   1579          
   1580          			f_lseek(&file1,(linkend-1)*node_size);
   1581          
   1582          			if ((f_read(&file1,buffer,node_size,&tmp) != FR_OK)||(tmp != node_size))
   1583          			{
   1584          				f_close(&file1);
   1585          				return -4;
   1586          			}
   1587          
   1588          
   1589          			if (hash_type == 0)
   1590          			{
   1591          				if (((TBATCH_NODE*)buffer)->by_barcode_next)
   1592          				{
   1593          					((TBATCH_NODE*)buffer)->by_barcode_next = 0;
   1594          				}
   1595          			}
   1596          			else if (hash_type == 1)
   1597          			{
   1598          				if (((TBATCH_NODE*)buffer)->by_index_next)
   1599          				{
   1600          					((TBATCH_NODE*)buffer)->by_index_next = 0;
   1601          				}
   1602          			}
   1603          			
   1604          
   1605          			calc_check_value(buffer);
   1606          
   1607          			f_lseek(&file1,(linkend-1)*node_size);
   1608          			if (f_write(&file1,buffer,node_size,&tmp) != FR_OK)
   1609          			{
   1610          				f_close(&file1);
   1611          				return -5;
   1612          			}
   1613          
   1614          			if (tmp != node_size)
   1615          			{
   1616          				f_close(&file1);
   1617          				return -5;
   1618          			}
   1619          
   1620          			f_close(&file1);
   1621          		}
   1622          
   1623          		return 0;
   1624          }
   1625          
   1626          
   1627          
   1628          /**
   1629          * @brief 增加记录操作的恢复
   1630          * @param[in] 
   1631          * @return 0:成功
   1632          *        -1:失败
   1633          */
   1634          static int record_add_recover(unsigned int rec_offset,unsigned char *log_data,unsigned int log_data_len)
   1635          {
   1636          	unsigned char	dir_str[35];
   1637          	unsigned int	tmp;
   1638          	unsigned int	hash_value,linkend;
   1639          	if (log_data_len < 8)
   1640          	{
   1641          		return -1;
   1642          	}
   1643          
   1644          	if (log_data_len == 8)
   1645          	{
   1646          		//只是记录了Barcode HashValue和相应链表的尾节点，那么Hashtable和节点文件都有可能已经改变了，将已经改变的恢复为原来的状况
   1647          		hash_value = *((unsigned int*)(log_data)); 
   1648          		linkend = *((unsigned int*)(log_data+4));
   1649          		if (recover_hash_table_modify(0,hash_value,linkend))
   1650          		{
   1651          			return -2;
   1652          		}
   1653          		return 0;
   1654          	}
   1655          	else
   1656          	{
   1657          		if (log_data_len == 16)
   1658          		{
   1659          			//恢复为原来的状况
   1660          			hash_value = *((unsigned int*)(log_data)); 
   1661          			linkend = *((unsigned int*)(log_data+4));
   1662          			if (recover_hash_table_modify(0,hash_value,linkend))
   1663          			{
   1664          				return -2;
   1665          			}
   1666          
   1667          			hash_value = *((unsigned int*)(log_data+8)); 
   1668          			linkend = *((unsigned int*)(log_data+12));
   1669          			if (recover_hash_table_modify(1,hash_value,linkend))
   1670          			{
   1671          				return -3;
   1672          			}
   1673          
   1674          			return 0;
   1675          		}
   1676          		else
   1677          		{
   1678          			if (log_data_len == 16+sizeof(TBATCH_NODE))
   1679          			{
   1680          				//可能已经写入了节点数据
   1681          				strcpy((char*)dir_str,batch_dirctory);
   1682          				strcat((char*)dir_str,batch_list_file);
   1683          				if (f_open(&file1,(char const*)dir_str,FA_OPEN_EXISTING | FA_READ | FA_WRITE) != FR_OK)
   1684          				{
   1685          					return -4;
   1686          				}
   1687          
   1688          				if (file1.fsize != rec_offset*sizeof(TBATCH_NODE))
   1689          				{
   1690          					//说明实际上没有写入节点
   1691          					f_lseek(&file1,file1.fsize);
   1692          					if (f_write(&file1,(void*)(log_data+16),sizeof(TBATCH_NODE),&tmp) != FR_OK)
   1693          					{
   1694          						f_close(&file1);
   1695          						return -5;
   1696          					}
   1697          
   1698          					if (tmp != sizeof(TBATCH_NODE))
   1699          					{	
   1700          						f_close(&file1);
   1701          						return -5;
   1702          					}
   1703          				}
   1704          				f_close(&file1);
   1705          				return 0;
   1706          			}
   1707          			else
   1708          			{	
   1709          				return -2;			//日志数据长度错误
   1710          			}
   1711          		}
   1712          	}
   1713          }
   1714          
   1715          
   1716          
   1717          /**
   1718          * @brief 恢复被中断的清除所有记录操作
   1719          * @return 0：成功  -1：失败
   1720          */
   1721          int record_clear_recover(void)
   1722          {
   1723          	unsigned char dir_str[35];
   1724          	const unsigned char	*p_hash_table_file[3];
   1725          	int i;
   1726          
   1727          
   1728          	p_hash_table_file[0] = barcode_hash_table_file;
   1729          	p_hash_table_file[1] = batch_inf_file;
   1730          	p_hash_table_file[2] = 0;
   1731          
   1732          
   1733          	i = 0;
   1734          	while (p_hash_table_file[i])
   1735          	{
   1736          		strcpy((char*)dir_str,batch_dirctory);
   1737          		strcat((char*)dir_str,(char const*)p_hash_table_file[i]);
   1738          
   1739          		//打开相应的hash_table文件
   1740          		if (f_open(&file2,(const char*)dir_str,FA_OPEN_EXISTING | FA_READ | FA_WRITE) != FR_OK)
   1741          		{
   1742          			return -3;
   1743          		}
   1744          		if (i == 1)
   1745          		{
   1746          			init_data_info_file(&file2);	
   1747          		}
   1748          		else
   1749          		{
   1750          			init_hash_table_file(&file2);	
   1751          		}
   1752          		
   1753          
   1754          		f_close(&file2);
   1755          		i++;
   1756          	}
   1757          	return 0;
   1758          }
   1759          
   1760          /**
   1761          * @brief 恢复被中断的删除某一个节点的操作
   1762          * @return 0：成功  -1：失败
   1763          */
   1764          static int del_one_node_recover(unsigned int index,unsigned int logical_prev,unsigned int logical_next,unsigned int barcode_hash_prev,unsigned int barcode_hash_next,unsigned int hash_value)
   1765          {
   1766          	unsigned char	buffer[RECORD_MAX_SIZE];
   1767          	unsigned int	tmp,link_end;
   1768          	unsigned char	inf_file_str[35];
   1769          	unsigned int	node_size;
   1770          
   1771          	strcpy((char*)inf_file_str,batch_dirctory);
   1772          	strcat((char*)inf_file_str,batch_list_file);
   1773          	node_size = sizeof(TBATCH_NODE);
   1774          
   1775          	//step2:更新该节点前一个节点和后一个节点的链表信息
   1776          	if (f_open(&file1,(char const*)inf_file_str,FA_OPEN_EXISTING | FA_READ | FA_WRITE) != FR_OK)
   1777          	{
   1778          		return -2;
   1779          	}
   1780          
   1781          	if(logical_prev)
   1782          	{
   1783          		f_lseek(&file1,(logical_prev-1)*node_size);
   1784          		if ((f_read(&file1,buffer,node_size,&tmp) != FR_OK)||(tmp != node_size))
   1785          		{
   1786          			f_close(&file1);
   1787          			return -4;
   1788          		}
   1789          
   1790          	
   1791          		((TBATCH_NODE*)buffer)->by_index_next = logical_next;
   1792          
   1793          		calc_check_value(buffer);
   1794          
   1795          		f_lseek(&file1,(logical_prev-1)*node_size);
   1796          		if (f_write(&file1,buffer,node_size,&tmp) != FR_OK)
   1797          		{
   1798          			f_close(&file1);
   1799          			return -5;
   1800          		}
   1801          
   1802          		if (tmp != node_size)
   1803          		{
   1804          			f_close(&file1);
   1805          			return -5;
   1806          		}
   1807          	}
   1808          
   1809          	if (logical_next)
   1810          	{
   1811          		f_lseek(&file1,(logical_next-1)*node_size);
   1812          		if ((f_read(&file1,buffer,node_size,&tmp) != FR_OK)||(tmp != node_size))
   1813          		{
   1814          			f_close(&file1);
   1815          			return -6;
   1816          		}
   1817          
   1818          	
   1819          		((TBATCH_NODE*)buffer)->by_index_prev = logical_prev;
   1820          		calc_check_value(buffer);
   1821          		f_lseek(&file1,(logical_next-1)*node_size);
   1822          		if (f_write(&file1,buffer,node_size,&tmp) != FR_OK)
   1823          		{
   1824          			f_close(&file1);
   1825          			return -7;
   1826          		}
   1827          
   1828          		if (tmp != node_size)
   1829          		{
   1830          			f_close(&file1);
   1831          			return -7;
   1832          		}
   1833          	}
   1834          
   1835          		if(barcode_hash_prev)
   1836          		{
   1837          			f_lseek(&file1,(barcode_hash_prev-1)*node_size);
   1838          			if ((f_read(&file1,buffer,node_size,&tmp) != FR_OK)||(tmp != node_size))
   1839          			{
   1840          				f_close(&file1);
   1841          				return -13;
   1842          			}
   1843          
   1844          
   1845          
   1846          			((TBATCH_NODE*)buffer)->by_barcode_next = barcode_hash_next;
   1847          			calc_check_value(buffer);
   1848          
   1849          			f_lseek(&file1,(barcode_hash_prev-1)*node_size);
   1850          			if (f_write(&file1,buffer,node_size,&tmp) != FR_OK)
   1851          			{
   1852          				f_close(&file1);
   1853          				return -14;
   1854          			}
   1855          
   1856          			if (tmp != node_size)
   1857          			{
   1858          				f_close(&file1);
   1859          				return -15;
   1860          			}
   1861          
   1862          			f_sync(&file1);
   1863          		}
   1864          
   1865          
   1866          		if (barcode_hash_next)
   1867          		{
   1868          			f_lseek(&file1,(barcode_hash_next-1)*node_size);
   1869          			if ((f_read(&file1,buffer,node_size,&tmp) != FR_OK)||(tmp != node_size))
   1870          			{
   1871          				f_close(&file1);
   1872          				return -16;
   1873          			}
   1874          
   1875          
   1876          			((TBATCH_NODE*)buffer)->by_barcode_prev = barcode_hash_prev;
   1877          			calc_check_value(buffer);
   1878          			f_lseek(&file1,(barcode_hash_next-1)*node_size);
   1879          			if (f_write(&file1,buffer,node_size,&tmp) != FR_OK)
   1880          			{
   1881          				f_close(&file1);
   1882          				return -17;
   1883          			}
   1884          
   1885          			if (tmp != node_size)
   1886          			{
   1887          				f_close(&file1);
   1888          				return -18;
   1889          			}
   1890          
   1891          			f_sync(&file1);	
   1892          		}
   1893          
   1894          
   1895          
   1896          
   1897          	//可以将节点文件关闭了
   1898          	f_close(&file1);
   1899          
   1900          	//step3:将删除的节点的偏移记录在信息文件中
   1901          	strcpy((char*)inf_file_str,batch_dirctory);
   1902          	strcat((char*)inf_file_str,batch_inf_file);
   1903          
   1904          	if (f_open(&file1,(char const*)inf_file_str,FA_OPEN_EXISTING | FA_READ | FA_WRITE) != FR_OK)
   1905          	{
   1906          		return -8;
   1907          	}
   1908          
   1909          	if (file1.fsize > 12)
   1910          	{
   1911          		f_lseek(&file1,file1.fsize-4);
   1912          		if (f_read(&file1,(void*)&link_end,4,&tmp) != FR_OK)
   1913          		{
   1914          			f_close(&file1);
   1915          			return -9;
   1916          		}
   1917          
   1918          		if (link_end == index)
   1919          		{
   1920          			goto check_next;		//说明该删除的节点偏移已经保存在INF文件中了，不需要再保存一次
   1921          		}
   1922          	}
   1923          
   1924          	f_lseek(&file1,file1.fsize);
   1925          	if (f_write(&file1,(void*)&index,4,&tmp) != FR_OK)
   1926          	{
   1927          		f_close(&file1);
   1928          		return -9;
   1929          	}
   1930          
   1931          	if (tmp != 4)
   1932          	{
   1933          		f_close(&file1);
   1934          		return -9;
   1935          	}
   1936          
   1937          	f_sync(&file1);
   1938          
   1939          check_next:
   1940          
   1941          	//如果删除的节点是链表的首节点，那么还需要更新保存的链表首节点信息
   1942          	f_lseek(&file1,4);
   1943          	if ((f_read(&file1,(void*)&link_end,4,&tmp) != FR_OK)||(tmp != 4))
   1944          	{
   1945          		f_close(&file1);
   1946          		return -10;
   1947          	}
   1948          
   1949          	if (link_end == index)
   1950          	{
   1951          		f_lseek(&file1,4);
   1952          		link_end = logical_next;
   1953          		if (f_write(&file1,(void*)&link_end,4,&tmp) != FR_OK)
   1954          		{
   1955          			f_close(&file1);
   1956          			return -11;
   1957          		}
   1958          
   1959          		if (tmp != 4)
   1960          		{
   1961          			f_close(&file1);
   1962          			return -11;
   1963          		}
   1964          
   1965          		f_sync(&file1);
   1966          	}
   1967          
   1968          	//如果删除的节点是链表的尾节点，那么还需要更新保存的链表尾节点信息
   1969          	f_lseek(&file1,8);
   1970          	if ((f_read(&file1,(void*)&link_end,4,&tmp) != FR_OK)||(tmp != 4))
   1971          	{
   1972          		f_close(&file1);
   1973          		return -10;
   1974          	}
   1975          
   1976          	if (link_end == index)
   1977          	{
   1978          		f_lseek(&file1,8);
   1979          		link_end = logical_prev;
   1980          		if (f_write(&file1,(void*)&link_end,4,&tmp) != FR_OK)
   1981          		{
   1982          			f_close(&file1);
   1983          			return -11;
   1984          		}
   1985          
   1986          		if (tmp != 4)
   1987          		{
   1988          			f_close(&file1);
   1989          			return -11;
   1990          		}
   1991          	}
   1992          
   1993          	f_close(&file1);
   1994          
   1995          	strcpy((char*)inf_file_str,batch_dirctory);
   1996          	strcat((char*)inf_file_str,barcode_hash_table_file);
   1997          
   1998          	if (hash_value)
   1999          	{
   2000          		if (f_open(&file1,(char const*)inf_file_str,FA_OPEN_EXISTING | FA_READ | FA_WRITE) != FR_OK)
   2001          		{
   2002          			return -28;
   2003          		}
   2004          
   2005          		f_lseek(&file1,4*(hash_value%HASH_TABLE_SIZE));
   2006          		//获取链表的尾地址
   2007          		if (f_read(&file1,(void*)&link_end,4,&tmp) != FR_OK)
   2008          		{
   2009          			f_close(&file1);
   2010          			return -29;
   2011          		}
   2012          
   2013          		if (link_end == index)
   2014          		{
   2015          			//如果该节点刚好是对应链表的尾节点，那么需要更新该链表对应的尾节点
   2016          			f_lseek(&file1,8*(hash_value%HASH_TABLE_SIZE));
   2017          
   2018          			if (f_write(&file1,(void*)&barcode_hash_prev,4,&tmp) != FR_OK)
   2019          			{
   2020          				f_close(&file1);
   2021          				return -30;
   2022          			}
   2023          		}
   2024          
   2025          		f_close(&file1);
   2026          
   2027          	}
   2028          
   2029          	return 0;
   2030          }
   2031          
   2032          /**
   2033          * @brief 记录操作的恢复
   2034          * @param[in] unsigned char *precord 记录指针
   2035          * @return 0:成功
   2036          *        -1:失败
   2037          */
   2038          static int record_recover(unsigned char *log_data,unsigned int log_data_len)
   2039          {
   2040          	unsigned int	op_type,rec_offset,prev,next,saved_linkend;
   2041          	unsigned int	barcode_hash_prev,barcode_hash_next;
   2042          
   2043          	op_type = *((unsigned int*)log_data);
   2044          
   2045          	if (OP_TYPE_ADD_NODE == op_type)
   2046          	{
   2047          		if (log_data_len < 12)
   2048          		{
   2049          			return -2;		//日志数据长度错误
   2050          		}
   2051          
   2052          		rec_offset = *((unsigned int*)(log_data+8));
   2053          
   2054          		if (log_data_len == 12)
   2055          		{
   2056          			//如果日志数据只有12字节，那么说明在增加记录时还没有对原来的记录文件做任何的变动，所以不需要任何的处理
   2057          			return 0;
   2058          		}
   2059          
   2060          		//说明在记录增加过程中可能已经改变了部分记录数据，需要采取恢复措施
   2061          		if (record_add_recover(rec_offset,log_data+12,log_data_len-12))
   2062          		{
   2063          			return -3;
   2064          		}
   2065          	}
   2066          	else if (OP_TYPE_CLEAR_NODE == op_type)
   2067          	{
   2068          		if ((log_data_len == 8)||(log_data_len == 12))
   2069          		{
   2070          			if (record_clear_recover())
   2071          			{
   2072          				return -3;
   2073          			}
   2074          		}
   2075          		else
   2076          		{
   2077          			return -2;	//日志数据长度错误
   2078          		}
   2079          	}
   2080          	else if (OP_TYPE_DEL_NODE == op_type)
   2081          	{
   2082          		if ((log_data_len == 32)||(log_data_len == 36))
   2083          		{
   2084          			//rec_type = *((unsigned int*)(log_data+4));
   2085          			rec_offset = *((unsigned int*)(log_data+8));
   2086          			prev = *((unsigned int*)(log_data+12));
   2087          			next = *((unsigned int*)(log_data+16));
   2088          			barcode_hash_prev = *((unsigned int*)(log_data+20));
   2089          			barcode_hash_next = *((unsigned int*)(log_data+24));
   2090          			saved_linkend = *((unsigned int*)(log_data+28));
   2091          			if (del_one_node_recover(rec_offset,prev,next,barcode_hash_prev,barcode_hash_next,saved_linkend))
   2092          			{
   2093          				return -3;
   2094          			}
   2095          		}
   2096          		else
   2097          		{
   2098          			return -2;	//日志数据长度错误
   2099          		}
   2100          
   2101          	}
   2102          
   2103          	return 0;
   2104          }
   2105          
   2106          
   2107          /**
   2108          ***************************************************************************
   2109          *@brief 判断是否存在日志文件，如果有日志文件试图根据日志文件恢复被中断的操作或者回滚被中断的操作
   2110          *@param[in] 
   2111          *@return 0 成功  else; 失败
   2112          ***************************************************************************
   2113          */
   2114          int recover_record_by_logfile(void)
   2115          {
   2116          	unsigned int	logfile_len,offset,logitem_len;
   2117          	unsigned int				tmp;
   2118          	int				err_code = 0;
   2119          	unsigned char	log_bufffer[160];
   2120          
   2121          	if (f_open(&file3,log_file,FA_OPEN_ALWAYS | FA_READ | FA_WRITE) != FR_OK)
   2122          	{
   2123          		return -1;
   2124          	}
   2125          	
   2126          	logfile_len = file3.fsize;	//日志文件的长度
   2127          	offset = 0;
   2128          	while(logfile_len)
   2129          	{
   2130          		f_lseek(&file3,offset);
   2131          		if (f_read(&file3,(void*)&logitem_len,4,&tmp) != FR_OK)
   2132          		{
   2133          			err_code = -2;
   2134          			break;
   2135          		}
   2136          
   2137          		if (tmp != 4)
   2138          		{
   2139          			err_code = -2;
   2140          			break;
   2141          		}
   2142          
   2143          		//if ((logitem_len <= 4)||(logitem_len > 256))
   2144          		//{
   2145          		//	err_code = -3;
   2146          		//	if (logitem_len == 0)	//碰到一种情况，log文件本身大小为24字节，但是内容全部为0，怀疑是写log文件自身时断电造成的
   2147          		//	{
   2148          		//		err_code = 0;		
   2149          		//	}
   2150          		//	break;
   2151          		//}
   2152          
   2153          		if (logitem_len != logfile_len)
   2154          		{
   2155          			err_code = 0;		//出现这种情况认为是在写LOG文件本身断电造成的
   2156          			break;
   2157          		}
   2158          
   2159          		if (f_read(&file3,(void*)log_bufffer,logitem_len-4,&tmp) != FR_OK)
   2160          		{
   2161          			err_code = -4;
   2162          			break;
   2163          		}
   2164          
   2165          		if (tmp != logitem_len-4)
   2166          		{
   2167          			err_code = -4;
   2168          			break;
   2169          		}
   2170          
   2171          		if (record_recover(log_bufffer,logitem_len-4))
   2172          		{
   2173          			err_code = -5;
   2174          			break;
   2175          		}
   2176          
   2177          		offset += logitem_len;
   2178          		logfile_len -= logitem_len;
   2179          	}
   2180          
   2181          	if (err_code == 0)
   2182          	{
   2183          		f_lseek(&file3,0);
   2184          		f_truncate(&file3);		//清除日志文件
   2185          	}
   2186          
   2187          	f_close(&file3);
   2188          	return err_code;
   2189          }
   2190          
   2191          
   2192          
   2193          
   2194          #ifdef T5_SD_DEBUG
   2195          
   2196          void debug_out(unsigned char* out,unsigned int len,unsigned char format)
   2197          {
   2198          	unsigned int write_num;
   2199          	unsigned char *pBuf;
   2200          	unsigned char data;
   2201          
   2202          	if (0 == debug_file_status)
   2203          	{
   2204          		//创建DEBUG结果的输出文件
   2205          		if (f_open(&debug_file,"Debug.out",FA_OPEN_ALWAYS | FA_WRITE) != FR_OK)
   2206          		{
   2207          			return;
   2208          		}
   2209          
   2210          		f_lseek(&debug_file,debug_file.fsize);
   2211          		debug_file_status = 1;
   2212          	}
   2213          
   2214          
   2215          	if (1 == debug_file_status)
   2216          	{
   2217          		if (format == 0)
   2218          		{
   2219          			//表明打印的数据是16进制数，需要转换为ASCII格式
   2220          			pBuf = (unsigned char*)Jmalloc(len*3);
   2221          			if (pBuf == NULL)
   2222          			{
   2223          				return;
   2224          			}
   2225          
   2226          			for (write_num = 0;write_num < len;write_num++)
   2227          			{
   2228          				data = out[write_num];
   2229          				pBuf[write_num*3] = HexToAscii(data >> 4);
   2230          				pBuf[write_num*3+1] = HexToAscii(out[write_num]&0x0f);
   2231          				pBuf[write_num*3+2] = ' ';
   2232          			}
   2233          
   2234          			if (f_write(&debug_file,pBuf,len*3,&write_num) != FR_OK)
   2235          			{
   2236          				Jfree(pBuf);
   2237          				f_close(&debug_file);
   2238          				debug_file_status = 0;
   2239          			}
   2240          
   2241          			Jfree(pBuf);
   2242          		}
   2243          		else
   2244          		{
   2245          			//表明打印的数据是ASCII格式，不需要转换
   2246          			if (f_write(&debug_file,out,len,&write_num) != FR_OK)
   2247          			{
   2248          				f_close(&debug_file);
   2249          				debug_file_status = 0;
   2250          			}
   2251          		}
   2252          
   2253          		f_sync(&debug_file);
   2254          	}
   2255          }
   2256          
   2257          
   2258          void delete_debug_file(void)
   2259          {
   2260          	debug_file_status = 0;
   2261          	if (f_open(&debug_file,"Debug.out",FA_OPEN_EXISTING | FA_WRITE) != FR_OK)
   2262          	{
   2263          		return;
   2264          	}
   2265          	
   2266          	f_lseek(&debug_file,0);
   2267          	f_truncate(&debug_file);
   2268          
   2269          	f_close(&debug_file);
   2270          }
   2271          
   2272          void close_debug_file(void)
   2273          {
   2274          	if (debug_file_status == 1)
   2275          	{
   2276          		f_close(&debug_file);
   2277          	}
   2278          }
   2279          
   2280          #endif
   2281          
   2282          #if 0
   2283          int check_serial_list_file(void)
   2284          {
   2285          #if 0
   2286          	unsigned char buf1[200],buf2[200];
   2287          	unsigned int tmp;
   2288          
   2289          	if (f_open(&file3,"/T5_DB/serial/serial.lst",FA_OPEN_EXISTING | FA_READ) != FR_OK)
   2290          	{
   2291          		return -1;
   2292          	}
   2293          
   2294          	if (file3.fsize >= 2*sizeof(SERIAL_DATA_NODE))
   2295          	{
   2296          		f_lseek(&file3,file3.fsize - 2*sizeof(SERIAL_DATA_NODE));
   2297          		if (f_read(&file3,(void*)buf1,sizeof(SERIAL_DATA_NODE),&tmp) != FR_OK)
   2298          		{
   2299          			f_close(&file3);
   2300          			return -1;
   2301          		}
   2302          
   2303          		if (tmp != sizeof(SERIAL_DATA_NODE))
   2304          		{
   2305          			f_close(&file3);
   2306          			return -1;
   2307          		}
   2308          
   2309          		if (f_read(&file3,(void*)buf2,sizeof(SERIAL_DATA_NODE),&tmp) != FR_OK)
   2310          		{
   2311          			f_close(&file3);
   2312          			return -1;
   2313          		}
   2314          
   2315          		if (tmp != sizeof(SERIAL_DATA_NODE))
   2316          		{
   2317          			f_close(&file3);
   2318          			return -1;
   2319          		}
   2320          
   2321          		if (memcmp(buf1,buf2,sizeof(SERIAL_DATA_NODE)) == 0)
   2322          		{
   2323          			f_close(&file3);
   2324          			return 1;
   2325          		}
   2326          	}
   2327          
   2328          		f_close(&file3);
   2329          
   2330          #endif
   2331          
   2332          	unsigned int index;
   2333          	unsigned char *ptmp;
   2334          
   2335          	if (f_open(&file3,"/T5_DB/serial/serial.lst",FA_OPEN_EXISTING | FA_READ) != FR_OK)
   2336          	{
   2337          		return -1;
   2338          	}
   2339          
   2340          	index = file3.fsize/sizeof(SERIAL_DATA_NODE);
   2341          	f_close(&file3);
   2342          
   2343          	ptmp = record_module_read(REC_TYPE_SERIAL_LIST,index);
   2344          	if (ptmp == 0)
   2345          	{
   2346          
   2347          		return 1;
   2348          	}
   2349          
   2350          	return 0;
   2351          }
   2352          #endif

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     calc_check_value                   16
     check_record_dir                   72
     check_updatefile                   24
     clear_log_file                      8
     del_one_node_recover              192
     del_update_bin                      8
     delete_one_node                   224
     get_file_size                       8
     get_node                           56
     init_data_info_file                24
     init_hash_table_file              528
     memcpy                              8
     memset                              8
     read_rec_file                      24
     rec_search                        176
     rec_searchby_tag                   16
     record_add                        152
     record_add_recover                 56
     record_clear                       64
     record_clear_recover               56
     record_module_count                80
     record_module_init                 56
     record_module_read                 56
     record_recover                     24
     recover_hash_table_modify         168
     recover_record_by_logfile         184
     save_log_file                     552
     update_link_info_after_addNode    144
     write_rec_file                     24


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     memcpy                           14
     memset                           20
     rec_module_buffer               112
     current_node_offset               4
     g_rec_offset                      4
     prev_node_offset                  4
     next_node_offset                  4
     log_len                           4
     file2                           548
     file3                           548
     dir                              28
     fs                              560
     init_hash_table_file            106
     init_data_info_file             100
     record_module_init              268
     record_module_read              188
     calc_check_value                 30
     update_link_info_after_addNode  166
     save_log_file                   278
     clear_log_file                   86
     record_add                      804
     record_module_count             144
     record_clear                    216
     rec_search                      242
     rec_searchby_tag                 28
     get_node                        180
     delete_one_node                1340
     get_file_size                    40
     read_rec_file                   100
     write_rec_file                  120
     check_record_dir                200
     check_updatefile                192
     del_update_bin                   56
     recover_hash_table_modify       404
     record_add_recover              236
     record_clear_recover            120
     del_one_node_recover           1144
     record_recover                  146
     recover_record_by_logfile       196
     ??DataTable12                     4
     ??DataTable49                     4
     ??DataTable58                     4
     ??DataTable119                    4
     ??DataTable124                    4
     ??DataTable126                    4
     ??DataTable132                    4
     ??DataTable136                    4
     ??DataTable138                    4
     ??DataTable139                    4
     ??DataTable144                    4
     ??DataTable146                    4
     ?<Constant "info">                8
     ?<Constant "/batch">              8
     ?<Constant "/barhash.tbl">       16
     ?<Constant "/batch.inf">         12
     ?<Constant "/batch.lst">         12
     ?<Constant "/log.tmp">           12
     ?<Constant "/update.bin">        12

 
 1 816 bytes in section .bss
    80 bytes in section .rodata
 7 212 bytes in section .text
 
 7 178 bytes of CODE  memory (+ 34 bytes shared)
    80 bytes of CONST memory
 1 816 bytes of DATA  memory

Errors: none
Warnings: none
