###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     09/Dec/2015  16:16:52 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\BT Printer\FW\src\Drivers\BT816.c                     #
#    Command line =  "E:\BT Printer\FW\src\Drivers\BT816.c" -D DEBUG_VER      #
#                    -lcN "E:\BT Printer\FW\src\Project\EWARMv5\Debug\List\"  #
#                    -o "E:\BT Printer\FW\src\Project\EWARMv5\Debug\Obj\"     #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 5.4\arm\INC\DLib_Config_Full.h" -I "E:\BT      #
#                    Printer\FW\src\Project\EWARMv5\..\" -I "E:\BT            #
#                    Printer\FW\src\Project\EWARMv5\..\..\App\" -I "E:\BT     #
#                    Printer\FW\src\Project\EWARMv5\..\..\Drivers\" -I        #
#                    "E:\BT Printer\FW\src\Project\EWARMv5\..\..\FatFs\" -I   #
#                    "E:\BT Printer\FW\src\Project\EWARMv5\..\..\Lib\inc\"    #
#                    -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS\uC-C #
#                    PU\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS #
#                    \uC-LIB\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\.. #
#                    \uCOS\uCOS-II\Ports\" -I "E:\BT                          #
#                    Printer\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Source #
#                    \" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS\u #
#                    C-Probe\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\.. #
#                    \usb_lib\" -I "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 5.4\arm\INC\" -Ol                              #
#    List file    =  E:\BT Printer\FW\src\Project\EWARMv5\Debug\List\BT816.ls #
#                    t                                                        #
#    Object file  =  E:\BT Printer\FW\src\Project\EWARMv5\Debug\Obj\BT816.o   #
#                                                                             #
#                                                                             #
###############################################################################

E:\BT Printer\FW\src\Drivers\BT816.c
      1          /**
      2          * @file BT816.c
      3          * @brief FSC BT816蓝牙模块的驱动
      4          * @version V0.0.1
      5          * @author joe.zhou
      6          * @date 2015年10月10日
      7          * @note   根据模块的响应特点，串口驱动采用 DMA发送和接受 + 串口空闲中断判断响应数据接收完的机制。
      8          * @copy
      9          *
     10          * 此代码为深圳合杰电子有限公司项目代码，任何人及公司未经许可不得复制传播，或用于
     11          * 本公司以外的项目。本司保留一切追究权利。
     12          *
     13          * <h1><center>&copy; COPYRIGHT 2015 heroje</center></h1>
     14          *
     15          */
     16          #include "hw_platform.h"
     17          #if(BT_MODULE == USE_BT816)
     18          #include "BT816.h"
     19          #include "stm32f10x_lib.h"
     20          #include "string.h"
     21          #include <assert.h>
     22          #include "basic_fun.h"
     23          #include "TimeBase.h"
     24          #include "uart.h"
     25          
     26          //#define	BT816_DEBUG
     27          #ifdef DEBUG_VER
     28          extern unsigned char debug_buffer[];
     29          extern unsigned int debug_cnt;
     30          #endif
     31          
     32          #define BT816_RES_INIT				0x00
     33          
     34          
     35          //应答类型的响应数据状态
     36          #define BT816_RES_SUCCESS				0x01
     37          #define BT816_RES_INVALID_STATE			0x02
     38          #define BT816_RES_INVALID_SYNTAX		0x03
     39          #define BT816_RES_BUSY					0x04
     40          
     41          #define BT816_RES_PAYLOAD				0x05
     42          
     43          #define BT816_RES_UNKOWN				0x06
     44          
     45          //command format:AT+(Command)[=parameter]<CR><LF>
     46          //response format1:<CR><LF>+(Response)#(code)<CR><LF>
     47          //		   format1:<CR><LF>+(Response)[=payload]<CR><LF>
     48          
     49          /**
     50          * @brief BT816S01响应定义  BT816S01->host
     51          */
     52          typedef struct {
     53          	unsigned short			DataPos;
     54          	unsigned short			DataLength;
     55          	unsigned char			status;
     56          	unsigned char			*DataBuffer;
     57          }TBT816Res;
     58          
     59          TBT816Res		BT816_res[MAX_BT_CHANNEL];
     60          
     61          static unsigned char	BT816_send_buff[MAX_BT_CHANNEL][32];
     62          unsigned char	BT816_recbuffer[MAX_BT_CHANNEL][BT816_RES_BUFFER_LEN];
     63          
     64          
     65          static	unsigned char  bt_connect_status;
     66          
     67          #define		BT1_CONNECT		(bt_connect_status&(1<<BT1_MODULE))
     68          #define		BT2_CONNECT		(bt_connect_status&(1<<BT2_MODULE))
     69          #define		BT3_CONNECT		(bt_connect_status&(1<<BT3_MODULE))
     70          #define		BT4_CONNECT		(bt_connect_status&(1<<BT4_MODULE))
     71          #define		BT_CONNECT(ch)		(bt_connect_status&(1<<(ch)))
     72          
     73          
     74          
     75          #define	RESET_BT1_DMA()		do{	\
     76          							DMA_Cmd(DMA1_Channel5,DISABLE);\
     77          							DMA1_Channel5->CNDTR = BT816_RES_BUFFER_LEN;\
     78          							DMA_Cmd(DMA1_Channel5,ENABLE);\
     79          							}while(0)
     80          
     81          #define	RESET_BT2_DMA()		do{	\
     82          							DMA_Cmd(DMA1_Channel6,DISABLE);\
     83          							DMA1_Channel6->CNDTR = BT816_RES_BUFFER_LEN; \
     84          							DMA_Cmd(DMA1_Channel6,ENABLE);\
     85          							}while(0)
     86          
     87          #define	RESET_BT3_DMA()		do{	\
     88          							DMA_Cmd(DMA1_Channel3,DISABLE);\
     89          							DMA1_Channel3->CNDTR = BT816_RES_BUFFER_LEN;\
     90          							DMA_Cmd(DMA1_Channel3,ENABLE);\
     91          							}while(0)
     92          
     93          #define	RESET_BT4_DMA()		do{	\
     94          							DMA_Cmd(DMA2_Channel3,DISABLE);\
     95          							DMA2_Channel3->CNDTR = BT816_RES_BUFFER_LEN;\
     96          							DMA_Cmd(DMA2_Channel3,ENABLE);\
     97          							}while(0)
     98          /*
     99           * @brief: 初始化模块端口
    100           * @param[in]  unsigned int bt_channel  蓝牙模块的索引
    101           * @param[in]  unsigned int baudrate	与模块连接的串口波特率
    102          */
    103          static void BT816_GPIO_config(unsigned int bt_channel,unsigned int baudrate)
    104          {
    105          	GPIO_InitTypeDef				GPIO_InitStructure;
    106          	USART_InitTypeDef				USART_InitStructure;
    107          	DMA_InitTypeDef					DMA_InitStructure;
    108          
    109          	//for debug trip
    110          	//RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    111          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO | RCC_APB2Periph_GPIOB , ENABLE);
    112          	GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable , ENABLE);
    113          
    114          	//trip1	PB.6  trip2  PB.5  trip3  PB.4  trip4  PB.3
    115          	GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6;
    116          	GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    117          	GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_Out_PP;
    118          	GPIO_Init(GPIOB, &GPIO_InitStructure);
    119          	GPIO_SetBits(GPIOB, GPIO_Pin_3);		//trip4
    120          	GPIO_SetBits(GPIOB, GPIO_Pin_4);		//trip3
    121          	GPIO_ResetBits(GPIOB, GPIO_Pin_5);		//trip2
    122          	GPIO_SetBits(GPIOB, GPIO_Pin_6);		//trip1
    123          
    124          #if(BT_MODULE_CONFIG & USE_BT1_MODULE)
    125          	if (bt_channel == BT1_MODULE)
    126          	{
    127          		//串口1
    128          		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
    129          		RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    130          
    131          		//B-Reset  PB.9		B-Busy	PB.8
    132          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_8 | GPIO_Pin_9;
    133          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    134          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_Out_PP;
    135          		GPIO_Init(GPIOB, &GPIO_InitStructure);
    136          		GPIO_SetBits(GPIOB, GPIO_Pin_9);
    137          		GPIO_ResetBits(GPIOB, GPIO_Pin_8);
    138          
    139          		//B-State  PB.7
    140          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_7;
    141          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    142          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IPD;
    143          		GPIO_Init(GPIOB, &GPIO_InitStructure);
    144          
    145          		// 使用USART1, PA9,PA10
    146          		/* Configure USART1 Tx (PA.9) as alternate function push-pull */
    147          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_9;
    148          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_50MHz;
    149          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_AF_PP;
    150          		GPIO_Init(GPIOA, &GPIO_InitStructure);
    151          
    152          		/* Configure USART1 Rx (PA.10) as input floating				*/
    153          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_10;
    154          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IN_FLOATING;
    155          		GPIO_Init(GPIOA, &GPIO_InitStructure);
    156          
    157          		USART_InitStructure.USART_BaudRate		= baudrate;					
    158          		USART_InitStructure.USART_WordLength	= USART_WordLength_8b;
    159          		USART_InitStructure.USART_StopBits		= USART_StopBits_1;
    160          		USART_InitStructure.USART_Parity		= USART_Parity_No;
    161          		USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    162          		USART_InitStructure.USART_Mode			= USART_Mode_Rx | USART_Mode_Tx;
    163          
    164          		USART_Init(USART1, &USART_InitStructure);
    165          
    166          
    167          		/* DMA clock enable */
    168          		RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
    169          
    170          		/* fill init structure */
    171          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    172          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    173          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    174          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
    175          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
    176          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
    177          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    178          
    179          		/* DMA1 Channel4 (triggered by USART1 Tx event) Config */
    180          		DMA_DeInit(DMA1_Channel4);
    181          		DMA_InitStructure.DMA_PeripheralBaseAddr =(u32)(&USART1->DR);
    182          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
    183          		/* As we will set them before DMA actually enabled, the DMA_MemoryBaseAddr
    184          		* and DMA_BufferSize are meaningless. So just set them to proper values
    185          		* which could make DMA_Init happy.
    186          		*/
    187          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)0;
    188          		DMA_InitStructure.DMA_BufferSize = 1;
    189          		DMA_Init(DMA1_Channel4, &DMA_InitStructure);
    190          
    191          
    192          		//DMA1通道5配置  
    193          		DMA_DeInit(DMA1_Channel5);  
    194          		//外设地址  
    195          		DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)(&USART1->DR);  
    196          		//内存地址  
    197          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)BT816_recbuffer[BT1_MODULE];  
    198          		//dma传输方向单向  
    199          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;  
    200          		//设置DMA在传输时缓冲区的长度  
    201          		DMA_InitStructure.DMA_BufferSize = BT816_RES_BUFFER_LEN;  
    202          		//设置DMA的外设递增模式，一个外设  
    203          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;  
    204          		//设置DMA的内存递增模式  
    205          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;  
    206          		//外设数据字长  
    207          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;  
    208          		//内存数据字长  
    209          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;  
    210          		//设置DMA的传输模式  
    211          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;  
    212          		//设置DMA的优先级别  
    213          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;  
    214          		//设置DMA的2个memory中的变量互相访问  
    215          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;  
    216          		DMA_Init(DMA1_Channel5,&DMA_InitStructure);  
    217          
    218          		//使能通道5 
    219          		DMA_Cmd(DMA1_Channel5,ENABLE);  
    220          
    221          		//采用DMA方式接收  
    222          		USART_DMACmd(USART1,USART_DMAReq_Rx,ENABLE); 
    223          
    224          		/* Enable USART1 DMA Tx request */
    225          		USART_DMACmd(USART1, USART_DMAReq_Tx , ENABLE);
    226          
    227          		USART_Cmd(USART1, ENABLE);
    228          	}
    229          #endif
    230          
    231          #if(BT_MODULE_CONFIG & USE_BT2_MODULE)
    232          	if (bt_channel == BT2_MODULE)
    233          	{
    234          		//USART2
    235          		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE);
    236          		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
    237          
    238          		//B-Reset  PC.3		B-Busy	PC.1
    239          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_1 | GPIO_Pin_3;
    240          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    241          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_Out_PP;
    242          		GPIO_Init(GPIOC, &GPIO_InitStructure);
    243          		GPIO_SetBits(GPIOC, GPIO_Pin_3);
    244          		GPIO_ResetBits(GPIOC, GPIO_Pin_1);
    245          
    246          		//B-State  PC.2
    247          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_2;
    248          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    249          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IPD;
    250          		GPIO_Init(GPIOC, &GPIO_InitStructure);
    251          
    252          		// 使用USART2, PA2,PA3
    253          		/* Configure USART2 Tx (PA.2) as alternate function push-pull */
    254          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_2;
    255          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_50MHz;
    256          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_AF_PP;
    257          		GPIO_Init(GPIOA, &GPIO_InitStructure);
    258          
    259          		/* Configure USART2 Rx (PA.3) as input floating				*/
    260          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_3;
    261          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IN_FLOATING;
    262          		GPIO_Init(GPIOA, &GPIO_InitStructure);
    263          
    264          		USART_InitStructure.USART_BaudRate		= baudrate;					
    265          		USART_InitStructure.USART_WordLength	= USART_WordLength_8b;
    266          		USART_InitStructure.USART_StopBits		= USART_StopBits_1;
    267          		USART_InitStructure.USART_Parity		= USART_Parity_No;
    268          		USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    269          		USART_InitStructure.USART_Mode			= USART_Mode_Rx | USART_Mode_Tx;
    270          
    271          		USART_Init(USART2, &USART_InitStructure);
    272          
    273          
    274          		/* DMA clock enable */
    275          		RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
    276          
    277          		/* fill init structure */
    278          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    279          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    280          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    281          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
    282          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
    283          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
    284          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    285          
    286          		/* DMA1 Channel7 (triggered by USART2 Tx event) Config */
    287          		DMA_DeInit(DMA1_Channel7);
    288          		DMA_InitStructure.DMA_PeripheralBaseAddr =(u32)(&USART2->DR);
    289          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
    290          		/* As we will set them before DMA actually enabled, the DMA_MemoryBaseAddr
    291          		* and DMA_BufferSize are meaningless. So just set them to proper values
    292          		* which could make DMA_Init happy.
    293          		*/
    294          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)0;
    295          		DMA_InitStructure.DMA_BufferSize = 1;
    296          		DMA_Init(DMA1_Channel7, &DMA_InitStructure);
    297          
    298          
    299          		//DMA1通道6配置  
    300          		DMA_DeInit(DMA1_Channel6);  
    301          		//外设地址  
    302          		DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)(&USART2->DR);  
    303          		//内存地址  
    304          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)BT816_recbuffer[BT2_MODULE];  
    305          		//dma传输方向单向  
    306          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;  
    307          		//设置DMA在传输时缓冲区的长度  
    308          		DMA_InitStructure.DMA_BufferSize = BT816_RES_BUFFER_LEN;  
    309          		//设置DMA的外设递增模式，一个外设  
    310          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;  
    311          		//设置DMA的内存递增模式  
    312          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;  
    313          		//外设数据字长  
    314          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;  
    315          		//内存数据字长  
    316          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;  
    317          		//设置DMA的传输模式  
    318          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;  
    319          		//设置DMA的优先级别  
    320          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;  
    321          		//设置DMA的2个memory中的变量互相访问  
    322          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;  
    323          		DMA_Init(DMA1_Channel6,&DMA_InitStructure);  
    324          
    325          		//使能通道6 
    326          		DMA_Cmd(DMA1_Channel6,ENABLE);  
    327          
    328          		//采用DMA方式接收  
    329          		USART_DMACmd(USART2,USART_DMAReq_Rx,ENABLE); 
    330          
    331          		/* Enable USART2 DMA Tx request */
    332          		USART_DMACmd(USART2, USART_DMAReq_Tx , ENABLE);
    333          
    334          		USART_Cmd(USART2, ENABLE);
    335          	}
    336          #endif
    337          
    338          #if(BT_MODULE_CONFIG & USE_BT3_MODULE)
    339          	if (bt_channel == BT3_MODULE)
    340          	{
    341          		//USART3
    342          		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE);
    343          		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
    344          
    345          		//B-Reset  PE.13		B-Busy	PE.15
    346          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_13 | GPIO_Pin_15;
    347          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    348          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_Out_PP;
    349          		GPIO_Init(GPIOE, &GPIO_InitStructure);
    350          		GPIO_SetBits(GPIOE, GPIO_Pin_13);
    351          		GPIO_ResetBits(GPIOE, GPIO_Pin_15);
    352          
    353          		//B-State  PE.14
    354          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_14;
    355          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    356          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IPD;
    357          		GPIO_Init(GPIOE, &GPIO_InitStructure);
    358          
    359          		// 使用USART3, PB10,PB11
    360          		/* Configure USART3 Tx (PB.10) as alternate function push-pull */
    361          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_10;
    362          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_50MHz;
    363          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_AF_PP;
    364          		GPIO_Init(GPIOB, &GPIO_InitStructure);
    365          
    366          		/* Configure USART3 Rx (PB.11) as input floating				*/
    367          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_11;
    368          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IN_FLOATING;
    369          		GPIO_Init(GPIOB, &GPIO_InitStructure);
    370          
    371          		USART_InitStructure.USART_BaudRate		= baudrate;					
    372          		USART_InitStructure.USART_WordLength	= USART_WordLength_8b;
    373          		USART_InitStructure.USART_StopBits		= USART_StopBits_1;
    374          		USART_InitStructure.USART_Parity		= USART_Parity_No;
    375          		USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    376          		USART_InitStructure.USART_Mode			= USART_Mode_Rx | USART_Mode_Tx;
    377          
    378          		USART_Init(USART3, &USART_InitStructure);
    379          
    380          
    381          		/* DMA clock enable */
    382          		RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
    383          
    384          		/* fill init structure */
    385          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    386          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    387          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    388          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
    389          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
    390          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
    391          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    392          
    393          		/* DMA1 Channel2 (triggered by USART3 Tx event) Config */
    394          		DMA_DeInit(DMA1_Channel2);
    395          		DMA_InitStructure.DMA_PeripheralBaseAddr =(u32)(&USART3->DR);
    396          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
    397          		/* As we will set them before DMA actually enabled, the DMA_MemoryBaseAddr
    398          		* and DMA_BufferSize are meaningless. So just set them to proper values
    399          		* which could make DMA_Init happy.
    400          		*/
    401          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)0;
    402          		DMA_InitStructure.DMA_BufferSize = 1;
    403          		DMA_Init(DMA1_Channel2, &DMA_InitStructure);
    404          
    405          
    406          		//DMA1通道3配置  
    407          		DMA_DeInit(DMA1_Channel3);  
    408          		//外设地址  
    409          		DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)(&USART3->DR);  
    410          		//内存地址  
    411          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)BT816_recbuffer[BT3_MODULE];  
    412          		//dma传输方向单向  
    413          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;  
    414          		//设置DMA在传输时缓冲区的长度  
    415          		DMA_InitStructure.DMA_BufferSize = BT816_RES_BUFFER_LEN;  
    416          		//设置DMA的外设递增模式，一个外设  
    417          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;  
    418          		//设置DMA的内存递增模式  
    419          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;  
    420          		//外设数据字长  
    421          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;  
    422          		//内存数据字长  
    423          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;  
    424          		//设置DMA的传输模式  
    425          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;  
    426          		//设置DMA的优先级别  
    427          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;  
    428          		//设置DMA的2个memory中的变量互相访问  
    429          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;  
    430          		DMA_Init(DMA1_Channel3,&DMA_InitStructure);  
    431          
    432          		//使能DMA1通道3 
    433          		DMA_Cmd(DMA1_Channel3,ENABLE);  
    434          
    435          		//采用DMA方式接收  
    436          		USART_DMACmd(USART3,USART_DMAReq_Rx,ENABLE); 
    437          
    438          		/* Enable USART3 DMA Tx request */
    439          		USART_DMACmd(USART3, USART_DMAReq_Tx , ENABLE);
    440          
    441          		USART_Cmd(USART3, ENABLE);
    442          	}
    443          #endif
    444          #if(BT_MODULE_CONFIG & USE_BT4_MODULE)
    445          	if (bt_channel == BT4_MODULE)
    446          	{
    447          		//UART4
    448          		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE);
    449          		RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
    450          
    451          		//B-Reset  PD.1		B-Busy	PD.0
    452          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_0 | GPIO_Pin_1;
    453          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    454          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_Out_PP;
    455          		GPIO_Init(GPIOD, &GPIO_InitStructure);
    456          		GPIO_SetBits(GPIOD, GPIO_Pin_1);
    457          		GPIO_ResetBits(GPIOD, GPIO_Pin_0);
    458          
    459          		//B-State  PD.3
    460          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_3;
    461          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    462          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IPD;
    463          		GPIO_Init(GPIOD, &GPIO_InitStructure);
    464          
    465          		// 使用UART4, PC11,PC10
    466          		/* Configure UART4 Tx (PC.10) as alternate function push-pull */
    467          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_10;
    468          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_50MHz;
    469          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_AF_PP;
    470          		GPIO_Init(GPIOC, &GPIO_InitStructure);
    471          
    472          		/* Configure UART4 Rx (PC.11) as input floating				*/
    473          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_11;
    474          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IN_FLOATING;
    475          		GPIO_Init(GPIOC, &GPIO_InitStructure);
    476          
    477          		USART_InitStructure.USART_BaudRate		= baudrate;					
    478          		USART_InitStructure.USART_WordLength	= USART_WordLength_8b;
    479          		USART_InitStructure.USART_StopBits		= USART_StopBits_1;
    480          		USART_InitStructure.USART_Parity		= USART_Parity_No;
    481          		USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    482          		USART_InitStructure.USART_Mode			= USART_Mode_Rx | USART_Mode_Tx;
    483          
    484          		USART_Init(UART4, &USART_InitStructure);
    485          
    486          
    487          		/* DMA clock enable */
    488          		RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA2, ENABLE);
    489          
    490          		/* fill init structure */
    491          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    492          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    493          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    494          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
    495          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
    496          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
    497          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    498          
    499          		/* DMA2 Channel5 (triggered by UART4 Tx event) Config */
    500          		DMA_DeInit(DMA2_Channel5);
    501          		DMA_InitStructure.DMA_PeripheralBaseAddr =(u32)(&UART4->DR);
    502          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
    503          		/* As we will set them before DMA actually enabled, the DMA_MemoryBaseAddr
    504          		* and DMA_BufferSize are meaningless. So just set them to proper values
    505          		* which could make DMA_Init happy.
    506          		*/
    507          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)0;
    508          		DMA_InitStructure.DMA_BufferSize = 1;
    509          		DMA_Init(DMA2_Channel5, &DMA_InitStructure);
    510          
    511          
    512          		//DMA2通道3配置  
    513          		DMA_DeInit(DMA2_Channel3);  
    514          		//外设地址  
    515          		DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)(&UART4->DR);  
    516          		//内存地址  
    517          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)BT816_recbuffer[BT4_MODULE];  
    518          		//dma传输方向单向  
    519          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;  
    520          		//设置DMA在传输时缓冲区的长度  
    521          		DMA_InitStructure.DMA_BufferSize = BT816_RES_BUFFER_LEN;  
    522          		//设置DMA的外设递增模式，一个外设  
    523          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;  
    524          		//设置DMA的内存递增模式  
    525          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;  
    526          		//外设数据字长  
    527          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;  
    528          		//内存数据字长  
    529          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;  
    530          		//设置DMA的传输模式  
    531          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;  
    532          		//设置DMA的优先级别  
    533          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;  
    534          		//设置DMA的2个memory中的变量互相访问  
    535          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;  
    536          		DMA_Init(DMA2_Channel3,&DMA_InitStructure);  
    537          
    538          		//使能DMA2通道3 
    539          		DMA_Cmd(DMA2_Channel3,ENABLE);  
    540          
    541          		//采用DMA方式接收  
    542          		USART_DMACmd(UART4,USART_DMAReq_Rx,ENABLE); 
    543          
    544          		/* Enable UART4 DMA Tx request */
    545          		USART_DMACmd(UART4, USART_DMAReq_Tx , ENABLE);
    546          
    547          		USART_Cmd(UART4, ENABLE);
    548          	}
    549          #endif
    550          }
    551          
    552          /*
    553          * @brief: 串口中断的初始化
    554          */
    555          static void BT816_NVIC_config(unsigned int bt_channel)
    556          {
    557          	NVIC_InitTypeDef				NVIC_InitStructure;
    558          #if(BT_MODULE_CONFIG & USE_BT1_MODULE)
    559          	if (bt_channel == BT1_MODULE)
    560          	{
    561          		//中断配置  
    562          		USART_ITConfig(USART1,USART_IT_TC,DISABLE);  
    563          		USART_ITConfig(USART1,USART_IT_RXNE,DISABLE);  
    564          		USART_ITConfig(USART1,USART_IT_IDLE,ENABLE);    
    565          
    566          		//配置UART4中断  
    567          		//NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
    568          		NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQChannel;               //通道设置为串口2中断    
    569          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;       //中断占先等级1    
    570          		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;              //中断响应优先级0    
    571          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                 //打开中断    
    572          		NVIC_Init(&NVIC_InitStructure);  
    573          
    574          		/* Enable the DMA1 Channel4 Interrupt */
    575          		NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel4_IRQChannel;
    576          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    577          		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    578          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    579          		NVIC_Init(&NVIC_InitStructure);
    580          
    581          		DMA_ITConfig(DMA1_Channel4, DMA_IT_TC | DMA_IT_TE, ENABLE);
    582          		DMA_ClearFlag(DMA1_FLAG_TC4);
    583          	}
    584          #endif
    585          
    586          #if(BT_MODULE_CONFIG & USE_BT2_MODULE)
    587          	if (bt_channel == BT2_MODULE)
    588          	{
    589          		//中断配置  
    590          		USART_ITConfig(USART2,USART_IT_TC,DISABLE);  
    591          		USART_ITConfig(USART2,USART_IT_RXNE,DISABLE);  
    592          		USART_ITConfig(USART2,USART_IT_IDLE,ENABLE);    
    593          
    594          		//配置USART2中断  
    595          		//NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
    596          		NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQChannel;               //通道设置为串口2中断    
    597          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;       //中断占先等级1    
    598          		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;              //中断响应优先级0    
    599          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                 //打开中断    
    600          		NVIC_Init(&NVIC_InitStructure);  
    601          
    602          		/* Enable the DMA1 Channel7 Interrupt */
    603          		NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel7_IRQChannel;
    604          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    605          		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    606          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    607          		NVIC_Init(&NVIC_InitStructure);
    608          
    609          		DMA_ITConfig(DMA1_Channel7, DMA_IT_TC | DMA_IT_TE, ENABLE);
    610          		DMA_ClearFlag(DMA1_FLAG_TC7);
    611          	}
    612          #endif
    613          
    614          #if(BT_MODULE_CONFIG & USE_BT3_MODULE)
    615          	if (bt_channel == BT3_MODULE)
    616          	{
    617          		//中断配置  
    618          		USART_ITConfig(USART3,USART_IT_TC,DISABLE);  
    619          		USART_ITConfig(USART3,USART_IT_RXNE,DISABLE);  
    620          		USART_ITConfig(USART3,USART_IT_IDLE,ENABLE);    
    621          
    622          		//配置USART3中断  
    623          		//NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
    624          		NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQChannel;               //通道设置为串口2中断    
    625          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;       //中断占先等级1    
    626          		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;              //中断响应优先级0    
    627          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                 //打开中断    
    628          		NVIC_Init(&NVIC_InitStructure);  
    629          
    630          		/* Enable the DMA1 Channel2 Interrupt */
    631          		NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel2_IRQChannel;
    632          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    633          		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    634          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    635          		NVIC_Init(&NVIC_InitStructure);
    636          
    637          		DMA_ITConfig(DMA1_Channel2, DMA_IT_TC | DMA_IT_TE, ENABLE);
    638          		DMA_ClearFlag(DMA1_FLAG_TC2);
    639          	}
    640          #endif
    641          
    642          #if(BT_MODULE_CONFIG & USE_BT4_MODULE)
    643          	if (bt_channel == BT4_MODULE)
    644          	{
    645          		//中断配置  
    646          		USART_ITConfig(UART4,USART_IT_TC,DISABLE);  
    647          		USART_ITConfig(UART4,USART_IT_RXNE,DISABLE);  
    648          		USART_ITConfig(UART4,USART_IT_IDLE,ENABLE);    
    649          
    650          		//配置UART4中断  
    651          		//NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
    652          		NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQChannel;               //通道设置为串口2中断    
    653          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;       //中断占先等级1    
    654          		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;              //中断响应优先级0    
    655          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                 //打开中断    
    656          		NVIC_Init(&NVIC_InitStructure);  
    657          
    658          		/* Enable the DMA2 Channel5 Interrupt */
    659          		NVIC_InitStructure.NVIC_IRQChannel = DMA2_Channel4_5_IRQChannel;
    660          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    661          		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    662          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    663          		NVIC_Init(&NVIC_InitStructure);
    664          
    665          		DMA_ITConfig(DMA2_Channel5, DMA_IT_TC | DMA_IT_TE, ENABLE);
    666          		DMA_ClearFlag(DMA2_FLAG_TC5);
    667          	}
    668          #endif
    669          }
    670          
    671          
    672          /**
    673          * @brief  发数据给蓝牙模块
    674          * @param[in] unsigned char *pData 要发送的数据
    675          * @param[in] int length 要发送数据的长度
    676          */
    677          static void send_data_to_BT(unsigned int bt_channel,const unsigned char *pData, unsigned int length)
    678          {
    679          #if(BT_MODULE_CONFIG & USE_BT1_MODULE)
    680          	if (bt_channel == BT1_MODULE)
    681          	{
    682          		//while(length--)
    683          		//{
    684          		//	USART_SendData(USART1, *pData++);
    685          		//	while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET)
    686          		//	{
    687          		//	}
    688          		//}
    689          		//while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET){};
    690          
    691          		/* disable DMA */
    692          		DMA_Cmd(DMA1_Channel4, DISABLE);
    693          
    694          		/* set buffer address */
    695          		memcpy(BT816_send_buff[BT1_MODULE],pData,length);
    696          
    697          		DMA1_Channel4->CMAR = (u32)&BT816_send_buff[BT1_MODULE][0];
    698          		/* set size */
    699          		DMA1_Channel4->CNDTR = length;
    700          
    701          		USART_DMACmd(USART1, USART_DMAReq_Tx , ENABLE);
    702          		/* enable DMA */
    703          		DMA_Cmd(DMA1_Channel4, ENABLE);
    704          
    705          		while(DMA1_Channel4->CNDTR);
    706          		while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET){};
    707          	}
    708          #endif
    709          
    710          #if(BT_MODULE_CONFIG & USE_BT2_MODULE)
    711          	if (bt_channel == BT2_MODULE)
    712          	{
    713          		//while(length--)
    714          		//{
    715          		//	USART_SendData(USART2, *pData++);
    716          		//	while(USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET)
    717          		//	{
    718          		//	}
    719          		//}
    720          		//while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET){};
    721          
    722          		/* disable DMA */
    723          		DMA_Cmd(DMA1_Channel7, DISABLE);
    724          
    725          		/* set buffer address */
    726          		memcpy(BT816_send_buff[BT2_MODULE],pData,length);
    727          
    728          		DMA1_Channel7->CMAR = (u32)&BT816_send_buff[BT2_MODULE][0];
    729          		/* set size */
    730          		DMA1_Channel7->CNDTR = length;
    731          
    732          		USART_DMACmd(USART2, USART_DMAReq_Tx , ENABLE);
    733          		/* enable DMA */
    734          		DMA_Cmd(DMA1_Channel7, ENABLE);
    735          
    736          		while(DMA1_Channel7->CNDTR);
    737          		while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET){};
    738          	}
    739          #endif
    740          
    741          #if(BT_MODULE_CONFIG & USE_BT3_MODULE)
    742          	if (bt_channel == BT3_MODULE)
    743          	{
    744          		//while(length--)
    745          		//{
    746          		//	USART_SendData(USART3, *pData++);
    747          		//	while(USART_GetFlagStatus(USART3, USART_FLAG_TXE) == RESET)
    748          		//	{
    749          		//	}
    750          		//}
    751          		//while(USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET){};
    752          
    753          		/* disable DMA */
    754          		DMA_Cmd(DMA1_Channel2, DISABLE);
    755          
    756          		/* set buffer address */
    757          		memcpy(BT816_send_buff[BT3_MODULE],pData,length);
    758          
    759          		DMA1_Channel2->CMAR = (u32)&BT816_send_buff[BT3_MODULE][0];
    760          		/* set size */
    761          		DMA1_Channel2->CNDTR = length;
    762          
    763          		USART_DMACmd(USART3, USART_DMAReq_Tx , ENABLE);
    764          		/* enable DMA */
    765          		DMA_Cmd(DMA1_Channel2, ENABLE);
    766          
    767          		while(DMA1_Channel2->CNDTR);
    768          		while(USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET){};
    769          	}
    770          #endif
    771          #if(BT_MODULE_CONFIG & USE_BT4_MODULE)
    772          	if (bt_channel == BT4_MODULE)
    773          	{
    774          	//while(length--)
    775          	//{
    776          	//	USART_SendData(UART4, *pData++);
    777          	//	while(USART_GetFlagStatus(UART4, USART_FLAG_TXE) == RESET)
    778          	//	{
    779          	//	}
    780          	//}
    781          	//while(USART_GetFlagStatus(UART4, USART_FLAG_TC) == RESET){};
    782          
    783          	/* disable DMA */
    784          	DMA_Cmd(DMA2_Channel5, DISABLE);
    785          
    786          	/* set buffer address */
    787          	memcpy(BT816_send_buff[BT4_MODULE],pData,length);
    788          
    789          	DMA2_Channel5->CMAR = (u32)&BT816_send_buff[BT4_MODULE][0];
    790          	/* set size */
    791          	DMA2_Channel5->CNDTR = length;
    792          
    793          	USART_DMACmd(UART4, USART_DMAReq_Tx , ENABLE);
    794          	/* enable DMA */
    795          	DMA_Cmd(DMA2_Channel5, ENABLE);
    796          
    797          	while(DMA2_Channel5->CNDTR);
    798          	while(USART_GetFlagStatus(UART4, USART_FLAG_TC) == RESET){};
    799          	}
    800          #endif
    801          }
    802          
    803          
    804          /*
    805           * @brief 清空接收蓝牙模块响应数据的buffer
    806          */
    807          static void BT816_reset_resVar(unsigned int bt_channel)
    808          {
    809          #if(BT_MODULE_CONFIG & USE_BT1_MODULE)
    810          	if (bt_channel == BT1_MODULE)
    811          	{
    812          		BT816_res[bt_channel].DataPos = 0;
    813          		BT816_res[bt_channel].DataLength = 0;
    814          		BT816_res[bt_channel].status	 = BT816_RES_INIT;
    815          		bt_connect_status &= ~(1<<BT1_MODULE);
    816          		DMA1_Channel5->CNDTR = BT816_RES_BUFFER_LEN; 
    817          	}
    818          #endif
    819          
    820          #if(BT_MODULE_CONFIG & USE_BT2_MODULE)
    821          	if (bt_channel == BT2_MODULE)
    822          	{
    823          		BT816_res[bt_channel].DataPos = 0;
    824          		BT816_res[bt_channel].DataLength = 0;
    825          		BT816_res[bt_channel].status	 = BT816_RES_INIT;
    826          		bt_connect_status &= ~(1<<BT2_MODULE);
    827          		DMA1_Channel6->CNDTR = BT816_RES_BUFFER_LEN; 
    828          	}
    829          #endif
    830          
    831          #if(BT_MODULE_CONFIG & USE_BT3_MODULE)
    832          	if (bt_channel == BT3_MODULE)
    833          	{
    834          		BT816_res[bt_channel].DataPos = 0;
    835          		BT816_res[bt_channel].DataLength = 0;
    836          		BT816_res[bt_channel].status	 = BT816_RES_INIT;
    837          		bt_connect_status &= ~(1<<BT3_MODULE);
    838          		DMA1_Channel3->CNDTR = BT816_RES_BUFFER_LEN; 
    839          	}
    840          #endif
    841          
    842          #if(BT_MODULE_CONFIG & USE_BT4_MODULE)
    843          	if (bt_channel == BT4_MODULE)
    844          	{
    845          	BT816_res[bt_channel].DataPos = 0;
    846          	BT816_res[bt_channel].DataLength = 0;
    847          	BT816_res[bt_channel].status	 = BT816_RES_INIT;
    848          	bt_connect_status &= ~(1<<BT4_MODULE);
    849          	DMA2_Channel3->CNDTR = BT816_RES_BUFFER_LEN;
    850          	}
    851          #endif
    852          }
    853          
    854          
    855          /**
    856          * @brief 处理host收到BT816的数据
    857          * @param[in] unsigned char c 读入的字符
    858          * @return 0:success put in buffer
    859          *        -1:fail
    860          */
    861          #if(BT_MODULE_CONFIG & USE_BT1_MODULE)
    862          int BT816_Channel1_RxISRHandler(unsigned char *res, unsigned int res_len)
    863          {	
    864          	int i,len;
    865          	if (BT1_CONNECT)
    866          	{
    867          		//已经处于连接状态，蓝牙模块进入数据透传模式
    868          		set_BT1_BUSY();
    869          		ringbuffer_put(&spp_ringbuf[BT1_MODULE],res,res_len);
    870          #ifdef DEBUG_VER
    871          		//memcpy(debug_buffer+debug_cnt,res,res_len);
    872          		//debug_cnt += res_len;
    873          #endif
    874          		DMA1_Channel5->CNDTR = BT816_RES_BUFFER_LEN;
    875          		if (ringbuffer_data_len(&spp_ringbuf[BT1_MODULE]) < RING_BUFF_FULL_TH)
    876          		{
    877          			set_BT1_FREE();
    878          		}	
    879          	}
    880          	else
    881          	{
    882          		if (res_len > 5)
    883          		{
    884          			BT816_res[BT1_MODULE].DataLength = res_len;
    885          			if ((res[0] == 0x0d)&&(res[1] == 0x0a)			\
    886          				&&(res[res_len-2] == 0x0d)&&(res[res_len-1] == 0x0a))
    887          			{
    888          				if (BT816_res[BT1_MODULE].status == BT816_RES_INIT)
    889          				{
    890          					BT816_res[BT1_MODULE].status = BT816_RES_INVALID_STATE;
    891          					for (i = 3; i < res_len-2;i++)
    892          					{
    893          
    894          						if ((res[i] == 'o')&&(res[i+1] == 'k'))
    895          						{
    896          							BT816_res[BT1_MODULE].status = BT816_RES_SUCCESS;
    897          							break;
    898          						}
    899          
    900          						if (res[i] == '=')
    901          						{
    902          							BT816_res[BT1_MODULE].status = BT816_RES_PAYLOAD;
    903          							break;
    904          						}
    905          					}
    906          				}
    907          			}
    908          			else
    909          			{
    910          				BT816_res[BT1_MODULE].status = BT816_RES_UNKOWN;
    911          			}
    912          		}
    913          	}
    914          	
    915                  
    916                  return 0;
    917          }
    918          #endif
    919          
    920          #if(BT_MODULE_CONFIG & USE_BT2_MODULE)
    921          int BT816_Channel2_RxISRHandler(unsigned char *res, unsigned int res_len)
    922          {	
    923          	int i,len;
    924          
    925          	if (BT2_CONNECT)
    926          	{
    927          		//已经处于连接状态，蓝牙模块进入数据透传模式
    928          		set_BT2_BUSY();
    929          		ringbuffer_put(&spp_ringbuf[BT2_MODULE],res,res_len);
    930          		DMA1_Channel6->CNDTR = BT816_RES_BUFFER_LEN;
    931          		if (ringbuffer_data_len(&spp_ringbuf[BT2_MODULE]) < RING_BUFF_FULL_TH)
    932          		{
    933          			set_BT2_FREE();
    934          		}
    935          	}
    936          	else
    937          	{
    938          		if (res_len > 5)
    939          		{
    940          			BT816_res[BT2_MODULE].DataLength = res_len;
    941          			if ((res[0] == 0x0d)&&(res[1] == 0x0a)			\
    942          				&&(res[res_len-2] == 0x0d)&&(res[res_len-1] == 0x0a))
    943          			{
    944          				if (BT816_res[BT2_MODULE].status == BT816_RES_INIT)
    945          				{
    946          					BT816_res[BT2_MODULE].status = BT816_RES_INVALID_STATE;
    947          					for (i = 3; i < res_len-2;i++)
    948          					{
    949          
    950          						if ((res[i] == 'o')&&(res[i+1] == 'k'))
    951          						{
    952          							BT816_res[BT2_MODULE].status = BT816_RES_SUCCESS;
    953          							break;
    954          						}
    955          
    956          						if (res[i] == '=')
    957          						{
    958          							BT816_res[BT2_MODULE].status = BT816_RES_PAYLOAD;
    959          							break;
    960          						}
    961          					}
    962          				}
    963          			}
    964          			else
    965          			{
    966          				BT816_res[BT2_MODULE].status = BT816_RES_UNKOWN;
    967          			}
    968          		}
    969          	}
    970          
    971          
    972          	return 0;
    973          }
    974          #endif
    975          
    976          #if(BT_MODULE_CONFIG & USE_BT3_MODULE)
    977          int BT816_Channel3_RxISRHandler(unsigned char *res, unsigned int res_len)
    978          {	
    979          	int i,len;
    980          	if (BT3_CONNECT)
    981          	{
    982          		//已经处于连接状态，蓝牙模块进入数据透传模式
    983          		set_BT3_BUSY();
    984          		ringbuffer_put(&spp_ringbuf[BT3_MODULE],res,res_len);
    985          		DMA1_Channel3->CNDTR = BT816_RES_BUFFER_LEN;
    986          		if (ringbuffer_data_len(&spp_ringbuf[BT3_MODULE]) < RING_BUFF_FULL_TH)
    987          		{
    988          			set_BT3_FREE();
    989          		}
    990          	}
    991          	else
    992          	{
    993          		if (res_len > 5)
    994          		{
    995          			BT816_res[BT3_MODULE].DataLength = res_len;
    996          			if ((res[0] == 0x0d)&&(res[1] == 0x0a)			\
    997          				&&(res[res_len-2] == 0x0d)&&(res[res_len-1] == 0x0a))
    998          			{
    999          				if (BT816_res[BT3_MODULE].status == BT816_RES_INIT)
   1000          				{
   1001          					BT816_res[BT3_MODULE].status = BT816_RES_INVALID_STATE;
   1002          					for (i = 3; i < res_len-2;i++)
   1003          					{
   1004          
   1005          						if ((res[i] == 'o')&&(res[i+1] == 'k'))
   1006          						{
   1007          							BT816_res[BT3_MODULE].status = BT816_RES_SUCCESS;
   1008          							break;
   1009          						}
   1010          
   1011          						if (res[i] == '=')
   1012          						{
   1013          							BT816_res[BT3_MODULE].status = BT816_RES_PAYLOAD;
   1014          							break;
   1015          						}
   1016          					}
   1017          				}
   1018          			}
   1019          			else
   1020          			{
   1021          				BT816_res[BT3_MODULE].status = BT816_RES_UNKOWN;
   1022          			}
   1023          		}
   1024          	}
   1025          
   1026          
   1027          	return 0;
   1028          }
   1029          #endif
   1030          
   1031          #if(BT_MODULE_CONFIG & USE_BT4_MODULE)
   1032          int BT816_Channel4_RxISRHandler(unsigned char *res, unsigned int res_len)
   1033          {	
   1034          	int i,len;
   1035          
   1036          	if (BT4_CONNECT)
   1037          	{
   1038          		//已经处于连接状态，蓝牙模块进入数据透传模式
   1039          		set_BT4_BUSY();
   1040          		ringbuffer_put(&spp_ringbuf[BT4_MODULE],res,res_len);
   1041          		DMA2_Channel3->CNDTR = BT816_RES_BUFFER_LEN;
   1042          		if (ringbuffer_data_len(&spp_ringbuf[BT4_MODULE]) < RING_BUFF_FULL_TH)
   1043          		{
   1044          			set_BT4_FREE();
   1045          		}
   1046          	}
   1047          	else
   1048          	{
   1049          		if (res_len > 5)
   1050          		{
   1051          			BT816_res[BT4_MODULE].DataLength = res_len;
   1052          			if ((res[0] == 0x0d)&&(res[1] == 0x0a)			\
   1053          				&&(res[res_len-2] == 0x0d)&&(res[res_len-1] == 0x0a))
   1054          			{
   1055          				if (BT816_res[BT4_MODULE].status == BT816_RES_INIT)
   1056          				{
   1057          					BT816_res[BT4_MODULE].status = BT816_RES_INVALID_STATE;
   1058          					for (i = 3; i < res_len-2;i++)
   1059          					{
   1060          
   1061          						if ((res[i] == 'o')&&(res[i+1] == 'k'))
   1062          						{
   1063          							BT816_res[BT4_MODULE].status = BT816_RES_SUCCESS;
   1064          							break;
   1065          						}
   1066          
   1067          						if (res[i] == '=')
   1068          						{
   1069          							BT816_res[BT4_MODULE].status = BT816_RES_PAYLOAD;
   1070          							break;
   1071          						}
   1072          					}
   1073          				}
   1074          			}
   1075          			else
   1076          			{
   1077          				BT816_res[BT4_MODULE].status = BT816_RES_UNKOWN;
   1078          			}
   1079          		}
   1080          	}
   1081          
   1082          
   1083          	return 0;
   1084          }
   1085          #endif
   1086          #define EXPECT_RES_FORMAT1_TYPE		1		//设置命令的响应，OK or Error
   1087          #define EXPECT_RES_FORMAT2_TYPE		2		//查询命令的响应，payload
   1088          
   1089          /**
   1090          * @brief  发命令给蓝牙模块BT816S01,并等待响应结果
   1091          * @param[in] unsigned char *pData 要发送的数据
   1092          * @param[in] unsigned int	length 要发送数据的长度
   1093          * @param[in] unsigned char  type   期待响应数据的命令类型	
   1094          *							EXPECT_RES_FORMAT1_TYPE: response format1		
   1095          *							EXPECT_RES_FORMAT2_TYPE:response format2
   1096          * @return		0: 成功
   1097          *				-1: 失败
   1098          *				-2: 未知响应，可能是响应解析函数有BUG，需要调试
   1099          *				-3：响应超时
   1100          * @note	等待一个响应帧的命令
   1101          */
   1102          static int BT816_write_cmd(unsigned int bt_channel,const unsigned char *pData, unsigned int length,unsigned char type)
   1103          {
   1104          	unsigned int	wait_cnt;
   1105          	send_data_to_BT(bt_channel,pData, length);
   1106          	BT816_reset_resVar(bt_channel);
   1107          	wait_cnt = 200;
   1108          	while (wait_cnt)
   1109          	{
   1110          		if (((BT816_res[bt_channel].status == BT816_RES_SUCCESS)&&(type == EXPECT_RES_FORMAT1_TYPE)) || ((BT816_res[bt_channel].status == BT816_RES_PAYLOAD)&&(type == EXPECT_RES_FORMAT2_TYPE)))
   1111          		{
   1112          			return 0;
   1113          		}
   1114          		else if(BT816_res[bt_channel].status == BT816_RES_INVALID_STATE)
   1115          		{
   1116          			return -1;
   1117          		}
   1118          		//OSTimeDlyHMSM(0,0,0,20);
   1119          		delay_ms(20);
   1120                          wait_cnt--;
   1121          	}
   1122          
   1123          	return -3;
   1124          }
   1125          
   1126          
   1127          //const unsigned char	*query_version_cmd="AT+VER=?";
   1128          //const unsigned char	*set_device_name_cmd="AT+DNAME=%s";
   1129          static unsigned char	token[10],token_value[15];
   1130          /*
   1131           * @brief 蓝牙模块BT816S01的复位
   1132          */
   1133          int BT816_Reset(void)
   1134          {
   1135          	unsigned int	wait_cnt,i,j;
   1136          	unsigned char	stat;
   1137          	int ret;
   1138          
   1139          #if(BT_MODULE_CONFIG & USE_BT1_MODULE)
   1140          	//拉低复位信号100ms
   1141          	GPIO_ResetBits(GPIOB, GPIO_Pin_9);
   1142          	delay_ms(100);
   1143              GPIO_SetBits(GPIOB, GPIO_Pin_9);
   1144          
   1145          	BT816_reset_resVar(BT1_MODULE);
   1146          #endif
   1147          
   1148          #if(BT_MODULE_CONFIG & USE_BT2_MODULE)
   1149          	//拉低复位信号100ms
   1150          	GPIO_ResetBits(GPIOC, GPIO_Pin_3);
   1151          	delay_ms(100);
   1152          	GPIO_SetBits(GPIOC, GPIO_Pin_3);
   1153          
   1154          	BT816_reset_resVar(BT2_MODULE);
   1155          #endif
   1156          
   1157          #if(BT_MODULE_CONFIG & USE_BT3_MODULE)
   1158          	//拉低复位信号100ms
   1159          	GPIO_ResetBits(GPIOE, GPIO_Pin_13);
   1160          	delay_ms(100);
   1161          	GPIO_SetBits(GPIOE, GPIO_Pin_13);
   1162          
   1163          	BT816_reset_resVar(BT3_MODULE);
   1164          #endif
   1165          
   1166          #if(BT_MODULE_CONFIG & USE_BT4_MODULE)
   1167          	//拉低复位信号100ms
   1168          	GPIO_ResetBits(GPIOD, GPIO_Pin_1);
   1169          	delay_ms(100);
   1170          	GPIO_SetBits(GPIOD, GPIO_Pin_1);
   1171          
   1172          	BT816_reset_resVar(BT4_MODULE);
   1173          #endif
   1174          #if 0
   1175          	wait_cnt = 20;
   1176          	ret = 0;
   1177          	while (wait_cnt)
   1178          	{
   1179          		if (BT816_res[].status == BT816_RES_PAYLOAD)
   1180          		{
   1181          			USART_Cmd(UART4, DISABLE);
   1182          			stat = 0;
   1183          			for (i = 0; i < BT816_res.DataLength;i++)
   1184          			{
   1185          				if (BT816_res.DataBuffer[i] == '+')
   1186          				{
   1187          					stat = 1;
   1188          					j = 0;
   1189          					continue;
   1190          				}
   1191          				else if (BT816_res.DataBuffer[i] == '=')
   1192          				{
   1193          					stat = 2;
   1194          					j = 0;
   1195          					continue;
   1196          				}
   1197          				else if (BT816_res.DataBuffer[i] == 0x0d)
   1198          				{
   1199          					if (stat == 2)
   1200          					{
   1201          						if (memcmp(token,"BDTP",4)==0)
   1202          						{
   1203          							if (token_value[0] != '0')
   1204          							{
   1205          								ret |= 0x01;
   1206          							}
   1207          						}
   1208          #ifdef DEBUG_VER
   1209          						else if (memcmp(token,"BDVER",5)==0)
   1210          						{
   1211          							token_value[j]=0;
   1212          							printf("BlueTooth Module Ver:%s\r\n",token_value);
   1213          						}
   1214          						else if (memcmp(token,"BDADDR",6)==0)
   1215          						{
   1216          							token_value[j]=0;
   1217          							printf("BlueTooth Module Addr:%s\r\n",token_value);
   1218          						}
   1219          #endif
   1220          						else if (memcmp(token,"BDMODE",6)==0)
   1221          						{
   1222          #ifdef HID_MODE
   1223          							if (token_value[0] != '2')
   1224          							{
   1225          								ret |= 0x02;
   1226          							}
   1227          #else
   1228          							if (token_value[0] != '1')
   1229          							{
   1230          								ret |= 0x02;
   1231          							}
   1232          #endif
   1233          						}
   1234          					}
   1235          					stat = 0;
   1236          					continue;
   1237          				}
   1238          
   1239          				if (stat == 1)
   1240          				{
   1241          					token[j] = BT816_res.DataBuffer[i];
   1242          					j++;
   1243          				}
   1244          				else if (stat == 2)
   1245          				{
   1246          					token_value[j] = BT816_res.DataBuffer[i];
   1247          					j++;
   1248          				}
   1249          			} 
   1250          			USART_Cmd(UART4, ENABLE);
   1251          			return ret;
   1252          		}
   1253          		//OSTimeDlyHMSM(0,0,0,100);
   1254                          wait_cnt--;
   1255                          delay_ms(100);
   1256          	}
   1257          
   1258          	return -1;
   1259          #endif
   1260          
   1261          	delay_ms(1000);
   1262          	return 0;
   1263          }
   1264          
   1265          /*
   1266           * @brief 查询蓝牙模块BT816的版本号
   1267           * @param[out]  unsigned char *ver_buffer  返回查询到的版本号，如果为空表示查询失败
   1268          */
   1269          int BT816_query_version(unsigned int bt_channel,unsigned char *ver_buffer)
   1270          {
   1271          	unsigned char	buffer[21];
   1272          	int		i,ret;
   1273          
   1274          	assert(ver_buffer != 0);
   1275          	ver_buffer[0] = 0;
   1276          	memcpy(buffer,"AT+VER\x0d\x0a",8);
   1277          	ret = BT816_write_cmd(bt_channel,(const unsigned char*)buffer,8,EXPECT_RES_FORMAT2_TYPE);
   1278          	if (ret)
   1279          	{
   1280          		return ret;
   1281          	}
   1282          
   1283          	if (memcmp(&BT816_res[bt_channel].DataBuffer[3],"VER=",4) == 0)
   1284          	{
   1285          		for (i = 0; i < ((BT816_res[bt_channel].DataLength-9) > 20)?20:(BT816_res[bt_channel].DataLength-9);i++)
   1286          		{
   1287          			if (BT816_res[bt_channel].DataBuffer[7+i] == 0x0d)
   1288          			{
   1289          				break;
   1290          			}
   1291          
   1292          			ver_buffer[i] = BT816_res[bt_channel].DataBuffer[7+i];
   1293          		}
   1294          		ver_buffer[i] = 0;
   1295          		return 0;
   1296          	}
   1297          
   1298          	return -1;
   1299          }
   1300          
   1301          
   1302          /*
   1303           * @brief 查询蓝牙模块的设备名称
   1304           * @param[out]  unsigned char *name  模块名称,字符串
   1305           * @return 0: 查询成功		else：查询失败
   1306           * @note 从手册暂时没有看到支持的名称的最大长度是多少，所以如果设置的名称太长可能会导致缓冲区溢出
   1307           *       在此接口中将设备名称限定为最长支持20个字节
   1308          */
   1309          int BT816_query_name(unsigned int bt_channel,unsigned char *name)
   1310          {
   1311          	unsigned char	buffer[15];
   1312          	int		i,ret;
   1313          
   1314          	assert(name != 0);
   1315          	name[0] = 0;
   1316          	memcpy(buffer,"AT+NAME\x0d\x0a",9);
   1317          
   1318          	ret = BT816_write_cmd(bt_channel,(const unsigned char*)buffer,9,EXPECT_RES_FORMAT2_TYPE);
   1319          	if (ret)
   1320          	{
   1321          		return ret;
   1322          	}
   1323          
   1324          	if (memcmp(&BT816_res[bt_channel].DataBuffer[3],"NAME",4) == 0)
   1325          	{
   1326          		for (i = 0; i < ((BT816_res[bt_channel].DataLength-10) > 20)?20:(BT816_res[bt_channel].DataLength-10);i++)
   1327          		{
   1328          			if (BT816_res[bt_channel].DataBuffer[8+i] == 0x0d)
   1329          			{
   1330          				break;
   1331          			}
   1332          
   1333          			name[i] = BT816_res[bt_channel].DataBuffer[8+i];
   1334          		}
   1335          		name[i] = 0;
   1336          		return 0;
   1337          	}
   1338          
   1339          	return -1; 
   1340          }
   1341          
   1342          /*
   1343           * @brief 查询和设置蓝牙模块的设备名称
   1344           * @param[in]  unsigned char *name  设置的名称,字符串
   1345           * @return 0: 设置成功		else：设置失败
   1346           * @note 从手册暂时没有看到支持的名称的最大长度是多少，所以如果设置的名称太长可能会设置失败
   1347           *       在此接口中将设备名称限定为最长支持22个字节
   1348          */
   1349          int BT816_set_name(unsigned int bt_channel,unsigned char *name)
   1350          {
   1351          	unsigned char	buffer[33];
   1352          	int		len;
   1353          
   1354          	assert(name != 0);
   1355          	memcpy(buffer,"AT+NAME=",8);
   1356          	len = strlen((char const*)name);
   1357          	if (len>22)
   1358          	{
   1359          		memcpy(buffer+8,name,22);
   1360          		buffer[30] = 0x0d;
   1361          		buffer[31] = 0x0a;
   1362          		len = 32;
   1363          	}
   1364          	else
   1365          	{
   1366          		memcpy(buffer+8,name,len);
   1367          		buffer[8+len] = 0x0d;
   1368          		buffer[9+len] = 0x0a;
   1369          		len += 10;
   1370          	}
   1371          
   1372          	return BT816_write_cmd(bt_channel,(const unsigned char*)buffer,len,EXPECT_RES_FORMAT1_TYPE); 
   1373          }
   1374          
   1375          /*
   1376           * @brief 设置蓝牙模块的PIN
   1377           * @param[in]  unsigned char *name  设置的PIN,字符串
   1378           * @return 0: 设置成功		else：设置失败
   1379           * @note 从手册暂时没有看到支持的PIN的最大长度是多少，所以如果设置的PIN太长可能会设置失败
   1380           *       在此接口中将设备名称限定为最长支持8个字节
   1381          */
   1382          int BT816_set_pin(unsigned int bt_channel,unsigned char *pin)
   1383          {
   1384          	unsigned char	buffer[33];
   1385          	int		len;
   1386          
   1387          	assert(pin != 0);
   1388          	memcpy(buffer,"AT+PIN=",7);
   1389          	len = strlen((char const*)pin);
   1390          	if (len>8)
   1391          	{
   1392          		memcpy(buffer+7,pin,8);
   1393          		buffer[15] = 0x0d;
   1394          		buffer[16] = 0x0a;
   1395          		len = 17;
   1396          	}
   1397          	else
   1398          	{
   1399          		memcpy(buffer+7,pin,len);
   1400          		buffer[7+len] = 0x0d;
   1401          		buffer[8+len] = 0x0a;
   1402          		len += 9;
   1403          	}
   1404          
   1405          	return BT816_write_cmd(bt_channel,(const unsigned char*)buffer,len,EXPECT_RES_FORMAT1_TYPE); 
   1406          }
   1407          
   1408          
   1409          /*
   1410           * @brief 查询蓝牙模块HID当前的连接状态  	
   1411           * @return <0 ：发送失败	0: unkown 	1: connected    2： disconnect
   1412           * @note 此函数需要被不断轮询才能正确反应各个模块的连接状态
   1413          */
   1414          int BT816_connect_status(unsigned int bt_channel)
   1415          {
   1416          	unsigned int i;
   1417          #if(BT_MODULE_CONFIG & USE_BT1_MODULE)
   1418          	if (bt_channel == BT1_MODULE)
   1419          	{
   1420          		if(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7))
   1421          		{
   1422          			for (i=0;i < 2000;i++);		//延时一小段时间，防止是因为抖动造成的
   1423          			if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_7))
   1424          			{
   1425          				bt_connect_status |= (1<<BT1_MODULE);
   1426          				return BT_MODULE_STATUS_CONNECTED;
   1427          			}
   1428          			else
   1429          			{
   1430          				bt_connect_status &= ~(1<<BT1_MODULE);
   1431          				return BT_MODULE_STATUS_DISCONNECT;
   1432          			}
   1433          		}
   1434          		else
   1435          		{
   1436          			bt_connect_status &= ~(1<<BT1_MODULE);
   1437          			return BT_MODULE_STATUS_DISCONNECT;
   1438          		}
   1439          	}
   1440          #endif
   1441          
   1442          #if(BT_MODULE_CONFIG & USE_BT2_MODULE)
   1443          	if (bt_channel == BT2_MODULE)
   1444          	{
   1445          		if(GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2))
   1446          		{
   1447          			for (i=0;i < 2000;i++);		//延时一小段时间，防止是因为抖动造成的
   1448          			if(GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_2))
   1449          			{
   1450          				bt_connect_status |= (1<<BT2_MODULE);
   1451          				return BT_MODULE_STATUS_CONNECTED;
   1452          			}
   1453          			else
   1454          			{
   1455          				bt_connect_status &= ~(1<<BT2_MODULE);
   1456          				return BT_MODULE_STATUS_DISCONNECT;
   1457          			}
   1458          		}
   1459          		else
   1460          		{
   1461          			bt_connect_status &= ~(1<<BT2_MODULE);
   1462          			return BT_MODULE_STATUS_DISCONNECT;
   1463          		}
   1464          	}
   1465          #endif
   1466          
   1467          #if(BT_MODULE_CONFIG & USE_BT3_MODULE)
   1468          	if (bt_channel == BT3_MODULE)
   1469          	{
   1470          		if(GPIO_ReadInputDataBit(GPIOE, GPIO_Pin_14))
   1471          		{
   1472          			for (i=0;i < 2000;i++);		//延时一小段时间，防止是因为抖动造成的
   1473          			if(GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_14))
   1474          			{
   1475          				bt_connect_status |= (1<<BT3_MODULE);
   1476          				return BT_MODULE_STATUS_CONNECTED;
   1477          			}
   1478          			else
   1479          			{
   1480          				bt_connect_status &= ~(1<<BT3_MODULE);
   1481          				return BT_MODULE_STATUS_DISCONNECT;
   1482          			}
   1483          		}
   1484          		else
   1485          		{
   1486          			bt_connect_status &= ~(1<<BT3_MODULE);
   1487          			return BT_MODULE_STATUS_DISCONNECT;
   1488          		}
   1489          	}
   1490          #endif
   1491          
   1492          #if(BT_MODULE_CONFIG & USE_BT4_MODULE)
   1493          	if (bt_channel == BT4_MODULE)
   1494          	{
   1495          		if(GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_3))
   1496          		{
   1497          			for (i=0;i < 2000;i++);		//延时一小段时间，防止是因为抖动造成的
   1498          			if(GPIO_ReadInputDataBit(GPIOD,GPIO_Pin_3))
   1499          			{
   1500          				bt_connect_status |= (1<<BT4_MODULE);
   1501          				return BT_MODULE_STATUS_CONNECTED;
   1502          			}
   1503          			else
   1504          			{
   1505          				bt_connect_status &= ~(1<<BT4_MODULE);
   1506          				return BT_MODULE_STATUS_DISCONNECT;
   1507          			}
   1508          		}
   1509          		else
   1510          		{
   1511          			bt_connect_status &= ~(1<<BT4_MODULE);
   1512          			return BT_MODULE_STATUS_DISCONNECT;
   1513          		}
   1514          	}
   1515          #endif
   1516          
   1517          }
   1518          
   1519          /*
   1520           * @brief 通过蓝牙模块的透传模式发送数据到蓝牙主机
   1521          */
   1522          void BT816_send_data(unsigned int bt_channel,unsigned char *data,unsigned int len)
   1523          {
   1524          	if (BT_CONNECT(bt_channel))
   1525          	{
   1526          		send_data_to_BT(bt_channel,data,len);
   1527          	}
   1528          }
   1529          
   1530          /*
   1531           * @brief 蓝牙模块BT816的初始化
   1532          */
   1533          int BT816_init(void)
   1534          {
   1535          	unsigned char	str[21];
   1536          	int ret,i;
   1537          	for (i = 0; i < MAX_BT_CHANNEL;i++)
   1538          	{
   1539          		BT816_res[i].DataBuffer = BT816_recbuffer[i];
   1540          		BT816_reset_resVar(i);
   1541          		//初始化一个SPP的环形缓冲区
   1542          		ringbuffer_init(&spp_ringbuf[i],spp_rec_buffer[i],SPP_BUFFER_LEN);
   1543          
   1544          		BT816_GPIO_config(i,115200);		//default波特率
   1545          		BT816_NVIC_config(i);
   1546          	}
   1547          
   1548          	ret = BT816_Reset();
   1549          	if(ret < 0)
   1550          	{
   1551          		ret = BT816_Reset();
   1552          		if(ret < 0)
   1553          		{
   1554          			return -1;
   1555          		}
   1556          	}
   1557          
   1558          #if 1
   1559          	if (BT816_query_name(BT1_MODULE,str))
   1560          	{
   1561          		return -4;
   1562          	}
   1563          
   1564          	if (memcmp(str,"HJ Pr",5) != 0)
   1565          	{
   1566          		if (BT816_set_name(BT1_MODULE,"HJ Printer1"))
   1567          		{
   1568          			return -5;
   1569          		}
   1570          	}
   1571          
   1572          	if (BT816_query_name(BT2_MODULE,str))
   1573          	{
   1574          		return -4;
   1575          	}
   1576          
   1577          	if (memcmp(str,"HJ Pr",5) != 0)
   1578          	{
   1579          		if (BT816_set_name(BT2_MODULE,"HJ Printer2"))
   1580          		{
   1581          			return -5;
   1582          		}
   1583          	}
   1584          
   1585          	if (BT816_query_name(BT3_MODULE,str))
   1586          	{
   1587          		return -4;
   1588          	}
   1589          
   1590          	if (memcmp(str,"HJ Pr",5) != 0)
   1591          	{
   1592          		if (BT816_set_name(BT3_MODULE,"HJ Printer3"))
   1593          		{
   1594          			return -5;
   1595          		}
   1596          	}
   1597          
   1598          	if (BT816_query_name(BT4_MODULE,str))
   1599          	{
   1600          		return -4;
   1601          	}
   1602          
   1603          	if (memcmp(str,"HJ Pr",5) != 0)
   1604          	{
   1605          		if (BT816_set_name(BT4_MODULE,"HJ Printer4"))
   1606          		{
   1607          			return -5;
   1608          		}
   1609          	}
   1610          
   1611          #endif
   1612          
   1613          	memset(spp_rec_buffer,0,MAX_BT_CHANNEL*SPP_BUFFER_LEN);
   1614          	RESET_BT1_DMA();
   1615          	RESET_BT2_DMA();
   1616          	RESET_BT3_DMA();
   1617          	RESET_BT4_DMA();
   1618          	return 0;
   1619          }
   1620          
   1621          #endif

   Maximum stack usage in bytes:

     Function                    .cstack
     --------                    -------
     BT816_Channel1_RxISRHandler     16
     BT816_Channel2_RxISRHandler     16
     BT816_Channel3_RxISRHandler     16
     BT816_Channel4_RxISRHandler     16
     BT816_GPIO_config               80
     BT816_NVIC_config               16
     BT816_Reset                      8
     BT816_connect_status             8
     BT816_init                      32
     BT816_query_name                32
     BT816_query_version             40
     BT816_reset_resVar               0
     BT816_send_data                  8
     BT816_set_name                  56
     BT816_set_pin                   56
     BT816_write_cmd                 16
     memcpy                           8
     memset                           8
     ringbuffer_data_len              8
     ringbuffer_status                0
     send_data_to_BT                 16


   Section sizes:

     Function/Label                             Bytes
     --------------                             -----
     memcpy                                       14
     memset                                       20
     ringbuffer_status                            40
     ringbuffer_data_len                          68
     BT816_res                                    48
     BT816_send_buff                             128
     BT816_recbuffer                            2048
     bt_connect_status                             1
     BT816_GPIO_config                          1624
     BT816_NVIC_config                           480
     send_data_to_BT                             340
     BT816_reset_resVar                          242
     BT816_Channel1_RxISRHandler                 182
     BT816_Channel2_RxISRHandler                 200
     BT816_Channel3_RxISRHandler                 204
     BT816_Channel4_RxISRHandler                 208
     BT816_write_cmd                             108
     BT816_Reset                                 152
     BT816_query_version                         208
     BT816_query_name                            208
     BT816_set_name                              132
     BT816_set_pin                               136
     BT816_connect_status                        380
     BT816_send_data                              24
     BT816_init                                  484
     ??DataTable13                                 4
     ??DataTable15                                 4
     ??DataTable28                                 4
     ??DataTable35                                 4
     ??DataTable43                                 4
     ??DataTable50                                 4
     ??DataTable52                                 4
     ??DataTable58                                 4
     ??DataTable80                                 4
     ??DataTable81                                 4
     ??DataTable84                                 4
     ??DataTable85                                 4
     ??DataTable88                                 4
     ??DataTable89                                 4
     ??DataTable92                                 4
     ??DataTable93                                 4
     ??DataTable105                                4
     ??DataTable111                                4
     ??DataTable117                                4
     ??DataTable118                                4
     ??DataTable121                                4
     ??DataTable122                                4
     ??DataTable123                                4
     ??DataTable129                                4
     ?<Constant "ver_buffer != 0">                16
     ?<Constant "E:\\BT Printer\\FW\\src\\...">   40
     ?<Constant "AT+VER\r\n">                     12
     ?<Constant "VER=">                            8
     ?<Constant "name != 0">                      12
     ?<Constant "AT+NAME\r\n">                    12
     ?<Constant "NAME">                            8
     ?<Constant "AT+NAME=">                       12
     ?<Constant "pin != 0">                       12
     ?<Constant "AT+PIN=">                         8
     ?<Constant "HJ Printer1">                    12
     ?<Constant "HJ Pr">                           8
     ?<Constant "HJ Printer2">                    12
     ?<Constant "HJ Printer3">                    12
     ?<Constant "HJ Printer4">                    12

 
 2 225 bytes in section .bss
   196 bytes in section .rodata
 5 550 bytes in section .text
 
 5 516 bytes of CODE  memory (+ 34 bytes shared)
   196 bytes of CONST memory
 2 225 bytes of DATA  memory

Errors: none
Warnings: 13
