###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     07/Dec/2015  18:42:27 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\BT Printer\FW\src\Drivers\BT816.c                     #
#    Command line =  "E:\BT Printer\FW\src\Drivers\BT816.c" -D DEBUG_VER      #
#                    -lcN "E:\BT Printer\FW\src\Project\EWARMv5\Debug\List\"  #
#                    -o "E:\BT Printer\FW\src\Project\EWARMv5\Debug\Obj\"     #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 5.4\arm\INC\DLib_Config_Full.h" -I "E:\BT      #
#                    Printer\FW\src\Project\EWARMv5\..\" -I "E:\BT            #
#                    Printer\FW\src\Project\EWARMv5\..\..\App\" -I "E:\BT     #
#                    Printer\FW\src\Project\EWARMv5\..\..\Drivers\" -I        #
#                    "E:\BT Printer\FW\src\Project\EWARMv5\..\..\FatFs\" -I   #
#                    "E:\BT Printer\FW\src\Project\EWARMv5\..\..\Lib\inc\"    #
#                    -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS\uC-C #
#                    PU\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS #
#                    \uC-LIB\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\.. #
#                    \uCOS\uCOS-II\Ports\" -I "E:\BT                          #
#                    Printer\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Source #
#                    \" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS\u #
#                    C-Probe\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\.. #
#                    \usb_lib\" -I "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 5.4\arm\INC\" -Ol                              #
#    List file    =  E:\BT Printer\FW\src\Project\EWARMv5\Debug\List\BT816.ls #
#                    t                                                        #
#    Object file  =  E:\BT Printer\FW\src\Project\EWARMv5\Debug\Obj\BT816.o   #
#                                                                             #
#                                                                             #
###############################################################################

E:\BT Printer\FW\src\Drivers\BT816.c
      1          /**
      2          * @file BT816.c
      3          * @brief FSC BT816蓝牙模块的驱动
      4          * @version V0.0.1
      5          * @author joe.zhou
      6          * @date 2015年10月10日
      7          * @note   根据模块的响应特点，串口驱动采用 DMA发送和接受 + 串口空闲中断判断响应数据接收完的机制。
      8          * @copy
      9          *
     10          * 此代码为深圳合杰电子有限公司项目代码，任何人及公司未经许可不得复制传播，或用于
     11          * 本公司以外的项目。本司保留一切追究权利。
     12          *
     13          * <h1><center>&copy; COPYRIGHT 2015 heroje</center></h1>
     14          *
     15          */
     16          #include "hw_platform.h"
     17          #if(BT_MODULE == USE_BT816)
     18          #include "BT816.h"
     19          #include "stm32f10x_lib.h"
     20          #include "string.h"
     21          #include <assert.h>
     22          #include "basic_fun.h"
     23          #include "TimeBase.h"
     24          #include "uart.h"
     25          
     26          //#define	BT816_DEBUG
     27          #ifdef DEBUG_VER
     28          extern unsigned short debug_buffer[];
     29          extern unsigned int debug_cnt;
     30          #endif
     31          
     32          #define BT816_RES_INIT				0x00
     33          
     34          
     35          //应答类型的响应数据状态
     36          #define BT816_RES_SUCCESS				0x01
     37          #define BT816_RES_INVALID_STATE			0x02
     38          #define BT816_RES_INVALID_SYNTAX		0x03
     39          #define BT816_RES_BUSY					0x04
     40          
     41          #define BT816_RES_PAYLOAD				0x05
     42          
     43          #define BT816_RES_UNKOWN				0x06
     44          
     45          //command format:AT+(Command)[=parameter]<CR><LF>
     46          //response format1:<CR><LF>+(Response)#(code)<CR><LF>
     47          //		   format1:<CR><LF>+(Response)[=payload]<CR><LF>
     48          
     49          /**
     50          * @brief BT816S01响应定义  BT816S01->host
     51          */
     52          typedef struct {
     53          	unsigned short			DataPos;
     54          	unsigned short			DataLength;
     55          	unsigned char			status;
     56          	unsigned char			*DataBuffer;
     57          }TBT816Res;
     58          
     59          TBT816Res		BT816_res[MAX_BT_CHANNEL];
     60          
     61          static unsigned char	BT816_send_buff[MAX_BT_CHANNEL][32];
     62          unsigned char	BT816_recbuffer[MAX_BT_CHANNEL][BT816_RES_BUFFER_LEN];
     63          
     64          
     65          static	unsigned char  bt_connect_status;
     66          
     67          #define		BT1_CONNECT		(bt_connect_status&(1<<BT1_MODULE))
     68          #define		BT2_CONNECT		(bt_connect_status&(1<<BT2_MODULE))
     69          #define		BT3_CONNECT		(bt_connect_status&(1<<BT3_MODULE))
     70          #define		BT4_CONNECT		(bt_connect_status&(1<<BT4_MODULE))
     71          #define		BT_CONNECT(ch)		(bt_connect_status&(1<<(ch)))
     72          
     73          
     74          
     75          #define	RESET_BT1_DMA()		do{	\
     76          							DMA_Cmd(DMA1_Channel5,DISABLE);\
     77          							DMA1_Channel5->CNDTR = BT816_RES_BUFFER_LEN;\
     78          							DMA_Cmd(DMA1_Channel5,ENABLE);\
     79          							}while(0)
     80          
     81          #define	RESET_BT2_DMA()		do{	\
     82          							DMA_Cmd(DMA1_Channel6,DISABLE);\
     83          							DMA1_Channel6->CNDTR = BT816_RES_BUFFER_LEN; \
     84          							DMA_Cmd(DMA1_Channel6,ENABLE);\
     85          							}while(0)
     86          
     87          #define	RESET_BT3_DMA()		do{	\
     88          							DMA_Cmd(DMA1_Channel3,DISABLE);\
     89          							DMA1_Channel3->CNDTR = BT816_RES_BUFFER_LEN;\
     90          							DMA_Cmd(DMA1_Channel3,ENABLE);\
     91          							}while(0)
     92          
     93          #define	RESET_BT4_DMA()		do{	\
     94          							DMA_Cmd(DMA2_Channel3,DISABLE);\
     95          							DMA2_Channel3->CNDTR = BT816_RES_BUFFER_LEN;\
     96          							DMA_Cmd(DMA2_Channel3,ENABLE);\
     97          							}while(0)
     98          /*
     99           * @brief: 初始化模块端口
    100           * @param[in]  unsigned int bt_channel  蓝牙模块的索引
    101           * @param[in]  unsigned int baudrate	与模块连接的串口波特率
    102          */
    103          static void BT816_GPIO_config(unsigned int bt_channel,unsigned int baudrate)
    104          {
    105          	GPIO_InitTypeDef				GPIO_InitStructure;
    106          	USART_InitTypeDef				USART_InitStructure;
    107          	DMA_InitTypeDef					DMA_InitStructure;
    108          
    109          	//for debug trip
    110          	//RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    111          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO | RCC_APB2Periph_GPIOB , ENABLE);
    112          	GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable , ENABLE);
    113          
    114          	//trip1	PB.6  trip2  PB.5  trip3  PB.4  trip4  PB.3
    115          	GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6;
    116          	GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    117          	GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_Out_PP;
    118          	GPIO_Init(GPIOB, &GPIO_InitStructure);
    119          	GPIO_SetBits(GPIOB, GPIO_Pin_3);
    120          	GPIO_ResetBits(GPIOB, GPIO_Pin_4);
    121          	GPIO_ResetBits(GPIOB, GPIO_Pin_5);
    122          	GPIO_SetBits(GPIOB, GPIO_Pin_6);
    123          
    124          #if(BT_MODULE_CONFIG & USE_BT1_MODULE)
    125          	if (bt_channel == BT1_MODULE)
    126          	{
    127          		//串口1
    128          		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
    129          		RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    130          
    131          		//B-Reset  PB.9		B-Busy	PB.8
    132          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_8 | GPIO_Pin_9;
    133          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    134          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_Out_PP;
    135          		GPIO_Init(GPIOB, &GPIO_InitStructure);
    136          		GPIO_SetBits(GPIOB, GPIO_Pin_9);
    137          		GPIO_ResetBits(GPIOB, GPIO_Pin_8);
    138          
    139          		//B-State  PB.7
    140          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_7;
    141          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    142          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IPD;
    143          		GPIO_Init(GPIOB, &GPIO_InitStructure);
    144          
    145          		// 使用USART1, PA9,PA10
    146          		/* Configure USART1 Tx (PA.9) as alternate function push-pull */
    147          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_9;
    148          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_50MHz;
    149          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_AF_PP;
    150          		GPIO_Init(GPIOA, &GPIO_InitStructure);
    151          
    152          		/* Configure USART1 Rx (PA.10) as input floating				*/
    153          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_10;
    154          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IN_FLOATING;
    155          		GPIO_Init(GPIOA, &GPIO_InitStructure);
    156          
    157          		USART_InitStructure.USART_BaudRate		= baudrate;					
    158          		USART_InitStructure.USART_WordLength	= USART_WordLength_8b;
    159          		USART_InitStructure.USART_StopBits		= USART_StopBits_1;
    160          		USART_InitStructure.USART_Parity		= USART_Parity_No;
    161          		USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    162          		USART_InitStructure.USART_Mode			= USART_Mode_Rx | USART_Mode_Tx;
    163          
    164          		USART_Init(USART1, &USART_InitStructure);
    165          
    166          
    167          		/* DMA clock enable */
    168          		RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
    169          
    170          		/* fill init structure */
    171          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    172          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    173          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    174          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
    175          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
    176          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
    177          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    178          
    179          		/* DMA1 Channel4 (triggered by USART1 Tx event) Config */
    180          		DMA_DeInit(DMA1_Channel4);
    181          		DMA_InitStructure.DMA_PeripheralBaseAddr =(u32)(&USART1->DR);
    182          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
    183          		/* As we will set them before DMA actually enabled, the DMA_MemoryBaseAddr
    184          		* and DMA_BufferSize are meaningless. So just set them to proper values
    185          		* which could make DMA_Init happy.
    186          		*/
    187          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)0;
    188          		DMA_InitStructure.DMA_BufferSize = 1;
    189          		DMA_Init(DMA1_Channel4, &DMA_InitStructure);
    190          
    191          
    192          		//DMA1通道5配置  
    193          		DMA_DeInit(DMA1_Channel5);  
    194          		//外设地址  
    195          		DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)(&USART1->DR);  
    196          		//内存地址  
    197          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)BT816_recbuffer[BT1_MODULE];  
    198          		//dma传输方向单向  
    199          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;  
    200          		//设置DMA在传输时缓冲区的长度  
    201          		DMA_InitStructure.DMA_BufferSize = BT816_RES_BUFFER_LEN;  
    202          		//设置DMA的外设递增模式，一个外设  
    203          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;  
    204          		//设置DMA的内存递增模式  
    205          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;  
    206          		//外设数据字长  
    207          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;  
    208          		//内存数据字长  
    209          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;  
    210          		//设置DMA的传输模式  
    211          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;  
    212          		//设置DMA的优先级别  
    213          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;  
    214          		//设置DMA的2个memory中的变量互相访问  
    215          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;  
    216          		DMA_Init(DMA1_Channel5,&DMA_InitStructure);  
    217          
    218          		//使能通道5 
    219          		DMA_Cmd(DMA1_Channel5,ENABLE);  
    220          
    221          		//采用DMA方式接收  
    222          		USART_DMACmd(USART1,USART_DMAReq_Rx,ENABLE); 
    223          
    224          		/* Enable USART1 DMA Tx request */
    225          		USART_DMACmd(USART1, USART_DMAReq_Tx , ENABLE);
    226          
    227          		USART_Cmd(USART1, ENABLE);
    228          	}
    229          #endif
    230          
    231          #if(BT_MODULE_CONFIG & USE_BT2_MODULE)
    232          	if (bt_channel == BT2_MODULE)
    233          	{
    234          		//USART2
    235          		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE);
    236          		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
    237          
    238          		//B-Reset  PC.3		B-Busy	PC.1
    239          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_1 | GPIO_Pin_3;
    240          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    241          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_Out_PP;
    242          		GPIO_Init(GPIOC, &GPIO_InitStructure);
    243          		GPIO_SetBits(GPIOC, GPIO_Pin_3);
    244          		GPIO_ResetBits(GPIOC, GPIO_Pin_1);
    245          
    246          		//B-State  PC.2
    247          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_2;
    248          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    249          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IPD;
    250          		GPIO_Init(GPIOC, &GPIO_InitStructure);
    251          
    252          		// 使用USART2, PA2,PA3
    253          		/* Configure USART2 Tx (PA.2) as alternate function push-pull */
    254          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_2;
    255          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_50MHz;
    256          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_AF_PP;
    257          		GPIO_Init(GPIOA, &GPIO_InitStructure);
    258          
    259          		/* Configure USART2 Rx (PA.3) as input floating				*/
    260          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_3;
    261          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IN_FLOATING;
    262          		GPIO_Init(GPIOA, &GPIO_InitStructure);
    263          
    264          		USART_InitStructure.USART_BaudRate		= baudrate;					
    265          		USART_InitStructure.USART_WordLength	= USART_WordLength_8b;
    266          		USART_InitStructure.USART_StopBits		= USART_StopBits_1;
    267          		USART_InitStructure.USART_Parity		= USART_Parity_No;
    268          		USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    269          		USART_InitStructure.USART_Mode			= USART_Mode_Rx | USART_Mode_Tx;
    270          
    271          		USART_Init(USART2, &USART_InitStructure);
    272          
    273          
    274          		/* DMA clock enable */
    275          		RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
    276          
    277          		/* fill init structure */
    278          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    279          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    280          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    281          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
    282          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
    283          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
    284          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    285          
    286          		/* DMA1 Channel7 (triggered by USART2 Tx event) Config */
    287          		DMA_DeInit(DMA1_Channel7);
    288          		DMA_InitStructure.DMA_PeripheralBaseAddr =(u32)(&USART2->DR);
    289          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
    290          		/* As we will set them before DMA actually enabled, the DMA_MemoryBaseAddr
    291          		* and DMA_BufferSize are meaningless. So just set them to proper values
    292          		* which could make DMA_Init happy.
    293          		*/
    294          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)0;
    295          		DMA_InitStructure.DMA_BufferSize = 1;
    296          		DMA_Init(DMA1_Channel7, &DMA_InitStructure);
    297          
    298          
    299          		//DMA1通道6配置  
    300          		DMA_DeInit(DMA1_Channel6);  
    301          		//外设地址  
    302          		DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)(&USART2->DR);  
    303          		//内存地址  
    304          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)BT816_recbuffer[BT2_MODULE];  
    305          		//dma传输方向单向  
    306          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;  
    307          		//设置DMA在传输时缓冲区的长度  
    308          		DMA_InitStructure.DMA_BufferSize = BT816_RES_BUFFER_LEN;  
    309          		//设置DMA的外设递增模式，一个外设  
    310          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;  
    311          		//设置DMA的内存递增模式  
    312          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;  
    313          		//外设数据字长  
    314          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;  
    315          		//内存数据字长  
    316          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;  
    317          		//设置DMA的传输模式  
    318          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;  
    319          		//设置DMA的优先级别  
    320          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;  
    321          		//设置DMA的2个memory中的变量互相访问  
    322          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;  
    323          		DMA_Init(DMA1_Channel6,&DMA_InitStructure);  
    324          
    325          		//使能通道6 
    326          		DMA_Cmd(DMA1_Channel6,ENABLE);  
    327          
    328          		//采用DMA方式接收  
    329          		USART_DMACmd(USART2,USART_DMAReq_Rx,ENABLE); 
    330          
    331          		/* Enable USART2 DMA Tx request */
    332          		USART_DMACmd(USART2, USART_DMAReq_Tx , ENABLE);
    333          
    334          		USART_Cmd(USART2, ENABLE);
    335          	}
    336          #endif
    337          
    338          #if(BT_MODULE_CONFIG & USE_BT3_MODULE)
    339          	if (bt_channel == BT3_MODULE)
    340          	{
    341          		//USART3
    342          		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE);
    343          		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
    344          
    345          		//B-Reset  PE.13		B-Busy	PE.15
    346          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_13 | GPIO_Pin_15;
    347          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    348          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_Out_PP;
    349          		GPIO_Init(GPIOE, &GPIO_InitStructure);
    350          		GPIO_SetBits(GPIOE, GPIO_Pin_13);
    351          		GPIO_ResetBits(GPIOE, GPIO_Pin_15);
    352          
    353          		//B-State  PE.14
    354          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_14;
    355          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    356          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IPD;
    357          		GPIO_Init(GPIOE, &GPIO_InitStructure);
    358          
    359          		// 使用USART3, PB10,PB11
    360          		/* Configure USART3 Tx (PB.10) as alternate function push-pull */
    361          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_10;
    362          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_50MHz;
    363          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_AF_PP;
    364          		GPIO_Init(GPIOB, &GPIO_InitStructure);
    365          
    366          		/* Configure USART3 Rx (PB.11) as input floating				*/
    367          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_11;
    368          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IN_FLOATING;
    369          		GPIO_Init(GPIOB, &GPIO_InitStructure);
    370          
    371          		USART_InitStructure.USART_BaudRate		= baudrate;					
    372          		USART_InitStructure.USART_WordLength	= USART_WordLength_8b;
    373          		USART_InitStructure.USART_StopBits		= USART_StopBits_1;
    374          		USART_InitStructure.USART_Parity		= USART_Parity_No;
    375          		USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    376          		USART_InitStructure.USART_Mode			= USART_Mode_Rx | USART_Mode_Tx;
    377          
    378          		USART_Init(USART3, &USART_InitStructure);
    379          
    380          
    381          		/* DMA clock enable */
    382          		RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
    383          
    384          		/* fill init structure */
    385          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    386          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    387          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    388          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
    389          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
    390          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
    391          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    392          
    393          		/* DMA1 Channel2 (triggered by USART3 Tx event) Config */
    394          		DMA_DeInit(DMA1_Channel2);
    395          		DMA_InitStructure.DMA_PeripheralBaseAddr =(u32)(&USART3->DR);
    396          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
    397          		/* As we will set them before DMA actually enabled, the DMA_MemoryBaseAddr
    398          		* and DMA_BufferSize are meaningless. So just set them to proper values
    399          		* which could make DMA_Init happy.
    400          		*/
    401          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)0;
    402          		DMA_InitStructure.DMA_BufferSize = 1;
    403          		DMA_Init(DMA1_Channel2, &DMA_InitStructure);
    404          
    405          
    406          		//DMA1通道3配置  
    407          		DMA_DeInit(DMA1_Channel3);  
    408          		//外设地址  
    409          		DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)(&USART3->DR);  
    410          		//内存地址  
    411          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)BT816_recbuffer[BT3_MODULE];  
    412          		//dma传输方向单向  
    413          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;  
    414          		//设置DMA在传输时缓冲区的长度  
    415          		DMA_InitStructure.DMA_BufferSize = BT816_RES_BUFFER_LEN;  
    416          		//设置DMA的外设递增模式，一个外设  
    417          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;  
    418          		//设置DMA的内存递增模式  
    419          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;  
    420          		//外设数据字长  
    421          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;  
    422          		//内存数据字长  
    423          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;  
    424          		//设置DMA的传输模式  
    425          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;  
    426          		//设置DMA的优先级别  
    427          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;  
    428          		//设置DMA的2个memory中的变量互相访问  
    429          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;  
    430          		DMA_Init(DMA1_Channel3,&DMA_InitStructure);  
    431          
    432          		//使能DMA1通道3 
    433          		DMA_Cmd(DMA1_Channel3,ENABLE);  
    434          
    435          		//采用DMA方式接收  
    436          		USART_DMACmd(USART3,USART_DMAReq_Rx,ENABLE); 
    437          
    438          		/* Enable USART3 DMA Tx request */
    439          		USART_DMACmd(USART3, USART_DMAReq_Tx , ENABLE);
    440          
    441          		USART_Cmd(USART3, ENABLE);
    442          	}
    443          #endif
    444          #if(BT_MODULE_CONFIG & USE_BT4_MODULE)
    445          	if (bt_channel == BT4_MODULE)
    446          	{
    447          		//UART4
    448          		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE);
    449          		RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
    450          
    451          		//B-Reset  PD.1		B-Busy	PD.0
    452          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_0 | GPIO_Pin_1;
    453          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    454          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_Out_PP;
    455          		GPIO_Init(GPIOD, &GPIO_InitStructure);
    456          		GPIO_SetBits(GPIOD, GPIO_Pin_1);
    457          		GPIO_ResetBits(GPIOD, GPIO_Pin_0);
    458          
    459          		//B-State  PD.3
    460          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_3;
    461          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    462          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IPD;
    463          		GPIO_Init(GPIOD, &GPIO_InitStructure);
    464          
    465          		// 使用UART4, PC11,PC10
    466          		/* Configure UART4 Tx (PC.10) as alternate function push-pull */
    467          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_10;
    468          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_50MHz;
    469          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_AF_PP;
    470          		GPIO_Init(GPIOC, &GPIO_InitStructure);
    471          
    472          		/* Configure UART4 Rx (PC.11) as input floating				*/
    473          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_11;
    474          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IN_FLOATING;
    475          		GPIO_Init(GPIOC, &GPIO_InitStructure);
    476          
    477          		USART_InitStructure.USART_BaudRate		= baudrate;					
    478          		USART_InitStructure.USART_WordLength	= USART_WordLength_8b;
    479          		USART_InitStructure.USART_StopBits		= USART_StopBits_1;
    480          		USART_InitStructure.USART_Parity		= USART_Parity_No;
    481          		USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    482          		USART_InitStructure.USART_Mode			= USART_Mode_Rx | USART_Mode_Tx;
    483          
    484          		USART_Init(UART4, &USART_InitStructure);
    485          
    486          
    487          		/* DMA clock enable */
    488          		RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA2, ENABLE);
    489          
    490          		/* fill init structure */
    491          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    492          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    493          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    494          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
    495          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
    496          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
    497          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    498          
    499          		/* DMA2 Channel5 (triggered by UART4 Tx event) Config */
    500          		DMA_DeInit(DMA2_Channel5);
    501          		DMA_InitStructure.DMA_PeripheralBaseAddr =(u32)(&UART4->DR);
    502          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
    503          		/* As we will set them before DMA actually enabled, the DMA_MemoryBaseAddr
    504          		* and DMA_BufferSize are meaningless. So just set them to proper values
    505          		* which could make DMA_Init happy.
    506          		*/
    507          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)0;
    508          		DMA_InitStructure.DMA_BufferSize = 1;
    509          		DMA_Init(DMA2_Channel5, &DMA_InitStructure);
    510          
    511          
    512          		//DMA2通道3配置  
    513          		DMA_DeInit(DMA2_Channel3);  
    514          		//外设地址  
    515          		DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)(&UART4->DR);  
    516          		//内存地址  
    517          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)BT816_recbuffer[BT4_MODULE];  
    518          		//dma传输方向单向  
    519          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;  
    520          		//设置DMA在传输时缓冲区的长度  
    521          		DMA_InitStructure.DMA_BufferSize = BT816_RES_BUFFER_LEN;  
    522          		//设置DMA的外设递增模式，一个外设  
    523          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;  
    524          		//设置DMA的内存递增模式  
    525          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;  
    526          		//外设数据字长  
    527          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;  
    528          		//内存数据字长  
    529          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;  
    530          		//设置DMA的传输模式  
    531          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;  
    532          		//设置DMA的优先级别  
    533          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;  
    534          		//设置DMA的2个memory中的变量互相访问  
    535          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;  
    536          		DMA_Init(DMA2_Channel3,&DMA_InitStructure);  
    537          
    538          		//使能DMA2通道3 
    539          		DMA_Cmd(DMA2_Channel3,ENABLE);  
    540          
    541          		//采用DMA方式接收  
    542          		USART_DMACmd(UART4,USART_DMAReq_Rx,ENABLE); 
    543          
    544          		/* Enable UART4 DMA Tx request */
    545          		USART_DMACmd(UART4, USART_DMAReq_Tx , ENABLE);
    546          
    547          		USART_Cmd(UART4, ENABLE);
    548          	}
    549          #endif
    550          }
    551          
    552          /*
    553          * @brief: 串口中断的初始化
    554          */
    555          static void BT816_NVIC_config(unsigned int bt_channel)
    556          {
    557          	NVIC_InitTypeDef				NVIC_InitStructure;
    558          #if(BT_MODULE_CONFIG & USE_BT1_MODULE)
    559          	if (bt_channel == BT1_MODULE)
    560          	{
    561          		//中断配置  
    562          		USART_ITConfig(USART1,USART_IT_TC,DISABLE);  
    563          		USART_ITConfig(USART1,USART_IT_RXNE,DISABLE);  
    564          		USART_ITConfig(USART1,USART_IT_IDLE,ENABLE);    
    565          
    566          		//配置UART4中断  
    567          		//NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
    568          		NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQChannel;               //通道设置为串口2中断    
    569          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;       //中断占先等级1    
    570          		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;              //中断响应优先级0    
    571          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                 //打开中断    
    572          		NVIC_Init(&NVIC_InitStructure);  
    573          
    574          		/* Enable the DMA1 Channel4 Interrupt */
    575          		NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel4_IRQChannel;
    576          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    577          		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    578          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    579          		NVIC_Init(&NVIC_InitStructure);
    580          
    581          		DMA_ITConfig(DMA1_Channel4, DMA_IT_TC | DMA_IT_TE, ENABLE);
    582          		DMA_ClearFlag(DMA1_FLAG_TC4);
    583          	}
    584          #endif
    585          
    586          #if(BT_MODULE_CONFIG & USE_BT2_MODULE)
    587          	if (bt_channel == BT2_MODULE)
    588          	{
    589          		//中断配置  
    590          		USART_ITConfig(USART2,USART_IT_TC,DISABLE);  
    591          		USART_ITConfig(USART2,USART_IT_RXNE,DISABLE);  
    592          		USART_ITConfig(USART2,USART_IT_IDLE,ENABLE);    
    593          
    594          		//配置USART2中断  
    595          		//NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
    596          		NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQChannel;               //通道设置为串口2中断    
    597          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;       //中断占先等级1    
    598          		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;              //中断响应优先级0    
    599          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                 //打开中断    
    600          		NVIC_Init(&NVIC_InitStructure);  
    601          
    602          		/* Enable the DMA1 Channel7 Interrupt */
    603          		NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel7_IRQChannel;
    604          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    605          		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    606          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    607          		NVIC_Init(&NVIC_InitStructure);
    608          
    609          		DMA_ITConfig(DMA1_Channel7, DMA_IT_TC | DMA_IT_TE, ENABLE);
    610          		DMA_ClearFlag(DMA1_FLAG_TC7);
    611          	}
    612          #endif
    613          
    614          #if(BT_MODULE_CONFIG & USE_BT3_MODULE)
    615          	if (bt_channel == BT3_MODULE)
    616          	{
    617          		//中断配置  
    618          		USART_ITConfig(USART3,USART_IT_TC,DISABLE);  
    619          		USART_ITConfig(USART3,USART_IT_RXNE,DISABLE);  
    620          		USART_ITConfig(USART3,USART_IT_IDLE,ENABLE);    
    621          
    622          		//配置USART3中断  
    623          		//NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
    624          		NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQChannel;               //通道设置为串口2中断    
    625          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;       //中断占先等级1    
    626          		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;              //中断响应优先级0    
    627          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                 //打开中断    
    628          		NVIC_Init(&NVIC_InitStructure);  
    629          
    630          		/* Enable the DMA1 Channel2 Interrupt */
    631          		NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel2_IRQChannel;
    632          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    633          		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    634          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    635          		NVIC_Init(&NVIC_InitStructure);
    636          
    637          		DMA_ITConfig(DMA1_Channel2, DMA_IT_TC | DMA_IT_TE, ENABLE);
    638          		DMA_ClearFlag(DMA1_FLAG_TC2);
    639          	}
    640          #endif
    641          
    642          #if(BT_MODULE_CONFIG & USE_BT4_MODULE)
    643          	if (bt_channel == BT4_MODULE)
    644          	{
    645          		//中断配置  
    646          		USART_ITConfig(UART4,USART_IT_TC,DISABLE);  
    647          		USART_ITConfig(UART4,USART_IT_RXNE,DISABLE);  
    648          		USART_ITConfig(UART4,USART_IT_IDLE,ENABLE);    
    649          
    650          		//配置UART4中断  
    651          		//NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
    652          		NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQChannel;               //通道设置为串口2中断    
    653          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;       //中断占先等级1    
    654          		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;              //中断响应优先级0    
    655          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                 //打开中断    
    656          		NVIC_Init(&NVIC_InitStructure);  
    657          
    658          		/* Enable the DMA2 Channel5 Interrupt */
    659          		NVIC_InitStructure.NVIC_IRQChannel = DMA2_Channel4_5_IRQChannel;
    660          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    661          		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    662          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    663          		NVIC_Init(&NVIC_InitStructure);
    664          
    665          		DMA_ITConfig(DMA2_Channel5, DMA_IT_TC | DMA_IT_TE, ENABLE);
    666          		DMA_ClearFlag(DMA2_FLAG_TC5);
    667          	}
    668          #endif
    669          }
    670          
    671          
    672          /**
    673          * @brief  发数据给蓝牙模块
    674          * @param[in] unsigned char *pData 要发送的数据
    675          * @param[in] int length 要发送数据的长度
    676          */
    677          static void send_data_to_BT(unsigned int bt_channel,const unsigned char *pData, unsigned int length)
    678          {
    679          #if(BT_MODULE_CONFIG & USE_BT1_MODULE)
    680          	if (bt_channel == BT1_MODULE)
    681          	{
    682          		//while(length--)
    683          		//{
    684          		//	USART_SendData(USART1, *pData++);
    685          		//	while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET)
    686          		//	{
    687          		//	}
    688          		//}
    689          		//while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET){};
    690          
    691          		/* disable DMA */
    692          		DMA_Cmd(DMA1_Channel4, DISABLE);
    693          
    694          		/* set buffer address */
    695          		memcpy(BT816_send_buff[BT1_MODULE],pData,length);
    696          
    697          		DMA1_Channel4->CMAR = (u32)&BT816_send_buff[BT1_MODULE][0];
    698          		/* set size */
    699          		DMA1_Channel4->CNDTR = length;
    700          
    701          		USART_DMACmd(USART1, USART_DMAReq_Tx , ENABLE);
    702          		/* enable DMA */
    703          		DMA_Cmd(DMA1_Channel4, ENABLE);
    704          
    705          		while(DMA1_Channel4->CNDTR);
    706          		while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET){};
    707          	}
    708          #endif
    709          
    710          #if(BT_MODULE_CONFIG & USE_BT2_MODULE)
    711          	if (bt_channel == BT2_MODULE)
    712          	{
    713          		//while(length--)
    714          		//{
    715          		//	USART_SendData(USART2, *pData++);
    716          		//	while(USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET)
    717          		//	{
    718          		//	}
    719          		//}
    720          		//while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET){};
    721          
    722          		/* disable DMA */
    723          		DMA_Cmd(DMA1_Channel7, DISABLE);
    724          
    725          		/* set buffer address */
    726          		memcpy(BT816_send_buff[BT2_MODULE],pData,length);
    727          
    728          		DMA1_Channel7->CMAR = (u32)&BT816_send_buff[BT2_MODULE][0];
    729          		/* set size */
    730          		DMA1_Channel7->CNDTR = length;
    731          
    732          		USART_DMACmd(USART2, USART_DMAReq_Tx , ENABLE);
    733          		/* enable DMA */
    734          		DMA_Cmd(DMA1_Channel7, ENABLE);
    735          
    736          		while(DMA1_Channel7->CNDTR);
    737          		while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET){};
    738          	}
    739          #endif
    740          
    741          #if(BT_MODULE_CONFIG & USE_BT3_MODULE)
    742          	if (bt_channel == BT3_MODULE)
    743          	{
    744          		//while(length--)
    745          		//{
    746          		//	USART_SendData(USART3, *pData++);
    747          		//	while(USART_GetFlagStatus(USART3, USART_FLAG_TXE) == RESET)
    748          		//	{
    749          		//	}
    750          		//}
    751          		//while(USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET){};
    752          
    753          		/* disable DMA */
    754          		DMA_Cmd(DMA1_Channel2, DISABLE);
    755          
    756          		/* set buffer address */
    757          		memcpy(BT816_send_buff[BT3_MODULE],pData,length);
    758          
    759          		DMA1_Channel2->CMAR = (u32)&BT816_send_buff[BT3_MODULE][0];
    760          		/* set size */
    761          		DMA1_Channel2->CNDTR = length;
    762          
    763          		USART_DMACmd(USART3, USART_DMAReq_Tx , ENABLE);
    764          		/* enable DMA */
    765          		DMA_Cmd(DMA1_Channel2, ENABLE);
    766          
    767          		while(DMA1_Channel2->CNDTR);
    768          		while(USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET){};
    769          	}
    770          #endif
    771          #if(BT_MODULE_CONFIG & USE_BT4_MODULE)
    772          	if (bt_channel == BT4_MODULE)
    773          	{
    774          	//while(length--)
    775          	//{
    776          	//	USART_SendData(UART4, *pData++);
    777          	//	while(USART_GetFlagStatus(UART4, USART_FLAG_TXE) == RESET)
    778          	//	{
    779          	//	}
    780          	//}
    781          	//while(USART_GetFlagStatus(UART4, USART_FLAG_TC) == RESET){};
    782          
    783          	/* disable DMA */
    784          	DMA_Cmd(DMA2_Channel5, DISABLE);
    785          
    786          	/* set buffer address */
    787          	memcpy(BT816_send_buff[BT4_MODULE],pData,length);
    788          
    789          	DMA2_Channel5->CMAR = (u32)&BT816_send_buff[BT4_MODULE][0];
    790          	/* set size */
    791          	DMA2_Channel5->CNDTR = length;
    792          
    793          	USART_DMACmd(UART4, USART_DMAReq_Tx , ENABLE);
    794          	/* enable DMA */
    795          	DMA_Cmd(DMA2_Channel5, ENABLE);
    796          
    797          	while(DMA2_Channel5->CNDTR);
    798          	while(USART_GetFlagStatus(UART4, USART_FLAG_TC) == RESET){};
    799          	}
    800          #endif
    801          }
    802          
    803          
    804          /*
    805           * @brief 清空接收蓝牙模块响应数据的buffer
    806          */
    807          static void BT816_reset_resVar(unsigned int bt_channel)
    808          {
    809          #if(BT_MODULE_CONFIG & USE_BT1_MODULE)
    810          	if (bt_channel == BT1_MODULE)
    811          	{
    812          		BT816_res[bt_channel].DataPos = 0;
    813          		BT816_res[bt_channel].DataLength = 0;
    814          		BT816_res[bt_channel].status	 = BT816_RES_INIT;
    815          		bt_connect_status &= ~(1<<BT1_MODULE);
    816          		DMA1_Channel5->CNDTR = BT816_RES_BUFFER_LEN; 
    817          	}
    818          #endif
    819          
    820          #if(BT_MODULE_CONFIG & USE_BT2_MODULE)
    821          	if (bt_channel == BT2_MODULE)
    822          	{
    823          		BT816_res[bt_channel].DataPos = 0;
    824          		BT816_res[bt_channel].DataLength = 0;
    825          		BT816_res[bt_channel].status	 = BT816_RES_INIT;
    826          		bt_connect_status &= ~(1<<BT2_MODULE);
    827          		DMA1_Channel6->CNDTR = BT816_RES_BUFFER_LEN; 
    828          	}
    829          #endif
    830          
    831          #if(BT_MODULE_CONFIG & USE_BT3_MODULE)
    832          	if (bt_channel == BT3_MODULE)
    833          	{
    834          		BT816_res[bt_channel].DataPos = 0;
    835          		BT816_res[bt_channel].DataLength = 0;
    836          		BT816_res[bt_channel].status	 = BT816_RES_INIT;
    837          		bt_connect_status &= ~(1<<BT3_MODULE);
    838          		DMA1_Channel3->CNDTR = BT816_RES_BUFFER_LEN; 
    839          	}
    840          #endif
    841          
    842          #if(BT_MODULE_CONFIG & USE_BT4_MODULE)
    843          	if (bt_channel == BT4_MODULE)
    844          	{
    845          	BT816_res[bt_channel].DataPos = 0;
    846          	BT816_res[bt_channel].DataLength = 0;
    847          	BT816_res[bt_channel].status	 = BT816_RES_INIT;
    848          	bt_connect_status &= ~(1<<BT4_MODULE);
    849          	DMA2_Channel3->CNDTR = BT816_RES_BUFFER_LEN;
    850          	}
    851          #endif
    852          }
    853          
    854          
    855          /**
    856          * @brief 处理host收到BT816的数据
    857          * @param[in] unsigned char c 读入的字符
    858          * @return 0:success put in buffer
    859          *        -1:fail
    860          */
    861          #if(BT_MODULE_CONFIG & USE_BT1_MODULE)
    862          int BT816_Channel1_RxISRHandler(unsigned char *res, unsigned int res_len)
    863          {	
    864          	int i,len;
    865          	if (BT1_CONNECT)
    866          	{
    867          		//已经处于连接状态，蓝牙模块进入数据透传模式
    868          		set_BT1_BUSY();
    869          		ringbuffer_put(&spp_ringbuf[BT1_MODULE],res,res_len);
    870          #ifdef DEBUG_VER
    871          		//memcpy(debug_buffer+debug_cnt,res,res_len);
    872          		//debug_cnt += res_len;
    873          #endif
    874          		DMA1_Channel5->CNDTR = BT816_RES_BUFFER_LEN;
    875          		if (ringbuffer_data_len(&spp_ringbuf[BT1_MODULE]) >= RING_BUFF_FULL_TH)
    876          		{
    877          			set_BT1_BUSY();
    878          		}
    879          		else
    880          		{
    881          			set_BT1_FREE();
    882          		}	
    883          	}
    884          	else
    885          	{
    886          		if (res_len > 5)
    887          		{
    888          			BT816_res[BT1_MODULE].DataLength = res_len;
    889          			if ((res[0] == 0x0d)&&(res[1] == 0x0a)			\
    890          				&&(res[res_len-2] == 0x0d)&&(res[res_len-1] == 0x0a))
    891          			{
    892          				if (BT816_res[BT1_MODULE].status == BT816_RES_INIT)
    893          				{
    894          					BT816_res[BT1_MODULE].status = BT816_RES_INVALID_STATE;
    895          					for (i = 3; i < res_len-2;i++)
    896          					{
    897          
    898          						if ((res[i] == 'o')&&(res[i+1] == 'k'))
    899          						{
    900          							BT816_res[BT1_MODULE].status = BT816_RES_SUCCESS;
    901          							break;
    902          						}
    903          
    904          						if (res[i] == '=')
    905          						{
    906          							BT816_res[BT1_MODULE].status = BT816_RES_PAYLOAD;
    907          							break;
    908          						}
    909          					}
    910          				}
    911          			}
    912          			else
    913          			{
    914          				BT816_res[BT1_MODULE].status = BT816_RES_UNKOWN;
    915          			}
    916          		}
    917          	}
    918          	
    919                  
    920                  return 0;
    921          }
    922          #endif
    923          
    924          #if(BT_MODULE_CONFIG & USE_BT2_MODULE)
    925          int BT816_Channel2_RxISRHandler(unsigned char *res, unsigned int res_len)
    926          {	
    927          	int i,len;
    928          
    929          	if (BT2_CONNECT)
    930          	{
    931          		//已经处于连接状态，蓝牙模块进入数据透传模式
    932          		set_BT2_BUSY();
    933          		ringbuffer_put(&spp_ringbuf[BT2_MODULE],res,res_len);
    934          		DMA1_Channel6->CNDTR = BT816_RES_BUFFER_LEN;
    935          		if (ringbuffer_data_len(&spp_ringbuf[BT2_MODULE]) >= RING_BUFF_FULL_TH)
    936          		{
    937          			set_BT2_BUSY();
    938          		}
    939          		else
    940          		{
    941          			set_BT2_FREE();
    942          		}
    943          	}
    944          	else
    945          	{
    946          		if (res_len > 5)
    947          		{
    948          			BT816_res[BT2_MODULE].DataLength = res_len;
    949          			if ((res[0] == 0x0d)&&(res[1] == 0x0a)			\
    950          				&&(res[res_len-2] == 0x0d)&&(res[res_len-1] == 0x0a))
    951          			{
    952          				if (BT816_res[BT2_MODULE].status == BT816_RES_INIT)
    953          				{
    954          					BT816_res[BT2_MODULE].status = BT816_RES_INVALID_STATE;
    955          					for (i = 3; i < res_len-2;i++)
    956          					{
    957          
    958          						if ((res[i] == 'o')&&(res[i+1] == 'k'))
    959          						{
    960          							BT816_res[BT2_MODULE].status = BT816_RES_SUCCESS;
    961          							break;
    962          						}
    963          
    964          						if (res[i] == '=')
    965          						{
    966          							BT816_res[BT2_MODULE].status = BT816_RES_PAYLOAD;
    967          							break;
    968          						}
    969          					}
    970          				}
    971          			}
    972          			else
    973          			{
    974          				BT816_res[BT2_MODULE].status = BT816_RES_UNKOWN;
    975          			}
    976          		}
    977          	}
    978          
    979          
    980          	return 0;
    981          }
    982          #endif
    983          
    984          #if(BT_MODULE_CONFIG & USE_BT3_MODULE)
    985          int BT816_Channel3_RxISRHandler(unsigned char *res, unsigned int res_len)
    986          {	
    987          	int i,len;
    988          	if (BT3_CONNECT)
    989          	{
    990          		//已经处于连接状态，蓝牙模块进入数据透传模式
    991          		set_BT3_BUSY();
    992          		ringbuffer_put(&spp_ringbuf[BT3_MODULE],res,res_len);
    993          		DMA1_Channel3->CNDTR = BT816_RES_BUFFER_LEN;
    994          		if (ringbuffer_data_len(&spp_ringbuf[BT3_MODULE]) >= RING_BUFF_FULL_TH)
    995          		{
    996          			set_BT3_BUSY();
    997          		}
    998          		else
    999          		{
   1000          			set_BT3_FREE();
   1001          		}
   1002          	}
   1003          	else
   1004          	{
   1005          		if (res_len > 5)
   1006          		{
   1007          			BT816_res[BT3_MODULE].DataLength = res_len;
   1008          			if ((res[0] == 0x0d)&&(res[1] == 0x0a)			\
   1009          				&&(res[res_len-2] == 0x0d)&&(res[res_len-1] == 0x0a))
   1010          			{
   1011          				if (BT816_res[BT3_MODULE].status == BT816_RES_INIT)
   1012          				{
   1013          					BT816_res[BT3_MODULE].status = BT816_RES_INVALID_STATE;
   1014          					for (i = 3; i < res_len-2;i++)
   1015          					{
   1016          
   1017          						if ((res[i] == 'o')&&(res[i+1] == 'k'))
   1018          						{
   1019          							BT816_res[BT3_MODULE].status = BT816_RES_SUCCESS;
   1020          							break;
   1021          						}
   1022          
   1023          						if (res[i] == '=')
   1024          						{
   1025          							BT816_res[BT3_MODULE].status = BT816_RES_PAYLOAD;
   1026          							break;
   1027          						}
   1028          					}
   1029          				}
   1030          			}
   1031          			else
   1032          			{
   1033          				BT816_res[BT3_MODULE].status = BT816_RES_UNKOWN;
   1034          			}
   1035          		}
   1036          	}
   1037          
   1038          
   1039          	return 0;
   1040          }
   1041          #endif
   1042          
   1043          #if(BT_MODULE_CONFIG & USE_BT4_MODULE)
   1044          int BT816_Channel4_RxISRHandler(unsigned char *res, unsigned int res_len)
   1045          {	
   1046          	int i,len;
   1047          
   1048          	if (BT4_CONNECT)
   1049          	{
   1050          		//已经处于连接状态，蓝牙模块进入数据透传模式
   1051          		set_BT4_BUSY();
   1052          		ringbuffer_put(&spp_ringbuf[BT4_MODULE],res,res_len);
   1053          		DMA2_Channel3->CNDTR = BT816_RES_BUFFER_LEN;
   1054          		if (ringbuffer_data_len(&spp_ringbuf[BT4_MODULE]) >= RING_BUFF_FULL_TH)
   1055          		{
   1056          			set_BT4_BUSY();
   1057          		}
   1058          		else
   1059          		{
   1060          			set_BT4_FREE();
   1061          		}
   1062          	}
   1063          	else
   1064          	{
   1065          		if (res_len > 5)
   1066          		{
   1067          			BT816_res[BT4_MODULE].DataLength = res_len;
   1068          			if ((res[0] == 0x0d)&&(res[1] == 0x0a)			\
   1069          				&&(res[res_len-2] == 0x0d)&&(res[res_len-1] == 0x0a))
   1070          			{
   1071          				if (BT816_res[BT4_MODULE].status == BT816_RES_INIT)
   1072          				{
   1073          					BT816_res[BT4_MODULE].status = BT816_RES_INVALID_STATE;
   1074          					for (i = 3; i < res_len-2;i++)
   1075          					{
   1076          
   1077          						if ((res[i] == 'o')&&(res[i+1] == 'k'))
   1078          						{
   1079          							BT816_res[BT4_MODULE].status = BT816_RES_SUCCESS;
   1080          							break;
   1081          						}
   1082          
   1083          						if (res[i] == '=')
   1084          						{
   1085          							BT816_res[BT4_MODULE].status = BT816_RES_PAYLOAD;
   1086          							break;
   1087          						}
   1088          					}
   1089          				}
   1090          			}
   1091          			else
   1092          			{
   1093          				BT816_res[BT4_MODULE].status = BT816_RES_UNKOWN;
   1094          			}
   1095          		}
   1096          	}
   1097          
   1098          
   1099          	return 0;
   1100          }
   1101          #endif
   1102          #define EXPECT_RES_FORMAT1_TYPE		1		//设置命令的响应，OK or Error
   1103          #define EXPECT_RES_FORMAT2_TYPE		2		//查询命令的响应，payload
   1104          
   1105          /**
   1106          * @brief  发命令给蓝牙模块BT816S01,并等待响应结果
   1107          * @param[in] unsigned char *pData 要发送的数据
   1108          * @param[in] unsigned int	length 要发送数据的长度
   1109          * @param[in] unsigned char  type   期待响应数据的命令类型	
   1110          *							EXPECT_RES_FORMAT1_TYPE: response format1		
   1111          *							EXPECT_RES_FORMAT2_TYPE:response format2
   1112          * @return		0: 成功
   1113          *				-1: 失败
   1114          *				-2: 未知响应，可能是响应解析函数有BUG，需要调试
   1115          *				-3：响应超时
   1116          * @note	等待一个响应帧的命令
   1117          */
   1118          static int BT816_write_cmd(unsigned int bt_channel,const unsigned char *pData, unsigned int length,unsigned char type)
   1119          {
   1120          	unsigned int	wait_cnt;
   1121          	send_data_to_BT(bt_channel,pData, length);
   1122          	BT816_reset_resVar(bt_channel);
   1123          	wait_cnt = 200;
   1124          	while (wait_cnt)
   1125          	{
   1126          		if (((BT816_res[bt_channel].status == BT816_RES_SUCCESS)&&(type == EXPECT_RES_FORMAT1_TYPE)) || ((BT816_res[bt_channel].status == BT816_RES_PAYLOAD)&&(type == EXPECT_RES_FORMAT2_TYPE)))
   1127          		{
   1128          			return 0;
   1129          		}
   1130          		else if(BT816_res[bt_channel].status == BT816_RES_INVALID_STATE)
   1131          		{
   1132          			return -1;
   1133          		}
   1134          		//OSTimeDlyHMSM(0,0,0,20);
   1135          		delay_ms(20);
   1136                          wait_cnt--;
   1137          	}
   1138          
   1139          	return -3;
   1140          }
   1141          
   1142          
   1143          //const unsigned char	*query_version_cmd="AT+VER=?";
   1144          //const unsigned char	*set_device_name_cmd="AT+DNAME=%s";
   1145          static unsigned char	token[10],token_value[15];
   1146          /*
   1147           * @brief 蓝牙模块BT816S01的复位
   1148          */
   1149          int BT816_Reset(void)
   1150          {
   1151          	unsigned int	wait_cnt,i,j;
   1152          	unsigned char	stat;
   1153          	int ret;
   1154          
   1155          #if(BT_MODULE_CONFIG & USE_BT1_MODULE)
   1156          	//拉低复位信号100ms
   1157          	GPIO_ResetBits(GPIOB, GPIO_Pin_9);
   1158          	delay_ms(100);
   1159              GPIO_SetBits(GPIOB, GPIO_Pin_9);
   1160          
   1161          	BT816_reset_resVar(BT1_MODULE);
   1162          #endif
   1163          
   1164          #if(BT_MODULE_CONFIG & USE_BT2_MODULE)
   1165          	//拉低复位信号100ms
   1166          	GPIO_ResetBits(GPIOC, GPIO_Pin_3);
   1167          	delay_ms(100);
   1168          	GPIO_SetBits(GPIOC, GPIO_Pin_3);
   1169          
   1170          	BT816_reset_resVar(BT2_MODULE);
   1171          #endif
   1172          
   1173          #if(BT_MODULE_CONFIG & USE_BT3_MODULE)
   1174          	//拉低复位信号100ms
   1175          	GPIO_ResetBits(GPIOE, GPIO_Pin_13);
   1176          	delay_ms(100);
   1177          	GPIO_SetBits(GPIOE, GPIO_Pin_13);
   1178          
   1179          	BT816_reset_resVar(BT3_MODULE);
   1180          #endif
   1181          
   1182          #if(BT_MODULE_CONFIG & USE_BT4_MODULE)
   1183          	//拉低复位信号100ms
   1184          	GPIO_ResetBits(GPIOD, GPIO_Pin_1);
   1185          	delay_ms(100);
   1186          	GPIO_SetBits(GPIOD, GPIO_Pin_1);
   1187          
   1188          	BT816_reset_resVar(BT4_MODULE);
   1189          #endif
   1190          #if 0
   1191          	wait_cnt = 20;
   1192          	ret = 0;
   1193          	while (wait_cnt)
   1194          	{
   1195          		if (BT816_res[].status == BT816_RES_PAYLOAD)
   1196          		{
   1197          			USART_Cmd(UART4, DISABLE);
   1198          			stat = 0;
   1199          			for (i = 0; i < BT816_res.DataLength;i++)
   1200          			{
   1201          				if (BT816_res.DataBuffer[i] == '+')
   1202          				{
   1203          					stat = 1;
   1204          					j = 0;
   1205          					continue;
   1206          				}
   1207          				else if (BT816_res.DataBuffer[i] == '=')
   1208          				{
   1209          					stat = 2;
   1210          					j = 0;
   1211          					continue;
   1212          				}
   1213          				else if (BT816_res.DataBuffer[i] == 0x0d)
   1214          				{
   1215          					if (stat == 2)
   1216          					{
   1217          						if (memcmp(token,"BDTP",4)==0)
   1218          						{
   1219          							if (token_value[0] != '0')
   1220          							{
   1221          								ret |= 0x01;
   1222          							}
   1223          						}
   1224          #ifdef DEBUG_VER
   1225          						else if (memcmp(token,"BDVER",5)==0)
   1226          						{
   1227          							token_value[j]=0;
   1228          							printf("BlueTooth Module Ver:%s\r\n",token_value);
   1229          						}
   1230          						else if (memcmp(token,"BDADDR",6)==0)
   1231          						{
   1232          							token_value[j]=0;
   1233          							printf("BlueTooth Module Addr:%s\r\n",token_value);
   1234          						}
   1235          #endif
   1236          						else if (memcmp(token,"BDMODE",6)==0)
   1237          						{
   1238          #ifdef HID_MODE
   1239          							if (token_value[0] != '2')
   1240          							{
   1241          								ret |= 0x02;
   1242          							}
   1243          #else
   1244          							if (token_value[0] != '1')
   1245          							{
   1246          								ret |= 0x02;
   1247          							}
   1248          #endif
   1249          						}
   1250          					}
   1251          					stat = 0;
   1252          					continue;
   1253          				}
   1254          
   1255          				if (stat == 1)
   1256          				{
   1257          					token[j] = BT816_res.DataBuffer[i];
   1258          					j++;
   1259          				}
   1260          				else if (stat == 2)
   1261          				{
   1262          					token_value[j] = BT816_res.DataBuffer[i];
   1263          					j++;
   1264          				}
   1265          			} 
   1266          			USART_Cmd(UART4, ENABLE);
   1267          			return ret;
   1268          		}
   1269          		//OSTimeDlyHMSM(0,0,0,100);
   1270                          wait_cnt--;
   1271                          delay_ms(100);
   1272          	}
   1273          
   1274          	return -1;
   1275          #endif
   1276          
   1277          	delay_ms(1000);
   1278          	return 0;
   1279          }
   1280          
   1281          /*
   1282           * @brief 查询蓝牙模块BT816的版本号
   1283           * @param[out]  unsigned char *ver_buffer  返回查询到的版本号，如果为空表示查询失败
   1284          */
   1285          int BT816_query_version(unsigned int bt_channel,unsigned char *ver_buffer)
   1286          {
   1287          	unsigned char	buffer[21];
   1288          	int		i,ret;
   1289          
   1290          	assert(ver_buffer != 0);
   1291          	ver_buffer[0] = 0;
   1292          	memcpy(buffer,"AT+VER\x0d\x0a",8);
   1293          	ret = BT816_write_cmd(bt_channel,(const unsigned char*)buffer,8,EXPECT_RES_FORMAT2_TYPE);
   1294          	if (ret)
   1295          	{
   1296          		return ret;
   1297          	}
   1298          
   1299          	if (memcmp(&BT816_res[bt_channel].DataBuffer[3],"VER=",4) == 0)
   1300          	{
   1301          		for (i = 0; i < ((BT816_res[bt_channel].DataLength-9) > 20)?20:(BT816_res[bt_channel].DataLength-9);i++)
   1302          		{
   1303          			if (BT816_res[bt_channel].DataBuffer[7+i] == 0x0d)
   1304          			{
   1305          				break;
   1306          			}
   1307          
   1308          			ver_buffer[i] = BT816_res[bt_channel].DataBuffer[7+i];
   1309          		}
   1310          		ver_buffer[i] = 0;
   1311          		return 0;
   1312          	}
   1313          
   1314          	return -1;
   1315          }
   1316          
   1317          
   1318          /*
   1319           * @brief 查询蓝牙模块的设备名称
   1320           * @param[out]  unsigned char *name  模块名称,字符串
   1321           * @return 0: 查询成功		else：查询失败
   1322           * @note 从手册暂时没有看到支持的名称的最大长度是多少，所以如果设置的名称太长可能会导致缓冲区溢出
   1323           *       在此接口中将设备名称限定为最长支持20个字节
   1324          */
   1325          int BT816_query_name(unsigned int bt_channel,unsigned char *name)
   1326          {
   1327          	unsigned char	buffer[15];
   1328          	int		i,ret;
   1329          
   1330          	assert(name != 0);
   1331          	name[0] = 0;
   1332          	memcpy(buffer,"AT+NAME\x0d\x0a",9);
   1333          
   1334          	ret = BT816_write_cmd(bt_channel,(const unsigned char*)buffer,9,EXPECT_RES_FORMAT2_TYPE);
   1335          	if (ret)
   1336          	{
   1337          		return ret;
   1338          	}
   1339          
   1340          	if (memcmp(&BT816_res[bt_channel].DataBuffer[3],"NAME",4) == 0)
   1341          	{
   1342          		for (i = 0; i < ((BT816_res[bt_channel].DataLength-10) > 20)?20:(BT816_res[bt_channel].DataLength-10);i++)
   1343          		{
   1344          			if (BT816_res[bt_channel].DataBuffer[8+i] == 0x0d)
   1345          			{
   1346          				break;
   1347          			}
   1348          
   1349          			name[i] = BT816_res[bt_channel].DataBuffer[8+i];
   1350          		}
   1351          		name[i] = 0;
   1352          		return 0;
   1353          	}
   1354          
   1355          	return -1; 
   1356          }
   1357          
   1358          /*
   1359           * @brief 查询和设置蓝牙模块的设备名称
   1360           * @param[in]  unsigned char *name  设置的名称,字符串
   1361           * @return 0: 设置成功		else：设置失败
   1362           * @note 从手册暂时没有看到支持的名称的最大长度是多少，所以如果设置的名称太长可能会设置失败
   1363           *       在此接口中将设备名称限定为最长支持22个字节
   1364          */
   1365          int BT816_set_name(unsigned int bt_channel,unsigned char *name)
   1366          {
   1367          	unsigned char	buffer[33];
   1368          	int		len;
   1369          
   1370          	assert(name != 0);
   1371          	memcpy(buffer,"AT+NAME=",8);
   1372          	len = strlen((char const*)name);
   1373          	if (len>22)
   1374          	{
   1375          		memcpy(buffer+8,name,22);
   1376          		buffer[30] = 0x0d;
   1377          		buffer[31] = 0x0a;
   1378          		len = 32;
   1379          	}
   1380          	else
   1381          	{
   1382          		memcpy(buffer+8,name,len);
   1383          		buffer[8+len] = 0x0d;
   1384          		buffer[9+len] = 0x0a;
   1385          		len += 10;
   1386          	}
   1387          
   1388          	return BT816_write_cmd(bt_channel,(const unsigned char*)buffer,len,EXPECT_RES_FORMAT1_TYPE); 
   1389          }
   1390          
   1391          /*
   1392           * @brief 设置蓝牙模块的PIN
   1393           * @param[in]  unsigned char *name  设置的PIN,字符串
   1394           * @return 0: 设置成功		else：设置失败
   1395           * @note 从手册暂时没有看到支持的PIN的最大长度是多少，所以如果设置的PIN太长可能会设置失败
   1396           *       在此接口中将设备名称限定为最长支持8个字节
   1397          */
   1398          int BT816_set_pin(unsigned int bt_channel,unsigned char *pin)
   1399          {
   1400          	unsigned char	buffer[33];
   1401          	int		len;
   1402          
   1403          	assert(pin != 0);
   1404          	memcpy(buffer,"AT+PIN=",7);
   1405          	len = strlen((char const*)pin);
   1406          	if (len>8)
   1407          	{
   1408          		memcpy(buffer+7,pin,8);
   1409          		buffer[15] = 0x0d;
   1410          		buffer[16] = 0x0a;
   1411          		len = 17;
   1412          	}
   1413          	else
   1414          	{
   1415          		memcpy(buffer+7,pin,len);
   1416          		buffer[7+len] = 0x0d;
   1417          		buffer[8+len] = 0x0a;
   1418          		len += 9;
   1419          	}
   1420          
   1421          	return BT816_write_cmd(bt_channel,(const unsigned char*)buffer,len,EXPECT_RES_FORMAT1_TYPE); 
   1422          }
   1423          
   1424          
   1425          /*
   1426           * @brief 查询蓝牙模块HID当前的连接状态  	
   1427           * @return <0 ：发送失败	0: unkown 	1: connected    2： disconnect
   1428           * @note 此函数需要被不断轮询才能正确反应各个模块的连接状态
   1429          */
   1430          int BT816_connect_status(unsigned int bt_channel)
   1431          {
   1432          	unsigned int i;
   1433          #if(BT_MODULE_CONFIG & USE_BT1_MODULE)
   1434          	if (bt_channel == BT1_MODULE)
   1435          	{
   1436          		if(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7))
   1437          		{
   1438          			for (i=0;i < 2000;i++);		//延时一小段时间，防止是因为抖动造成的
   1439          			if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_7))
   1440          			{
   1441          				bt_connect_status |= (1<<BT1_MODULE);
   1442          				return BT_MODULE_STATUS_CONNECTED;
   1443          			}
   1444          			else
   1445          			{
   1446          				bt_connect_status &= ~(1<<BT1_MODULE);
   1447          				return BT_MODULE_STATUS_DISCONNECT;
   1448          			}
   1449          		}
   1450          		else
   1451          		{
   1452          			bt_connect_status &= ~(1<<BT1_MODULE);
   1453          			return BT_MODULE_STATUS_DISCONNECT;
   1454          		}
   1455          	}
   1456          #endif
   1457          
   1458          #if(BT_MODULE_CONFIG & USE_BT2_MODULE)
   1459          	if (bt_channel == BT2_MODULE)
   1460          	{
   1461          		if(GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2))
   1462          		{
   1463          			for (i=0;i < 2000;i++);		//延时一小段时间，防止是因为抖动造成的
   1464          			if(GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_2))
   1465          			{
   1466          				bt_connect_status |= (1<<BT2_MODULE);
   1467          				return BT_MODULE_STATUS_CONNECTED;
   1468          			}
   1469          			else
   1470          			{
   1471          				bt_connect_status &= ~(1<<BT2_MODULE);
   1472          				return BT_MODULE_STATUS_DISCONNECT;
   1473          			}
   1474          		}
   1475          		else
   1476          		{
   1477          			bt_connect_status &= ~(1<<BT2_MODULE);
   1478          			return BT_MODULE_STATUS_DISCONNECT;
   1479          		}
   1480          	}
   1481          #endif
   1482          
   1483          #if(BT_MODULE_CONFIG & USE_BT3_MODULE)
   1484          	if (bt_channel == BT3_MODULE)
   1485          	{
   1486          		if(GPIO_ReadInputDataBit(GPIOE, GPIO_Pin_14))
   1487          		{
   1488          			for (i=0;i < 2000;i++);		//延时一小段时间，防止是因为抖动造成的
   1489          			if(GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_14))
   1490          			{
   1491          				bt_connect_status |= (1<<BT3_MODULE);
   1492          				return BT_MODULE_STATUS_CONNECTED;
   1493          			}
   1494          			else
   1495          			{
   1496          				bt_connect_status &= ~(1<<BT3_MODULE);
   1497          				return BT_MODULE_STATUS_DISCONNECT;
   1498          			}
   1499          		}
   1500          		else
   1501          		{
   1502          			bt_connect_status &= ~(1<<BT3_MODULE);
   1503          			return BT_MODULE_STATUS_DISCONNECT;
   1504          		}
   1505          	}
   1506          #endif
   1507          
   1508          #if(BT_MODULE_CONFIG & USE_BT4_MODULE)
   1509          	if (bt_channel == BT4_MODULE)
   1510          	{
   1511          		if(GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_3))
   1512          		{
   1513          			for (i=0;i < 2000;i++);		//延时一小段时间，防止是因为抖动造成的
   1514          			if(GPIO_ReadInputDataBit(GPIOD,GPIO_Pin_3))
   1515          			{
   1516          				bt_connect_status |= (1<<BT4_MODULE);
   1517          				return BT_MODULE_STATUS_CONNECTED;
   1518          			}
   1519          			else
   1520          			{
   1521          				bt_connect_status &= ~(1<<BT4_MODULE);
   1522          				return BT_MODULE_STATUS_DISCONNECT;
   1523          			}
   1524          		}
   1525          		else
   1526          		{
   1527          			bt_connect_status &= ~(1<<BT4_MODULE);
   1528          			return BT_MODULE_STATUS_DISCONNECT;
   1529          		}
   1530          	}
   1531          #endif
   1532          
   1533          }
   1534          
   1535          /*
   1536           * @brief 通过蓝牙模块的透传模式发送数据到蓝牙主机
   1537          */
   1538          void BT816_send_data(unsigned int bt_channel,unsigned char *data,unsigned int len)
   1539          {
   1540          	if (BT_CONNECT(bt_channel))
   1541          	{
   1542          		send_data_to_BT(bt_channel,data,len);
   1543          	}
   1544          }
   1545          
   1546          /*
   1547           * @brief 蓝牙模块BT816的初始化
   1548          */
   1549          int BT816_init(void)
   1550          {
   1551          	unsigned char	str[21];
   1552          	int ret,i;
   1553          	for (i = 0; i < MAX_BT_CHANNEL;i++)
   1554          	{
   1555          		BT816_res[i].DataBuffer = BT816_recbuffer[i];
   1556          		BT816_reset_resVar(i);
   1557          		//初始化一个SPP的环形缓冲区
   1558          		ringbuffer_init(&spp_ringbuf[i],spp_rec_buffer[i],SPP_BUFFER_LEN);
   1559          
   1560          		BT816_GPIO_config(i,115200);		//default波特率
   1561          		BT816_NVIC_config(i);
   1562          	}
   1563          
   1564          	ret = BT816_Reset();
   1565          	if(ret < 0)
   1566          	{
   1567          		ret = BT816_Reset();
   1568          		if(ret < 0)
   1569          		{
   1570          			return -1;
   1571          		}
   1572          	}
   1573          
   1574          #if 1
   1575          	if (BT816_query_name(BT1_MODULE,str))
   1576          	{
   1577          		return -4;
   1578          	}
   1579          
   1580          	if (memcmp(str,"HJ Pr",5) != 0)
   1581          	{
   1582          		if (BT816_set_name(BT1_MODULE,"HJ Printer1"))
   1583          		{
   1584          			return -5;
   1585          		}
   1586          	}
   1587          
   1588          	if (BT816_query_name(BT2_MODULE,str))
   1589          	{
   1590          		return -4;
   1591          	}
   1592          
   1593          	if (memcmp(str,"HJ Pr",5) != 0)
   1594          	{
   1595          		if (BT816_set_name(BT2_MODULE,"HJ Printer2"))
   1596          		{
   1597          			return -5;
   1598          		}
   1599          	}
   1600          
   1601          	if (BT816_query_name(BT3_MODULE,str))
   1602          	{
   1603          		return -4;
   1604          	}
   1605          
   1606          	if (memcmp(str,"HJ Pr",5) != 0)
   1607          	{
   1608          		if (BT816_set_name(BT3_MODULE,"HJ Printer3"))
   1609          		{
   1610          			return -5;
   1611          		}
   1612          	}
   1613          
   1614          	if (BT816_query_name(BT4_MODULE,str))
   1615          	{
   1616          		return -4;
   1617          	}
   1618          
   1619          	if (memcmp(str,"HJ Pr",5) != 0)
   1620          	{
   1621          		if (BT816_set_name(BT4_MODULE,"HJ Printer4"))
   1622          		{
   1623          			return -5;
   1624          		}
   1625          	}
   1626          
   1627          #endif
   1628          
   1629          	memset(spp_rec_buffer,0,MAX_BT_CHANNEL*SPP_BUFFER_LEN);
   1630          	RESET_BT1_DMA();
   1631          	RESET_BT2_DMA();
   1632          	RESET_BT3_DMA();
   1633          	RESET_BT4_DMA();
   1634          	return 0;
   1635          }
   1636          
   1637          #endif

   Maximum stack usage in bytes:

     Function                    .cstack
     --------                    -------
     BT816_Channel1_RxISRHandler     16
     BT816_Channel2_RxISRHandler     16
     BT816_Channel3_RxISRHandler     16
     BT816_Channel4_RxISRHandler     16
     BT816_GPIO_config               80
     BT816_NVIC_config               16
     BT816_Reset                      8
     BT816_connect_status             8
     BT816_init                      32
     BT816_query_name                32
     BT816_query_version             40
     BT816_reset_resVar               0
     BT816_send_data                  8
     BT816_set_name                  56
     BT816_set_pin                   56
     BT816_write_cmd                 16
     memcpy                           8
     memset                           8
     ringbuffer_data_len              8
     ringbuffer_status                0
     send_data_to_BT                 16


   Section sizes:

     Function/Label                             Bytes
     --------------                             -----
     memcpy                                       14
     memset                                       20
     ringbuffer_status                            40
     ringbuffer_data_len                          68
     BT816_res                                    48
     BT816_send_buff                             128
     BT816_recbuffer                            1024
     bt_connect_status                             1
     BT816_GPIO_config                          1624
     BT816_NVIC_config                           480
     send_data_to_BT                             340
     BT816_reset_resVar                          242
     BT816_Channel1_RxISRHandler                 236
     BT816_Channel2_RxISRHandler                 208
     BT816_Channel3_RxISRHandler                 216
     BT816_Channel4_RxISRHandler                 220
     BT816_write_cmd                             108
     BT816_Reset                                 152
     BT816_query_version                         208
     BT816_query_name                            208
     BT816_set_name                              132
     BT816_set_pin                               136
     BT816_connect_status                        380
     BT816_send_data                              24
     BT816_init                                  484
     ??DataTable13                                 4
     ??DataTable15                                 4
     ??DataTable28                                 4
     ??DataTable35                                 4
     ??DataTable43                                 4
     ??DataTable50                                 4
     ??DataTable52                                 4
     ??DataTable58                                 4
     ??DataTable80                                 4
     ??DataTable81                                 4
     ??DataTable84                                 4
     ??DataTable85                                 4
     ??DataTable88                                 4
     ??DataTable89                                 4
     ??DataTable92                                 4
     ??DataTable93                                 4
     ??DataTable105                                4
     ??DataTable111                                4
     ??DataTable117                                4
     ??DataTable118                                4
     ??DataTable121                                4
     ??DataTable122                                4
     ??DataTable124                                4
     ??DataTable130                                4
     ?<Constant "ver_buffer != 0">                16
     ?<Constant "E:\\BT Printer\\FW\\src\\...">   40
     ?<Constant "AT+VER\r\n">                     12
     ?<Constant "VER=">                            8
     ?<Constant "name != 0">                      12
     ?<Constant "AT+NAME\r\n">                    12
     ?<Constant "NAME">                            8
     ?<Constant "AT+NAME=">                       12
     ?<Constant "pin != 0">                       12
     ?<Constant "AT+PIN=">                         8
     ?<Constant "HJ Printer1">                    12
     ?<Constant "HJ Pr">                           8
     ?<Constant "HJ Printer2">                    12
     ?<Constant "HJ Printer3">                    12
     ?<Constant "HJ Printer4">                    12

 
 1 201 bytes in section .bss
   196 bytes in section .rodata
 5 636 bytes in section .text
 
 5 602 bytes of CODE  memory (+ 34 bytes shared)
   196 bytes of CONST memory
 1 201 bytes of DATA  memory

Errors: none
Warnings: 13
