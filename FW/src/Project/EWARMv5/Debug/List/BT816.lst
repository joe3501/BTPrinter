###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     26/Nov/2015  15:28:14 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\BT Printer\FW\src\Drivers\BT816.c                     #
#    Command line =  "E:\BT Printer\FW\src\Drivers\BT816.c" -D DEBUG_VER      #
#                    -lcN "E:\BT Printer\FW\src\Project\EWARMv5\Debug\List\"  #
#                    -o "E:\BT Printer\FW\src\Project\EWARMv5\Debug\Obj\"     #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 5.4\arm\INC\DLib_Config_Full.h" -I "E:\BT      #
#                    Printer\FW\src\Project\EWARMv5\..\" -I "E:\BT            #
#                    Printer\FW\src\Project\EWARMv5\..\..\App\" -I "E:\BT     #
#                    Printer\FW\src\Project\EWARMv5\..\..\Drivers\" -I        #
#                    "E:\BT Printer\FW\src\Project\EWARMv5\..\..\FatFs\" -I   #
#                    "E:\BT Printer\FW\src\Project\EWARMv5\..\..\Lib\inc\"    #
#                    -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS\uC-C #
#                    PU\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS #
#                    \uC-LIB\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\.. #
#                    \uCOS\uCOS-II\Ports\" -I "E:\BT                          #
#                    Printer\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Source #
#                    \" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS\u #
#                    C-Probe\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\.. #
#                    \usb_lib\" -I "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 5.4\arm\INC\" -Ol                              #
#    List file    =  E:\BT Printer\FW\src\Project\EWARMv5\Debug\List\BT816.ls #
#                    t                                                        #
#    Object file  =  E:\BT Printer\FW\src\Project\EWARMv5\Debug\Obj\BT816.o   #
#                                                                             #
#                                                                             #
###############################################################################

E:\BT Printer\FW\src\Drivers\BT816.c
      1          /**
      2          * @file BT816.c
      3          * @brief FSC BT816蓝牙模块的驱动
      4          * @version V0.0.1
      5          * @author joe.zhou
      6          * @date 2015年10月10日
      7          * @note   根据模块的响应特点，串口驱动采用 DMA发送和接受 + 串口空闲中断判断响应数据接收完的机制。
      8          * @copy
      9          *
     10          * 此代码为深圳合杰电子有限公司项目代码，任何人及公司未经许可不得复制传播，或用于
     11          * 本公司以外的项目。本司保留一切追究权利。
     12          *
     13          * <h1><center>&copy; COPYRIGHT 2015 heroje</center></h1>
     14          *
     15          */
     16          #include "hw_platform.h"
     17          #if(BT_MODULE == USE_BT816)
     18          #include "BT816.h"
     19          #include "stm32f10x_lib.h"
     20          #include "string.h"
     21          #include <assert.h>
     22          #include "basic_fun.h"
     23          #include "ringbuffer.h"
     24          #include "TimeBase.h"
     25          
     26          //#define	BT816_DEBUG
     27          
     28          
     29          #define BT816_RES_INIT				0x00
     30          
     31          
     32          //应答类型的响应数据状态
     33          #define BT816_RES_SUCCESS				0x01
     34          #define BT816_RES_INVALID_STATE			0x02
     35          #define BT816_RES_INVALID_SYNTAX		0x03
     36          #define BT816_RES_BUSY					0x04
     37          
     38          #define BT816_RES_PAYLOAD				0x05
     39          
     40          #define BT816_RES_UNKOWN				0x06
     41          
     42          //command format:AT+(Command)[=parameter]<CR><LF>
     43          //response format1:<CR><LF>+(Response)#(code)<CR><LF>
     44          //		   format1:<CR><LF>+(Response)[=payload]<CR><LF>
     45          
     46          /**
     47          * @brief BT816S01响应定义  BT816S01->host
     48          */
     49          typedef struct {
     50          	unsigned short			DataPos;
     51          	unsigned short			DataLength;
     52          	unsigned char			status;
     53          	unsigned char			*DataBuffer;
     54          }TBT816Res;
     55          
     56          TBT816Res		BT816_res[MAX_PT_CHANNEL];
     57          
     58          static unsigned char	BT816_send_buff[MAX_PT_CHANNEL][32];
     59          unsigned char	BT816_recbuffer[MAX_PT_CHANNEL][BT816_RES_BUFFER_LEN];
     60          
     61          unsigned char		spp_rec_buffer[MAX_PT_CHANNEL][SPP_BUFFER_LEN];
     62          struct ringbuffer	spp_ringbuf[MAX_PT_CHANNEL];
     63          
     64          #define RING_BUFF_FULL_TH		(SPP_BUFFER_LEN-256)	//当ringbuffer中接收到的数据大于此值时，实行流控，通知蓝牙模块不要再传数据下来了，此值待调试确定
     65          
     66          static	unsigned char  bt_connect_status;
     67          
     68          #define		BT1_CONNECT		(bt_connect_status&(1<<BT1_MODULE))
     69          #define		BT2_CONNECT		(bt_connect_status&(1<<BT2_MODULE))
     70          #define		BT3_CONNECT		(bt_connect_status&(1<<BT3_MODULE))
     71          #define		BT4_CONNECT		(bt_connect_status&(1<<BT4_MODULE))
     72          
     73          #define     set_BT1_BUSY()	GPIO_SetBits(GPIOB, GPIO_Pin_8)
     74          #define     set_BT1_FREE()	GPIO_ResetBits(GPIOB, GPIO_Pin_8)
     75          
     76          #define     set_BT2_BUSY()	GPIO_SetBits(GPIOC, GPIO_Pin_1)
     77          #define     set_BT2_FREE()	GPIO_ResetBits(GPIOC, GPIO_Pin_1)
     78          
     79          #define     set_BT3_BUSY()	GPIO_SetBits(GPIOE, GPIO_Pin_15)
     80          #define     set_BT3_FREE()	GPIO_ResetBits(GPIOE, GPIO_Pin_15)
     81          
     82          #define     set_BT4_BUSY()	GPIO_SetBits(GPIOD, GPIO_Pin_0)
     83          #define     set_BT4_FREE()	GPIO_ResetBits(GPIOD, GPIO_Pin_0)
     84          
     85          #define	RESET_BT1_DMA()		do{	\
     86          							DMA_Cmd(DMA1_Channel5,DISABLE);\
     87          							DMA1_Channel5->CNDTR = BT816_RES_BUFFER_LEN;\
     88          							DMA_Cmd(DMA1_Channel5,ENABLE);\
     89          							}while(0)
     90          
     91          #define	RESET_BT2_DMA()		do{	\
     92          							DMA_Cmd(DMA1_Channel6,DISABLE);\
     93          							DMA1_Channel6->CNDTR = BT816_RES_BUFFER_LEN; \
     94          							DMA_Cmd(DMA1_Channel6,ENABLE);\
     95          							}while(0)
     96          
     97          #define	RESET_BT3_DMA()		do{	\
     98          							DMA_Cmd(DMA1_Channel3,DISABLE);\
     99          							DMA1_Channel3->CNDTR = BT816_RES_BUFFER_LEN;\
    100          							DMA_Cmd(DMA1_Channel3,ENABLE);\
    101          							}while(0)
    102          
    103          #define	RESET_BT4_DMA()		do{	\
    104          							DMA_Cmd(DMA2_Channel3,DISABLE);\
    105          							DMA2_Channel3->CNDTR = BT816_RES_BUFFER_LEN;\
    106          							DMA_Cmd(DMA2_Channel3,ENABLE);\
    107          							}while(0)
    108          /*
    109           * @brief: 初始化模块端口
    110           * @param[in]  unsigned int bt_channel  蓝牙模块的索引
    111           * @param[in]  unsigned int baudrate	与模块连接的串口波特率
    112          */
    113          static void BT816_GPIO_config(unsigned int bt_channel,unsigned int baudrate)
    114          {
    115          	GPIO_InitTypeDef				GPIO_InitStructure;
    116          	USART_InitTypeDef				USART_InitStructure;
    117          	DMA_InitTypeDef					DMA_InitStructure;
    118          
    119          #if(BT_MODULE_CONFIG & USE_BT1_MODULE)
    120          	if (bt_channel == BT1_MODULE)
    121          	{
    122          		//串口1
    123          		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
    124          		RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    125          
    126          		//B-Reset  PB.9		B-Busy	PB.8
    127          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_8 | GPIO_Pin_9;
    128          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    129          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_Out_PP;
    130          		GPIO_Init(GPIOB, &GPIO_InitStructure);
    131          		GPIO_SetBits(GPIOB, GPIO_Pin_9);
    132          		GPIO_ResetBits(GPIOB, GPIO_Pin_8);
    133          
    134          		//B-State  PB.7
    135          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_7;
    136          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    137          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IPD;
    138          		GPIO_Init(GPIOB, &GPIO_InitStructure);
    139          
    140          		// 使用USART1, PA9,PA10
    141          		/* Configure USART1 Tx (PA.9) as alternate function push-pull */
    142          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_9;
    143          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_50MHz;
    144          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_AF_PP;
    145          		GPIO_Init(GPIOA, &GPIO_InitStructure);
    146          
    147          		/* Configure USART1 Rx (PA.10) as input floating				*/
    148          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_10;
    149          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IN_FLOATING;
    150          		GPIO_Init(GPIOA, &GPIO_InitStructure);
    151          
    152          		USART_InitStructure.USART_BaudRate		= baudrate;					
    153          		USART_InitStructure.USART_WordLength	= USART_WordLength_8b;
    154          		USART_InitStructure.USART_StopBits		= USART_StopBits_1;
    155          		USART_InitStructure.USART_Parity		= USART_Parity_No;
    156          		USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    157          		USART_InitStructure.USART_Mode			= USART_Mode_Rx | USART_Mode_Tx;
    158          
    159          		USART_Init(USART1, &USART_InitStructure);
    160          
    161          
    162          		/* DMA clock enable */
    163          		RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
    164          
    165          		/* fill init structure */
    166          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    167          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    168          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    169          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
    170          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
    171          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
    172          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    173          
    174          		/* DMA1 Channel4 (triggered by USART1 Tx event) Config */
    175          		DMA_DeInit(DMA1_Channel4);
    176          		DMA_InitStructure.DMA_PeripheralBaseAddr =(u32)(&USART1->DR);
    177          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
    178          		/* As we will set them before DMA actually enabled, the DMA_MemoryBaseAddr
    179          		* and DMA_BufferSize are meaningless. So just set them to proper values
    180          		* which could make DMA_Init happy.
    181          		*/
    182          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)0;
    183          		DMA_InitStructure.DMA_BufferSize = 1;
    184          		DMA_Init(DMA1_Channel4, &DMA_InitStructure);
    185          
    186          
    187          		//DMA1通道5配置  
    188          		DMA_DeInit(DMA1_Channel5);  
    189          		//外设地址  
    190          		DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)(&USART1->DR);  
    191          		//内存地址  
    192          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)BT816_recbuffer[BT1_MODULE];  
    193          		//dma传输方向单向  
    194          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;  
    195          		//设置DMA在传输时缓冲区的长度  
    196          		DMA_InitStructure.DMA_BufferSize = BT816_RES_BUFFER_LEN;  
    197          		//设置DMA的外设递增模式，一个外设  
    198          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;  
    199          		//设置DMA的内存递增模式  
    200          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;  
    201          		//外设数据字长  
    202          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;  
    203          		//内存数据字长  
    204          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;  
    205          		//设置DMA的传输模式  
    206          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;  
    207          		//设置DMA的优先级别  
    208          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;  
    209          		//设置DMA的2个memory中的变量互相访问  
    210          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;  
    211          		DMA_Init(DMA1_Channel5,&DMA_InitStructure);  
    212          
    213          		//使能通道5 
    214          		DMA_Cmd(DMA1_Channel5,ENABLE);  
    215          
    216          		//采用DMA方式接收  
    217          		USART_DMACmd(USART1,USART_DMAReq_Rx,ENABLE); 
    218          
    219          		/* Enable USART1 DMA Tx request */
    220          		USART_DMACmd(USART1, USART_DMAReq_Tx , ENABLE);
    221          
    222          		USART_Cmd(USART1, ENABLE);
    223          	}
    224          #endif
    225          
    226          #if(BT_MODULE_CONFIG & USE_BT2_MODULE)
    227          	if (bt_channel == BT2_MODULE)
    228          	{
    229          		//USART2
    230          		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE);
    231          		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
    232          
    233          		//B-Reset  PC.3		B-Busy	PC.1
    234          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_1 | GPIO_Pin_3;
    235          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    236          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_Out_PP;
    237          		GPIO_Init(GPIOC, &GPIO_InitStructure);
    238          		GPIO_SetBits(GPIOC, GPIO_Pin_3);
    239          		GPIO_ResetBits(GPIOC, GPIO_Pin_1);
    240          
    241          		//B-State  PC.2
    242          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_2;
    243          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    244          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IPD;
    245          		GPIO_Init(GPIOC, &GPIO_InitStructure);
    246          
    247          		// 使用USART2, PA2,PA3
    248          		/* Configure USART2 Tx (PA.2) as alternate function push-pull */
    249          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_2;
    250          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_50MHz;
    251          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_AF_PP;
    252          		GPIO_Init(GPIOA, &GPIO_InitStructure);
    253          
    254          		/* Configure USART2 Rx (PA.3) as input floating				*/
    255          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_3;
    256          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IN_FLOATING;
    257          		GPIO_Init(GPIOA, &GPIO_InitStructure);
    258          
    259          		USART_InitStructure.USART_BaudRate		= baudrate;					
    260          		USART_InitStructure.USART_WordLength	= USART_WordLength_8b;
    261          		USART_InitStructure.USART_StopBits		= USART_StopBits_1;
    262          		USART_InitStructure.USART_Parity		= USART_Parity_No;
    263          		USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    264          		USART_InitStructure.USART_Mode			= USART_Mode_Rx | USART_Mode_Tx;
    265          
    266          		USART_Init(USART2, &USART_InitStructure);
    267          
    268          
    269          		/* DMA clock enable */
    270          		RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
    271          
    272          		/* fill init structure */
    273          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    274          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    275          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    276          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
    277          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
    278          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
    279          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    280          
    281          		/* DMA1 Channel7 (triggered by USART2 Tx event) Config */
    282          		DMA_DeInit(DMA1_Channel7);
    283          		DMA_InitStructure.DMA_PeripheralBaseAddr =(u32)(&USART2->DR);
    284          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
    285          		/* As we will set them before DMA actually enabled, the DMA_MemoryBaseAddr
    286          		* and DMA_BufferSize are meaningless. So just set them to proper values
    287          		* which could make DMA_Init happy.
    288          		*/
    289          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)0;
    290          		DMA_InitStructure.DMA_BufferSize = 1;
    291          		DMA_Init(DMA1_Channel7, &DMA_InitStructure);
    292          
    293          
    294          		//DMA1通道6配置  
    295          		DMA_DeInit(DMA1_Channel6);  
    296          		//外设地址  
    297          		DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)(&USART2->DR);  
    298          		//内存地址  
    299          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)BT816_recbuffer[BT2_MODULE];  
    300          		//dma传输方向单向  
    301          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;  
    302          		//设置DMA在传输时缓冲区的长度  
    303          		DMA_InitStructure.DMA_BufferSize = BT816_RES_BUFFER_LEN;  
    304          		//设置DMA的外设递增模式，一个外设  
    305          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;  
    306          		//设置DMA的内存递增模式  
    307          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;  
    308          		//外设数据字长  
    309          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;  
    310          		//内存数据字长  
    311          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;  
    312          		//设置DMA的传输模式  
    313          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;  
    314          		//设置DMA的优先级别  
    315          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;  
    316          		//设置DMA的2个memory中的变量互相访问  
    317          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;  
    318          		DMA_Init(DMA1_Channel6,&DMA_InitStructure);  
    319          
    320          		//使能通道6 
    321          		DMA_Cmd(DMA1_Channel6,ENABLE);  
    322          
    323          		//采用DMA方式接收  
    324          		USART_DMACmd(USART2,USART_DMAReq_Rx,ENABLE); 
    325          
    326          		/* Enable USART2 DMA Tx request */
    327          		USART_DMACmd(USART2, USART_DMAReq_Tx , ENABLE);
    328          
    329          		USART_Cmd(USART2, ENABLE);
    330          	}
    331          #endif
    332          
    333          #if(BT_MODULE_CONFIG & USE_BT3_MODULE)
    334          	if (bt_channel == BT3_MODULE)
    335          	{
    336          		//USART3
    337          		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE);
    338          		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
    339          
    340          		//B-Reset  PE.13		B-Busy	PE.15
    341          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_13 | GPIO_Pin_15;
    342          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    343          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_Out_PP;
    344          		GPIO_Init(GPIOE, &GPIO_InitStructure);
    345          		GPIO_SetBits(GPIOE, GPIO_Pin_13);
    346          		GPIO_ResetBits(GPIOE, GPIO_Pin_15);
    347          
    348          		//B-State  PE.14
    349          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_14;
    350          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    351          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IPD;
    352          		GPIO_Init(GPIOE, &GPIO_InitStructure);
    353          
    354          		// 使用USART3, PB10,PB11
    355          		/* Configure USART3 Tx (PB.10) as alternate function push-pull */
    356          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_10;
    357          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_50MHz;
    358          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_AF_PP;
    359          		GPIO_Init(GPIOB, &GPIO_InitStructure);
    360          
    361          		/* Configure USART3 Rx (PB.11) as input floating				*/
    362          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_11;
    363          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IN_FLOATING;
    364          		GPIO_Init(GPIOB, &GPIO_InitStructure);
    365          
    366          		USART_InitStructure.USART_BaudRate		= baudrate;					
    367          		USART_InitStructure.USART_WordLength	= USART_WordLength_8b;
    368          		USART_InitStructure.USART_StopBits		= USART_StopBits_1;
    369          		USART_InitStructure.USART_Parity		= USART_Parity_No;
    370          		USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    371          		USART_InitStructure.USART_Mode			= USART_Mode_Rx | USART_Mode_Tx;
    372          
    373          		USART_Init(USART3, &USART_InitStructure);
    374          
    375          
    376          		/* DMA clock enable */
    377          		RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
    378          
    379          		/* fill init structure */
    380          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    381          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    382          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    383          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
    384          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
    385          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
    386          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    387          
    388          		/* DMA1 Channel2 (triggered by USART3 Tx event) Config */
    389          		DMA_DeInit(DMA1_Channel2);
    390          		DMA_InitStructure.DMA_PeripheralBaseAddr =(u32)(&USART3->DR);
    391          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
    392          		/* As we will set them before DMA actually enabled, the DMA_MemoryBaseAddr
    393          		* and DMA_BufferSize are meaningless. So just set them to proper values
    394          		* which could make DMA_Init happy.
    395          		*/
    396          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)0;
    397          		DMA_InitStructure.DMA_BufferSize = 1;
    398          		DMA_Init(DMA1_Channel2, &DMA_InitStructure);
    399          
    400          
    401          		//DMA1通道3配置  
    402          		DMA_DeInit(DMA1_Channel3);  
    403          		//外设地址  
    404          		DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)(&USART3->DR);  
    405          		//内存地址  
    406          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)BT816_recbuffer[BT3_MODULE];  
    407          		//dma传输方向单向  
    408          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;  
    409          		//设置DMA在传输时缓冲区的长度  
    410          		DMA_InitStructure.DMA_BufferSize = BT816_RES_BUFFER_LEN;  
    411          		//设置DMA的外设递增模式，一个外设  
    412          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;  
    413          		//设置DMA的内存递增模式  
    414          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;  
    415          		//外设数据字长  
    416          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;  
    417          		//内存数据字长  
    418          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;  
    419          		//设置DMA的传输模式  
    420          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;  
    421          		//设置DMA的优先级别  
    422          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;  
    423          		//设置DMA的2个memory中的变量互相访问  
    424          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;  
    425          		DMA_Init(DMA1_Channel3,&DMA_InitStructure);  
    426          
    427          		//使能DMA1通道3 
    428          		DMA_Cmd(DMA1_Channel3,ENABLE);  
    429          
    430          		//采用DMA方式接收  
    431          		USART_DMACmd(USART3,USART_DMAReq_Rx,ENABLE); 
    432          
    433          		/* Enable USART3 DMA Tx request */
    434          		USART_DMACmd(USART3, USART_DMAReq_Tx , ENABLE);
    435          
    436          		USART_Cmd(USART3, ENABLE);
    437          	}
    438          #endif
    439          #if(BT_MODULE_CONFIG & USE_BT4_MODULE)
    440          	if (bt_channel == BT4_MODULE)
    441          	{
    442          		//UART4
    443          		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE);
    444          		RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
    445          
    446          		//B-Reset  PD.1		B-Busy	PD.0
    447          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_0 | GPIO_Pin_1;
    448          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    449          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_Out_PP;
    450          		GPIO_Init(GPIOD, &GPIO_InitStructure);
    451          		GPIO_SetBits(GPIOD, GPIO_Pin_1);
    452          		GPIO_ResetBits(GPIOD, GPIO_Pin_0);
    453          
    454          		//B-State  PD.3
    455          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_3;
    456          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_2MHz;
    457          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IPD;
    458          		GPIO_Init(GPIOD, &GPIO_InitStructure);
    459          
    460          		// 使用UART4, PC11,PC10
    461          		/* Configure UART4 Tx (PC.10) as alternate function push-pull */
    462          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_10;
    463          		GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_50MHz;
    464          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_AF_PP;
    465          		GPIO_Init(GPIOC, &GPIO_InitStructure);
    466          
    467          		/* Configure UART4 Rx (PC.11) as input floating				*/
    468          		GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_11;
    469          		GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IN_FLOATING;
    470          		GPIO_Init(GPIOC, &GPIO_InitStructure);
    471          
    472          		USART_InitStructure.USART_BaudRate		= baudrate;					
    473          		USART_InitStructure.USART_WordLength	= USART_WordLength_8b;
    474          		USART_InitStructure.USART_StopBits		= USART_StopBits_1;
    475          		USART_InitStructure.USART_Parity		= USART_Parity_No;
    476          		USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    477          		USART_InitStructure.USART_Mode			= USART_Mode_Rx | USART_Mode_Tx;
    478          
    479          		USART_Init(UART4, &USART_InitStructure);
    480          
    481          
    482          		/* DMA clock enable */
    483          		RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA2, ENABLE);
    484          
    485          		/* fill init structure */
    486          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    487          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    488          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    489          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
    490          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
    491          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
    492          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    493          
    494          		/* DMA2 Channel5 (triggered by UART4 Tx event) Config */
    495          		DMA_DeInit(DMA2_Channel5);
    496          		DMA_InitStructure.DMA_PeripheralBaseAddr =(u32)(&UART4->DR);
    497          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
    498          		/* As we will set them before DMA actually enabled, the DMA_MemoryBaseAddr
    499          		* and DMA_BufferSize are meaningless. So just set them to proper values
    500          		* which could make DMA_Init happy.
    501          		*/
    502          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)0;
    503          		DMA_InitStructure.DMA_BufferSize = 1;
    504          		DMA_Init(DMA2_Channel5, &DMA_InitStructure);
    505          
    506          
    507          		//DMA2通道3配置  
    508          		DMA_DeInit(DMA2_Channel3);  
    509          		//外设地址  
    510          		DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)(&UART4->DR);  
    511          		//内存地址  
    512          		DMA_InitStructure.DMA_MemoryBaseAddr = (u32)BT816_recbuffer[BT4_MODULE];  
    513          		//dma传输方向单向  
    514          		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;  
    515          		//设置DMA在传输时缓冲区的长度  
    516          		DMA_InitStructure.DMA_BufferSize = BT816_RES_BUFFER_LEN;  
    517          		//设置DMA的外设递增模式，一个外设  
    518          		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;  
    519          		//设置DMA的内存递增模式  
    520          		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;  
    521          		//外设数据字长  
    522          		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;  
    523          		//内存数据字长  
    524          		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;  
    525          		//设置DMA的传输模式  
    526          		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;  
    527          		//设置DMA的优先级别  
    528          		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;  
    529          		//设置DMA的2个memory中的变量互相访问  
    530          		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;  
    531          		DMA_Init(DMA2_Channel3,&DMA_InitStructure);  
    532          
    533          		//使能DMA2通道3 
    534          		DMA_Cmd(DMA2_Channel3,ENABLE);  
    535          
    536          		//采用DMA方式接收  
    537          		USART_DMACmd(UART4,USART_DMAReq_Rx,ENABLE); 
    538          
    539          		/* Enable UART4 DMA Tx request */
    540          		USART_DMACmd(UART4, USART_DMAReq_Tx , ENABLE);
    541          
    542          		USART_Cmd(UART4, ENABLE);
    543          	}
    544          #endif
    545          }
    546          
    547          /*
    548          * @brief: 串口中断的初始化
    549          */
    550          static void BT816_NVIC_config(unsigned int bt_channel)
    551          {
    552          	NVIC_InitTypeDef				NVIC_InitStructure;
    553          #if(BT_MODULE_CONFIG & USE_BT1_MODULE)
    554          	if (bt_channel == BT1_MODULE)
    555          	{
    556          		//中断配置  
    557          		USART_ITConfig(USART1,USART_IT_TC,DISABLE);  
    558          		USART_ITConfig(USART1,USART_IT_RXNE,DISABLE);  
    559          		USART_ITConfig(USART1,USART_IT_IDLE,ENABLE);    
    560          
    561          		//配置UART4中断  
    562          		NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
    563          		NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQChannel;               //通道设置为串口2中断    
    564          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;       //中断占先等级0    
    565          		//NVIC_InitStructure.NVIC_IRQChannelSubPriority = 6;              //中断响应优先级0    
    566          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                 //打开中断    
    567          		NVIC_Init(&NVIC_InitStructure);  
    568          
    569          		/* Enable the DMA1 Channel4 Interrupt */
    570          		NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel4_IRQChannel;
    571          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    572          		//NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    573          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    574          		NVIC_Init(&NVIC_InitStructure);
    575          
    576          		DMA_ITConfig(DMA1_Channel4, DMA_IT_TC | DMA_IT_TE, ENABLE);
    577          		DMA_ClearFlag(DMA1_FLAG_TC4);
    578          	}
    579          #endif
    580          
    581          #if(BT_MODULE_CONFIG & USE_BT2_MODULE)
    582          	if (bt_channel == BT2_MODULE)
    583          	{
    584          		//中断配置  
    585          		USART_ITConfig(USART2,USART_IT_TC,DISABLE);  
    586          		USART_ITConfig(USART2,USART_IT_RXNE,DISABLE);  
    587          		USART_ITConfig(USART2,USART_IT_IDLE,ENABLE);    
    588          
    589          		//配置USART2中断  
    590          		NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
    591          		NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQChannel;               //通道设置为串口2中断    
    592          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;       //中断占先等级0    
    593          		//NVIC_InitStructure.NVIC_IRQChannelSubPriority = 6;              //中断响应优先级0    
    594          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                 //打开中断    
    595          		NVIC_Init(&NVIC_InitStructure);  
    596          
    597          		/* Enable the DMA1 Channel7 Interrupt */
    598          		NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel7_IRQChannel;
    599          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    600          		//NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    601          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    602          		NVIC_Init(&NVIC_InitStructure);
    603          
    604          		DMA_ITConfig(DMA1_Channel7, DMA_IT_TC | DMA_IT_TE, ENABLE);
    605          		DMA_ClearFlag(DMA1_FLAG_TC7);
    606          	}
    607          #endif
    608          
    609          #if(BT_MODULE_CONFIG & USE_BT3_MODULE)
    610          	if (bt_channel == BT3_MODULE)
    611          	{
    612          		//中断配置  
    613          		USART_ITConfig(USART3,USART_IT_TC,DISABLE);  
    614          		USART_ITConfig(USART3,USART_IT_RXNE,DISABLE);  
    615          		USART_ITConfig(USART3,USART_IT_IDLE,ENABLE);    
    616          
    617          		//配置USART3中断  
    618          		NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
    619          		NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQChannel;               //通道设置为串口2中断    
    620          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;       //中断占先等级0    
    621          		//NVIC_InitStructure.NVIC_IRQChannelSubPriority = 6;              //中断响应优先级0    
    622          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                 //打开中断    
    623          		NVIC_Init(&NVIC_InitStructure);  
    624          
    625          		/* Enable the DMA1 Channel2 Interrupt */
    626          		NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel2_IRQChannel;
    627          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    628          		//NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    629          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    630          		NVIC_Init(&NVIC_InitStructure);
    631          
    632          		DMA_ITConfig(DMA1_Channel2, DMA_IT_TC | DMA_IT_TE, ENABLE);
    633          		DMA_ClearFlag(DMA1_FLAG_TC2);
    634          	}
    635          #endif
    636          
    637          #if(BT_MODULE_CONFIG & USE_BT4_MODULE)
    638          	if (bt_channel == BT4_MODULE)
    639          	{
    640          		//中断配置  
    641          		USART_ITConfig(UART4,USART_IT_TC,DISABLE);  
    642          		USART_ITConfig(UART4,USART_IT_RXNE,DISABLE);  
    643          		USART_ITConfig(UART4,USART_IT_IDLE,ENABLE);    
    644          
    645          		//配置UART4中断  
    646          		NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
    647          		NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQChannel;               //通道设置为串口2中断    
    648          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;       //中断占先等级0    
    649          		//NVIC_InitStructure.NVIC_IRQChannelSubPriority = 6;              //中断响应优先级0    
    650          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                 //打开中断    
    651          		NVIC_Init(&NVIC_InitStructure);  
    652          
    653          		/* Enable the DMA2 Channel5 Interrupt */
    654          		NVIC_InitStructure.NVIC_IRQChannel = DMA2_Channel4_5_IRQChannel;
    655          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    656          		//NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    657          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    658          		NVIC_Init(&NVIC_InitStructure);
    659          
    660          		DMA_ITConfig(DMA2_Channel5, DMA_IT_TC | DMA_IT_TE, ENABLE);
    661          		DMA_ClearFlag(DMA2_FLAG_TC5);
    662          	}
    663          #endif
    664          }
    665          
    666          
    667          /**
    668          * @brief  发数据给蓝牙模块
    669          * @param[in] unsigned char *pData 要发送的数据
    670          * @param[in] int length 要发送数据的长度
    671          */
    672          static void send_data_to_BT(unsigned int bt_channel,const unsigned char *pData, unsigned int length)
    673          {
    674          #if(BT_MODULE_CONFIG & USE_BT1_MODULE)
    675          	if (bt_channel == BT1_MODULE)
    676          	{
    677          		//while(length--)
    678          		//{
    679          		//	USART_SendData(USART1, *pData++);
    680          		//	while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET)
    681          		//	{
    682          		//	}
    683          		//}
    684          		//while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET){};
    685          
    686          		/* disable DMA */
    687          		DMA_Cmd(DMA1_Channel4, DISABLE);
    688          
    689          		/* set buffer address */
    690          		memcpy(BT816_send_buff[BT1_MODULE],pData,length);
    691          
    692          		DMA1_Channel4->CMAR = (u32)&BT816_send_buff[BT1_MODULE][0];
    693          		/* set size */
    694          		DMA1_Channel4->CNDTR = length;
    695          
    696          		USART_DMACmd(USART1, USART_DMAReq_Tx , ENABLE);
    697          		/* enable DMA */
    698          		DMA_Cmd(DMA1_Channel4, ENABLE);
    699          
    700          		while(DMA1_Channel4->CNDTR);
    701          		while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET){};
    702          	}
    703          #endif
    704          
    705          #if(BT_MODULE_CONFIG & USE_BT2_MODULE)
    706          	if (bt_channel == BT2_MODULE)
    707          	{
    708          		//while(length--)
    709          		//{
    710          		//	USART_SendData(USART2, *pData++);
    711          		//	while(USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET)
    712          		//	{
    713          		//	}
    714          		//}
    715          		//while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET){};
    716          
    717          		/* disable DMA */
    718          		DMA_Cmd(DMA1_Channel7, DISABLE);
    719          
    720          		/* set buffer address */
    721          		memcpy(BT816_send_buff[BT2_MODULE],pData,length);
    722          
    723          		DMA1_Channel7->CMAR = (u32)&BT816_send_buff[BT2_MODULE][0];
    724          		/* set size */
    725          		DMA1_Channel7->CNDTR = length;
    726          
    727          		USART_DMACmd(USART2, USART_DMAReq_Tx , ENABLE);
    728          		/* enable DMA */
    729          		DMA_Cmd(DMA1_Channel7, ENABLE);
    730          
    731          		while(DMA1_Channel7->CNDTR);
    732          		while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET){};
    733          	}
    734          #endif
    735          
    736          #if(BT_MODULE_CONFIG & USE_BT3_MODULE)
    737          	if (bt_channel == BT3_MODULE)
    738          	{
    739          		//while(length--)
    740          		//{
    741          		//	USART_SendData(USART3, *pData++);
    742          		//	while(USART_GetFlagStatus(USART3, USART_FLAG_TXE) == RESET)
    743          		//	{
    744          		//	}
    745          		//}
    746          		//while(USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET){};
    747          
    748          		/* disable DMA */
    749          		DMA_Cmd(DMA1_Channel2, DISABLE);
    750          
    751          		/* set buffer address */
    752          		memcpy(BT816_send_buff[BT3_MODULE],pData,length);
    753          
    754          		DMA1_Channel2->CMAR = (u32)&BT816_send_buff[BT3_MODULE][0];
    755          		/* set size */
    756          		DMA1_Channel2->CNDTR = length;
    757          
    758          		USART_DMACmd(USART3, USART_DMAReq_Tx , ENABLE);
    759          		/* enable DMA */
    760          		DMA_Cmd(DMA1_Channel2, ENABLE);
    761          
    762          		while(DMA1_Channel2->CNDTR);
    763          		while(USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET){};
    764          	}
    765          #endif
    766          #if(BT_MODULE_CONFIG & USE_BT4_MODULE)
    767          	if (bt_channel == BT4_MODULE)
    768          	{
    769          	//while(length--)
    770          	//{
    771          	//	USART_SendData(UART4, *pData++);
    772          	//	while(USART_GetFlagStatus(UART4, USART_FLAG_TXE) == RESET)
    773          	//	{
    774          	//	}
    775          	//}
    776          	//while(USART_GetFlagStatus(UART4, USART_FLAG_TC) == RESET){};
    777          
    778          	/* disable DMA */
    779          	DMA_Cmd(DMA2_Channel5, DISABLE);
    780          
    781          	/* set buffer address */
    782          	memcpy(BT816_send_buff[BT4_MODULE],pData,length);
    783          
    784          	DMA2_Channel5->CMAR = (u32)&BT816_send_buff[BT4_MODULE][0];
    785          	/* set size */
    786          	DMA2_Channel5->CNDTR = length;
    787          
    788          	USART_DMACmd(UART4, USART_DMAReq_Tx , ENABLE);
    789          	/* enable DMA */
    790          	DMA_Cmd(DMA2_Channel5, ENABLE);
    791          
    792          	while(DMA2_Channel5->CNDTR);
    793          	while(USART_GetFlagStatus(UART4, USART_FLAG_TC) == RESET){};
    794          	}
    795          #endif
    796          }
    797          
    798          
    799          /*
    800           * @brief 清空接收蓝牙模块响应数据的buffer
    801          */
    802          static void BT816_reset_resVar(unsigned int bt_channel)
    803          {
    804          #if(BT_MODULE_CONFIG & USE_BT1_MODULE)
    805          	if (bt_channel == BT1_MODULE)
    806          	{
    807          		BT816_res[bt_channel].DataPos = 0;
    808          		BT816_res[bt_channel].DataLength = 0;
    809          		BT816_res[bt_channel].status	 = BT816_RES_INIT;
    810          		bt_connect_status &= ~(1<<BT1_MODULE);
    811          		DMA1_Channel5->CNDTR = BT816_RES_BUFFER_LEN; 
    812          	}
    813          #endif
    814          
    815          #if(BT_MODULE_CONFIG & USE_BT2_MODULE)
    816          	if (bt_channel == BT2_MODULE)
    817          	{
    818          		BT816_res[bt_channel].DataPos = 0;
    819          		BT816_res[bt_channel].DataLength = 0;
    820          		BT816_res[bt_channel].status	 = BT816_RES_INIT;
    821          		bt_connect_status &= ~(1<<BT2_MODULE);
    822          		DMA1_Channel6->CNDTR = BT816_RES_BUFFER_LEN; 
    823          	}
    824          #endif
    825          
    826          #if(BT_MODULE_CONFIG & USE_BT3_MODULE)
    827          	if (bt_channel == BT3_MODULE)
    828          	{
    829          		BT816_res[bt_channel].DataPos = 0;
    830          		BT816_res[bt_channel].DataLength = 0;
    831          		BT816_res[bt_channel].status	 = BT816_RES_INIT;
    832          		bt_connect_status &= ~(1<<BT3_MODULE);
    833          		DMA1_Channel3->CNDTR = BT816_RES_BUFFER_LEN; 
    834          	}
    835          #endif
    836          
    837          #if(BT_MODULE_CONFIG & USE_BT4_MODULE)
    838          	if (bt_channel == BT4_MODULE)
    839          	{
    840          	BT816_res[bt_channel].DataPos = 0;
    841          	BT816_res[bt_channel].DataLength = 0;
    842          	BT816_res[bt_channel].status	 = BT816_RES_INIT;
    843          	bt_connect_status &= ~(1<<BT4_MODULE);
    844          	DMA2_Channel3->CNDTR = BT816_RES_BUFFER_LEN;
    845          	}
    846          #endif
    847          }
    848          
    849          
    850          /**
    851          * @brief 处理host收到BT816的数据
    852          * @param[in] unsigned char c 读入的字符
    853          * @return 0:success put in buffer
    854          *        -1:fail
    855          */
    856          #if(BT_MODULE_CONFIG & USE_BT1_MODULE)
    857          int BT816_Channel1_RxISRHandler(unsigned char *res, unsigned int res_len)
    858          {	
    859          	int i,len;
    860          	if (BT1_CONNECT)
    861          	{
    862          		//已经处于连接状态，蓝牙模块进入数据透传模式
    863          		set_BT1_BUSY();
    864          		ringbuffer_put(&spp_ringbuf[BT1_MODULE],res,res_len);
    865          		DMA1_Channel5->CNDTR = BT816_RES_BUFFER_LEN;
    866          		if (ringbuffer_data_len(&spp_ringbuf[BT1_MODULE]) >= RING_BUFF_FULL_TH)
    867          		{
    868          			set_BT1_BUSY();
    869          		}
    870          		else
    871          		{
    872          			set_BT1_FREE();
    873          		}	
    874          	}
    875          	else
    876          	{
    877          		if (res_len > 5)
    878          		{
    879          			BT816_res[BT1_MODULE].DataLength = res_len;
    880          			if ((res[0] == 0x0d)&&(res[1] == 0x0a)			\
    881          				&&(res[res_len-2] == 0x0d)&&(res[res_len-1] == 0x0a))
    882          			{
    883          				if (BT816_res[BT1_MODULE].status == BT816_RES_INIT)
    884          				{
    885          					BT816_res[BT1_MODULE].status = BT816_RES_INVALID_STATE;
    886          					for (i = 3; i < res_len-2;i++)
    887          					{
    888          
    889          						if ((res[i] == 'o')&&(res[i+1] == 'k'))
    890          						{
    891          							BT816_res[BT1_MODULE].status = BT816_RES_SUCCESS;
    892          							break;
    893          						}
    894          
    895          						if (res[i] == '=')
    896          						{
    897          							BT816_res[BT1_MODULE].status = BT816_RES_PAYLOAD;
    898          							break;
    899          						}
    900          					}
    901          				}
    902          			}
    903          			else
    904          			{
    905          				BT816_res[BT1_MODULE].status = BT816_RES_UNKOWN;
    906          			}
    907          		}
    908          	}
    909          	
    910                  
    911                  return 0;
    912          }
    913          #endif
    914          
    915          #if(BT_MODULE_CONFIG & USE_BT2_MODULE)
    916          int BT816_Channel2_RxISRHandler(unsigned char *res, unsigned int res_len)
    917          {	
    918          	int i,len;
    919          	if (BT2_CONNECT)
    920          	{
    921          		//已经处于连接状态，蓝牙模块进入数据透传模式
    922          		set_BT2_BUSY();
    923          		ringbuffer_put(&spp_ringbuf[BT2_MODULE],res,res_len);
    924          		DMA1_Channel6->CNDTR = BT816_RES_BUFFER_LEN;
    925          		if (ringbuffer_data_len(&spp_ringbuf[BT2_MODULE]) >= RING_BUFF_FULL_TH)
    926          		{
    927          			set_BT2_BUSY();
    928          		}
    929          		else
    930          		{
    931          			set_BT2_FREE();
    932          		}
    933          	}
    934          	else
    935          	{
    936          		if (res_len > 5)
    937          		{
    938          			BT816_res[BT2_MODULE].DataLength = res_len;
    939          			if ((res[0] == 0x0d)&&(res[1] == 0x0a)			\
    940          				&&(res[res_len-2] == 0x0d)&&(res[res_len-1] == 0x0a))
    941          			{
    942          				if (BT816_res[BT2_MODULE].status == BT816_RES_INIT)
    943          				{
    944          					BT816_res[BT2_MODULE].status = BT816_RES_INVALID_STATE;
    945          					for (i = 3; i < res_len-2;i++)
    946          					{
    947          
    948          						if ((res[i] == 'o')&&(res[i+1] == 'k'))
    949          						{
    950          							BT816_res[BT2_MODULE].status = BT816_RES_SUCCESS;
    951          							break;
    952          						}
    953          
    954          						if (res[i] == '=')
    955          						{
    956          							BT816_res[BT2_MODULE].status = BT816_RES_PAYLOAD;
    957          							break;
    958          						}
    959          					}
    960          				}
    961          			}
    962          			else
    963          			{
    964          				BT816_res[BT2_MODULE].status = BT816_RES_UNKOWN;
    965          			}
    966          		}
    967          	}
    968          
    969          
    970          	return 0;
    971          }
    972          #endif
    973          
    974          #if(BT_MODULE_CONFIG & USE_BT3_MODULE)
    975          int BT816_Channel3_RxISRHandler(unsigned char *res, unsigned int res_len)
    976          {	
    977          	int i,len;
    978          	if (BT3_CONNECT)
    979          	{
    980          		//已经处于连接状态，蓝牙模块进入数据透传模式
    981          		set_BT3_BUSY();
    982          		ringbuffer_put(&spp_ringbuf[BT3_MODULE],res,res_len);
    983          		DMA1_Channel3->CNDTR = BT816_RES_BUFFER_LEN;
    984          		if (ringbuffer_data_len(&spp_ringbuf[BT3_MODULE]) >= RING_BUFF_FULL_TH)
    985          		{
    986          			set_BT3_BUSY();
    987          		}
    988          		else
    989          		{
    990          			set_BT3_FREE();
    991          		}
    992          	}
    993          	else
    994          	{
    995          		if (res_len > 5)
    996          		{
    997          			BT816_res[BT3_MODULE].DataLength = res_len;
    998          			if ((res[0] == 0x0d)&&(res[1] == 0x0a)			\
    999          				&&(res[res_len-2] == 0x0d)&&(res[res_len-1] == 0x0a))
   1000          			{
   1001          				if (BT816_res[BT3_MODULE].status == BT816_RES_INIT)
   1002          				{
   1003          					BT816_res[BT3_MODULE].status = BT816_RES_INVALID_STATE;
   1004          					for (i = 3; i < res_len-2;i++)
   1005          					{
   1006          
   1007          						if ((res[i] == 'o')&&(res[i+1] == 'k'))
   1008          						{
   1009          							BT816_res[BT3_MODULE].status = BT816_RES_SUCCESS;
   1010          							break;
   1011          						}
   1012          
   1013          						if (res[i] == '=')
   1014          						{
   1015          							BT816_res[BT3_MODULE].status = BT816_RES_PAYLOAD;
   1016          							break;
   1017          						}
   1018          					}
   1019          				}
   1020          			}
   1021          			else
   1022          			{
   1023          				BT816_res[BT3_MODULE].status = BT816_RES_UNKOWN;
   1024          			}
   1025          		}
   1026          	}
   1027          
   1028          
   1029          	return 0;
   1030          }
   1031          #endif
   1032          
   1033          #if(BT_MODULE_CONFIG & USE_BT4_MODULE)
   1034          int BT816_Channel4_RxISRHandler(unsigned char *res, unsigned int res_len)
   1035          {	
   1036          	int i,len;
   1037          	if (BT4_CONNECT)
   1038          	{
   1039          		//已经处于连接状态，蓝牙模块进入数据透传模式
   1040          		set_BT4_BUSY();
   1041          		ringbuffer_put(&spp_ringbuf[BT4_MODULE],res,res_len);
   1042          		DMA2_Channel3->CNDTR = BT816_RES_BUFFER_LEN;
   1043          		if (ringbuffer_data_len(&spp_ringbuf[BT4_MODULE]) >= RING_BUFF_FULL_TH)
   1044          		{
   1045          			set_BT4_BUSY();
   1046          		}
   1047          		else
   1048          		{
   1049          			set_BT4_FREE();
   1050          		}
   1051          	}
   1052          	else
   1053          	{
   1054          		if (res_len > 5)
   1055          		{
   1056          			BT816_res[BT4_MODULE].DataLength = res_len;
   1057          			if ((res[0] == 0x0d)&&(res[1] == 0x0a)			\
   1058          				&&(res[res_len-2] == 0x0d)&&(res[res_len-1] == 0x0a))
   1059          			{
   1060          				if (BT816_res[BT4_MODULE].status == BT816_RES_INIT)
   1061          				{
   1062          					BT816_res[BT4_MODULE].status = BT816_RES_INVALID_STATE;
   1063          					for (i = 3; i < res_len-2;i++)
   1064          					{
   1065          
   1066          						if ((res[i] == 'o')&&(res[i+1] == 'k'))
   1067          						{
   1068          							BT816_res[BT4_MODULE].status = BT816_RES_SUCCESS;
   1069          							break;
   1070          						}
   1071          
   1072          						if (res[i] == '=')
   1073          						{
   1074          							BT816_res[BT4_MODULE].status = BT816_RES_PAYLOAD;
   1075          							break;
   1076          						}
   1077          					}
   1078          				}
   1079          			}
   1080          			else
   1081          			{
   1082          				BT816_res[BT4_MODULE].status = BT816_RES_UNKOWN;
   1083          			}
   1084          		}
   1085          	}
   1086          
   1087          
   1088          	return 0;
   1089          }
   1090          #endif
   1091          #define EXPECT_RES_FORMAT1_TYPE		1		//设置命令的响应，OK or Error
   1092          #define EXPECT_RES_FORMAT2_TYPE		2		//查询命令的响应，payload
   1093          
   1094          /**
   1095          * @brief  发命令给蓝牙模块BT816S01,并等待响应结果
   1096          * @param[in] unsigned char *pData 要发送的数据
   1097          * @param[in] unsigned int	length 要发送数据的长度
   1098          * @param[in] unsigned char  type   期待响应数据的命令类型	
   1099          *							EXPECT_RES_FORMAT1_TYPE: response format1		
   1100          *							EXPECT_RES_FORMAT2_TYPE:response format2
   1101          * @return		0: 成功
   1102          *				-1: 失败
   1103          *				-2: 未知响应，可能是响应解析函数有BUG，需要调试
   1104          *				-3：响应超时
   1105          * @note	等待一个响应帧的命令
   1106          */
   1107          static int BT816_write_cmd(unsigned int bt_channel,const unsigned char *pData, unsigned int length,unsigned char type)
   1108          {
   1109          	unsigned int	wait_cnt;
   1110          	send_data_to_BT(bt_channel,pData, length);
   1111          	BT816_reset_resVar(bt_channel);
   1112          	wait_cnt = 200;
   1113          	while (wait_cnt)
   1114          	{
   1115          		if (((BT816_res[bt_channel].status == BT816_RES_SUCCESS)&&(type == EXPECT_RES_FORMAT1_TYPE)) || ((BT816_res[bt_channel].status == BT816_RES_PAYLOAD)&&(type == EXPECT_RES_FORMAT2_TYPE)))
   1116          		{
   1117          			return 0;
   1118          		}
   1119          		else if(BT816_res[bt_channel].status == BT816_RES_INVALID_STATE)
   1120          		{
   1121          			return -1;
   1122          		}
   1123          		//OSTimeDlyHMSM(0,0,0,20);
   1124          		delay_ms(20);
   1125                          wait_cnt--;
   1126          	}
   1127          
   1128          	return -3;
   1129          }
   1130          
   1131          
   1132          //const unsigned char	*query_version_cmd="AT+VER=?";
   1133          //const unsigned char	*set_device_name_cmd="AT+DNAME=%s";
   1134          static unsigned char	token[10],token_value[15];
   1135          /*
   1136           * @brief 蓝牙模块BT816S01的复位
   1137          */
   1138          int BT816_Reset(void)
   1139          {
   1140          	unsigned int	wait_cnt,i,j;
   1141          	unsigned char	stat;
   1142          	int ret;
   1143          
   1144          #if(BT_MODULE_CONFIG & USE_BT1_MODULE)
   1145          	//拉低复位信号100ms
   1146          	GPIO_ResetBits(GPIOB, GPIO_Pin_9);
   1147          	delay_ms(100);
   1148              GPIO_SetBits(GPIOB, GPIO_Pin_9);
   1149          
   1150          	BT816_reset_resVar(BT1_MODULE);
   1151          #endif
   1152          
   1153          #if(BT_MODULE_CONFIG & USE_BT2_MODULE)
   1154          	//拉低复位信号100ms
   1155          	GPIO_ResetBits(GPIOC, GPIO_Pin_3);
   1156          	delay_ms(100);
   1157          	GPIO_SetBits(GPIOC, GPIO_Pin_3);
   1158          
   1159          	BT816_reset_resVar(BT2_MODULE);
   1160          #endif
   1161          
   1162          #if(BT_MODULE_CONFIG & USE_BT3_MODULE)
   1163          	//拉低复位信号100ms
   1164          	GPIO_ResetBits(GPIOE, GPIO_Pin_13);
   1165          	delay_ms(100);
   1166          	GPIO_SetBits(GPIOE, GPIO_Pin_13);
   1167          
   1168          	BT816_reset_resVar(BT3_MODULE);
   1169          #endif
   1170          
   1171          #if(BT_MODULE_CONFIG & USE_BT4_MODULE)
   1172          	//拉低复位信号100ms
   1173          	GPIO_ResetBits(GPIOD, GPIO_Pin_1);
   1174          	delay_ms(100);
   1175          	GPIO_SetBits(GPIOD, GPIO_Pin_1);
   1176          
   1177          	BT816_reset_resVar(BT4_MODULE);
   1178          #endif
   1179          #if 0
   1180          	wait_cnt = 20;
   1181          	ret = 0;
   1182          	while (wait_cnt)
   1183          	{
   1184          		if (BT816_res[].status == BT816_RES_PAYLOAD)
   1185          		{
   1186          			USART_Cmd(UART4, DISABLE);
   1187          			stat = 0;
   1188          			for (i = 0; i < BT816_res.DataLength;i++)
   1189          			{
   1190          				if (BT816_res.DataBuffer[i] == '+')
   1191          				{
   1192          					stat = 1;
   1193          					j = 0;
   1194          					continue;
   1195          				}
   1196          				else if (BT816_res.DataBuffer[i] == '=')
   1197          				{
   1198          					stat = 2;
   1199          					j = 0;
   1200          					continue;
   1201          				}
   1202          				else if (BT816_res.DataBuffer[i] == 0x0d)
   1203          				{
   1204          					if (stat == 2)
   1205          					{
   1206          						if (memcmp(token,"BDTP",4)==0)
   1207          						{
   1208          							if (token_value[0] != '0')
   1209          							{
   1210          								ret |= 0x01;
   1211          							}
   1212          						}
   1213          #ifdef DEBUG_VER
   1214          						else if (memcmp(token,"BDVER",5)==0)
   1215          						{
   1216          							token_value[j]=0;
   1217          							printf("BlueTooth Module Ver:%s\r\n",token_value);
   1218          						}
   1219          						else if (memcmp(token,"BDADDR",6)==0)
   1220          						{
   1221          							token_value[j]=0;
   1222          							printf("BlueTooth Module Addr:%s\r\n",token_value);
   1223          						}
   1224          #endif
   1225          						else if (memcmp(token,"BDMODE",6)==0)
   1226          						{
   1227          #ifdef HID_MODE
   1228          							if (token_value[0] != '2')
   1229          							{
   1230          								ret |= 0x02;
   1231          							}
   1232          #else
   1233          							if (token_value[0] != '1')
   1234          							{
   1235          								ret |= 0x02;
   1236          							}
   1237          #endif
   1238          						}
   1239          					}
   1240          					stat = 0;
   1241          					continue;
   1242          				}
   1243          
   1244          				if (stat == 1)
   1245          				{
   1246          					token[j] = BT816_res.DataBuffer[i];
   1247          					j++;
   1248          				}
   1249          				else if (stat == 2)
   1250          				{
   1251          					token_value[j] = BT816_res.DataBuffer[i];
   1252          					j++;
   1253          				}
   1254          			} 
   1255          			USART_Cmd(UART4, ENABLE);
   1256          			return ret;
   1257          		}
   1258          		//OSTimeDlyHMSM(0,0,0,100);
   1259                          wait_cnt--;
   1260                          delay_ms(100);
   1261          	}
   1262          
   1263          	return -1;
   1264          #endif
   1265          
   1266          	delay_ms(1000);
   1267          	return 0;
   1268          }
   1269          
   1270          /*
   1271           * @brief 查询蓝牙模块BT816的版本号
   1272           * @param[out]  unsigned char *ver_buffer  返回查询到的版本号，如果为空表示查询失败
   1273          */
   1274          int BT816_query_version(unsigned int bt_channel,unsigned char *ver_buffer)
   1275          {
   1276          	unsigned char	buffer[21];
   1277          	int		i,ret;
   1278          
   1279          	assert(ver_buffer != 0);
   1280          	ver_buffer[0] = 0;
   1281          	memcpy(buffer,"AT+VER\x0d\x0a",8);
   1282          	ret = BT816_write_cmd(bt_channel,(const unsigned char*)buffer,8,EXPECT_RES_FORMAT2_TYPE);
   1283          	if (ret)
   1284          	{
   1285          		return ret;
   1286          	}
   1287          
   1288          	if (memcmp(&BT816_res[bt_channel].DataBuffer[3],"VER=",4) == 0)
   1289          	{
   1290          		for (i = 0; i < ((BT816_res[bt_channel].DataLength-9) > 20)?20:(BT816_res[bt_channel].DataLength-9);i++)
   1291          		{
   1292          			if (BT816_res[bt_channel].DataBuffer[7+i] == 0x0d)
   1293          			{
   1294          				break;
   1295          			}
   1296          
   1297          			ver_buffer[i] = BT816_res[bt_channel].DataBuffer[7+i];
   1298          		}
   1299          		ver_buffer[i] = 0;
   1300          		return 0;
   1301          	}
   1302          
   1303          	return -1;
   1304          }
   1305          
   1306          
   1307          /*
   1308           * @brief 查询蓝牙模块的设备名称
   1309           * @param[out]  unsigned char *name  模块名称,字符串
   1310           * @return 0: 查询成功		else：查询失败
   1311           * @note 从手册暂时没有看到支持的名称的最大长度是多少，所以如果设置的名称太长可能会导致缓冲区溢出
   1312           *       在此接口中将设备名称限定为最长支持20个字节
   1313          */
   1314          int BT816_query_name(unsigned int bt_channel,unsigned char *name)
   1315          {
   1316          	unsigned char	buffer[15];
   1317          	int		i,ret;
   1318          
   1319          	assert(name != 0);
   1320          	name[0] = 0;
   1321          	memcpy(buffer,"AT+NAME\x0d\x0a",9);
   1322          
   1323          	ret = BT816_write_cmd(bt_channel,(const unsigned char*)buffer,9,EXPECT_RES_FORMAT2_TYPE);
   1324          	if (ret)
   1325          	{
   1326          		return ret;
   1327          	}
   1328          
   1329          	if (memcmp(&BT816_res[bt_channel].DataBuffer[3],"NAME",4) == 0)
   1330          	{
   1331          		for (i = 0; i < ((BT816_res[bt_channel].DataLength-10) > 20)?20:(BT816_res[bt_channel].DataLength-10);i++)
   1332          		{
   1333          			if (BT816_res[bt_channel].DataBuffer[8+i] == 0x0d)
   1334          			{
   1335          				break;
   1336          			}
   1337          
   1338          			name[i] = BT816_res[bt_channel].DataBuffer[8+i];
   1339          		}
   1340          		name[i] = 0;
   1341          		return 0;
   1342          	}
   1343          
   1344          	return -1; 
   1345          }
   1346          
   1347          /*
   1348           * @brief 查询和设置蓝牙模块的设备名称
   1349           * @param[in]  unsigned char *name  设置的名称,字符串
   1350           * @return 0: 设置成功		else：设置失败
   1351           * @note 从手册暂时没有看到支持的名称的最大长度是多少，所以如果设置的名称太长可能会设置失败
   1352           *       在此接口中将设备名称限定为最长支持22个字节
   1353          */
   1354          int BT816_set_name(unsigned int bt_channel,unsigned char *name)
   1355          {
   1356          	unsigned char	buffer[33];
   1357          	int		len;
   1358          
   1359          	assert(name != 0);
   1360          	memcpy(buffer,"AT+NAME=",8);
   1361          	len = strlen((char const*)name);
   1362          	if (len>22)
   1363          	{
   1364          		memcpy(buffer+8,name,22);
   1365          		buffer[30] = 0x0d;
   1366          		buffer[31] = 0x0a;
   1367          		len = 32;
   1368          	}
   1369          	else
   1370          	{
   1371          		memcpy(buffer+8,name,len);
   1372          		buffer[8+len] = 0x0d;
   1373          		buffer[9+len] = 0x0a;
   1374          		len += 10;
   1375          	}
   1376          
   1377          	return BT816_write_cmd(bt_channel,(const unsigned char*)buffer,len,EXPECT_RES_FORMAT1_TYPE); 
   1378          }
   1379          
   1380          
   1381          /*
   1382           * @brief 查询蓝牙模块HID当前的连接状态  	
   1383           * @return <0 ：发送失败	0: unkown 	1: connected    2： disconnect
   1384           * @note 
   1385          */
   1386          int BT816_connect_status(unsigned int bt_channel)
   1387          {
   1388          	unsigned int i;
   1389          #if(BT_MODULE_CONFIG & USE_BT1_MODULE)
   1390          	if (bt_channel == BT1_MODULE)
   1391          	{
   1392          		if(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7))
   1393          		{
   1394          			for (i=0;i < 2000;i++);		//延时一小段时间，防止是因为抖动造成的
   1395          			if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_7))
   1396          			{
   1397          				bt_connect_status |= (1<<BT1_MODULE);
   1398          				return BT_MODULE_STATUS_CONNECTED;
   1399          			}
   1400          			else
   1401          			{
   1402          				bt_connect_status &= ~(1<<BT1_MODULE);
   1403          				return BT_MODULE_STATUS_DISCONNECT;
   1404          			}
   1405          		}
   1406          		else
   1407          		{
   1408          			bt_connect_status &= ~(1<<BT1_MODULE);
   1409          			return BT_MODULE_STATUS_DISCONNECT;
   1410          		}
   1411          	}
   1412          #endif
   1413          
   1414          #if(BT_MODULE_CONFIG & USE_BT2_MODULE)
   1415          	if (bt_channel == BT2_MODULE)
   1416          	{
   1417          		if(GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2))
   1418          		{
   1419          			for (i=0;i < 2000;i++);		//延时一小段时间，防止是因为抖动造成的
   1420          			if(GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_2))
   1421          			{
   1422          				bt_connect_status |= (1<<BT2_MODULE);
   1423          				return BT_MODULE_STATUS_CONNECTED;
   1424          			}
   1425          			else
   1426          			{
   1427          				bt_connect_status &= ~(1<<BT2_MODULE);
   1428          				return BT_MODULE_STATUS_DISCONNECT;
   1429          			}
   1430          		}
   1431          		else
   1432          		{
   1433          			bt_connect_status &= ~(1<<BT2_MODULE);
   1434          			return BT_MODULE_STATUS_DISCONNECT;
   1435          		}
   1436          	}
   1437          #endif
   1438          
   1439          #if(BT_MODULE_CONFIG & USE_BT3_MODULE)
   1440          	if (bt_channel == BT3_MODULE)
   1441          	{
   1442          		if(GPIO_ReadInputDataBit(GPIOE, GPIO_Pin_14))
   1443          		{
   1444          			for (i=0;i < 2000;i++);		//延时一小段时间，防止是因为抖动造成的
   1445          			if(GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_14))
   1446          			{
   1447          				bt_connect_status |= (1<<BT3_MODULE);
   1448          				return BT_MODULE_STATUS_CONNECTED;
   1449          			}
   1450          			else
   1451          			{
   1452          				bt_connect_status &= ~(1<<BT3_MODULE);
   1453          				return BT_MODULE_STATUS_DISCONNECT;
   1454          			}
   1455          		}
   1456          		else
   1457          		{
   1458          			bt_connect_status &= ~(1<<BT3_MODULE);
   1459          			return BT_MODULE_STATUS_DISCONNECT;
   1460          		}
   1461          	}
   1462          #endif
   1463          
   1464          #if(BT_MODULE_CONFIG & USE_BT4_MODULE)
   1465          	if (bt_channel == BT4_MODULE)
   1466          	{
   1467          		if(GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_3))
   1468          		{
   1469          			for (i=0;i < 2000;i++);		//延时一小段时间，防止是因为抖动造成的
   1470          			if(GPIO_ReadInputDataBit(GPIOD,GPIO_Pin_3))
   1471          			{
   1472          				bt_connect_status |= (1<<BT4_MODULE);
   1473          				return BT_MODULE_STATUS_CONNECTED;
   1474          			}
   1475          			else
   1476          			{
   1477          				bt_connect_status &= ~(1<<BT4_MODULE);
   1478          				return BT_MODULE_STATUS_DISCONNECT;
   1479          			}
   1480          		}
   1481          		else
   1482          		{
   1483          			bt_connect_status &= ~(1<<BT4_MODULE);
   1484          			return BT_MODULE_STATUS_DISCONNECT;
   1485          		}
   1486          	}
   1487          #endif
   1488          
   1489          }
   1490          
   1491          
   1492          /*
   1493           * @brief 蓝牙模块BT816的初始化
   1494          */
   1495          int BT816_init(void)
   1496          {
   1497          	unsigned char	str[21];
   1498          	int ret,i;
   1499          	for (i = 0; i < MAX_PT_CHANNEL;i++)
   1500          	{
   1501          		BT816_res[i].DataBuffer = BT816_recbuffer[i];
   1502          		BT816_reset_resVar(i);
   1503          		//初始化一个SPP的环形缓冲区
   1504          		ringbuffer_init(&spp_ringbuf[i],spp_rec_buffer[i],SPP_BUFFER_LEN);
   1505          
   1506          		BT816_GPIO_config(i,115200);		//default波特率
   1507          		BT816_NVIC_config(i);
   1508          	}
   1509          
   1510          	ret = BT816_Reset();
   1511          	if(ret < 0)
   1512          	{
   1513          		ret = BT816_Reset();
   1514          		if(ret < 0)
   1515          		{
   1516          			return -1;
   1517          		}
   1518          	}
   1519          
   1520          #if 1
   1521          	if (BT816_query_name(BT1_MODULE,str))
   1522          	{
   1523          		return -4;
   1524          	}
   1525          
   1526          	if (memcmp(str,"HJ Pr",5) != 0)
   1527          	{
   1528          		if (BT816_set_name(BT1_MODULE,"HJ Printer1"))
   1529          		{
   1530          			return -5;
   1531          		}
   1532          	}
   1533          
   1534          	if (BT816_query_name(BT2_MODULE,str))
   1535          	{
   1536          		return -4;
   1537          	}
   1538          
   1539          	if (memcmp(str,"HJ Pr",5) != 0)
   1540          	{
   1541          		if (BT816_set_name(BT2_MODULE,"HJ Printer2"))
   1542          		{
   1543          			return -5;
   1544          		}
   1545          	}
   1546          
   1547          	if (BT816_query_name(BT3_MODULE,str))
   1548          	{
   1549          		return -4;
   1550          	}
   1551          
   1552          	if (memcmp(str,"HJ Pr",5) != 0)
   1553          	{
   1554          		if (BT816_set_name(BT3_MODULE,"HJ Printer3"))
   1555          		{
   1556          			return -5;
   1557          		}
   1558          	}
   1559          
   1560          	if (BT816_query_name(BT4_MODULE,str))
   1561          	{
   1562          		return -4;
   1563          	}
   1564          
   1565          	if (memcmp(str,"HJ Pr",5) != 0)
   1566          	{
   1567          		if (BT816_set_name(BT4_MODULE,"HJ Printer4"))
   1568          		{
   1569          			return -5;
   1570          		}
   1571          	}
   1572          
   1573          #endif
   1574          
   1575          	RESET_BT1_DMA();
   1576          	RESET_BT2_DMA();
   1577          	RESET_BT3_DMA();
   1578          	RESET_BT4_DMA();
   1579          	return 0;
   1580          }
   1581          
   1582          #endif

   Maximum stack usage in bytes:

     Function                    .cstack
     --------                    -------
     BT816_Channel1_RxISRHandler     16
     BT816_Channel2_RxISRHandler     16
     BT816_Channel3_RxISRHandler     16
     BT816_Channel4_RxISRHandler     16
     BT816_GPIO_config               80
     BT816_NVIC_config               16
     BT816_Reset                      8
     BT816_connect_status             8
     BT816_init                      32
     BT816_query_name                32
     BT816_query_version             40
     BT816_reset_resVar               0
     BT816_set_name                  56
     BT816_write_cmd                 16
     memcpy                           8
     ringbuffer_data_len              8
     ringbuffer_status                0
     send_data_to_BT                 16


   Section sizes:

     Function/Label                             Bytes
     --------------                             -----
     memcpy                                       14
     ringbuffer_status                            40
     ringbuffer_data_len                          68
     BT816_res                                    48
     BT816_send_buff                             128
     BT816_recbuffer                            1024
     spp_rec_buffer                             4096
     spp_ringbuf                                  64
     bt_connect_status                             1
     BT816_GPIO_config                          1536
     BT816_NVIC_config                           464
     send_data_to_BT                             340
     BT816_reset_resVar                          242
     BT816_Channel1_RxISRHandler                 194
     BT816_Channel2_RxISRHandler                 204
     BT816_Channel3_RxISRHandler                 216
     BT816_Channel4_RxISRHandler                 220
     BT816_write_cmd                             108
     BT816_Reset                                 152
     BT816_query_version                         208
     BT816_query_name                            208
     BT816_set_name                              132
     BT816_connect_status                        380
     BT816_init                                  472
     ??DataTable8                                  4
     ??DataTable10                                 4
     ??DataTable23                                 4
     ??DataTable30                                 4
     ??DataTable38                                 4
     ??DataTable45                                 4
     ??DataTable47                                 4
     ??DataTable53                                 4
     ??DataTable75                                 4
     ??DataTable76                                 4
     ??DataTable79                                 4
     ??DataTable80                                 4
     ??DataTable83                                 4
     ??DataTable84                                 4
     ??DataTable87                                 4
     ??DataTable88                                 4
     ??DataTable100                                4
     ??DataTable106                                4
     ??DataTable112                                4
     ??DataTable113                                4
     ??DataTable116                                4
     ??DataTable117                                4
     ??DataTable119                                4
     ??DataTable131                                4
     ?<Constant "ver_buffer != 0">                16
     ?<Constant "E:\\BT Printer\\FW\\src\\...">   40
     ?<Constant "AT+VER\r\n">                     12
     ?<Constant "VER=">                            8
     ?<Constant "name != 0">                      12
     ?<Constant "AT+NAME\r\n">                    12
     ?<Constant "NAME">                            8
     ?<Constant "AT+NAME=">                       12
     ?<Constant "HJ Printer1">                    12
     ?<Constant "HJ Pr">                           8
     ?<Constant "HJ Printer2">                    12
     ?<Constant "HJ Printer3">                    12
     ?<Constant "HJ Printer4">                    12

 
 5 361 bytes in section .bss
   176 bytes in section .rodata
 5 294 bytes in section .text
 
 5 280 bytes of CODE  memory (+ 14 bytes shared)
   176 bytes of CONST memory
 5 361 bytes of DATA  memory

Errors: none
Warnings: 13
