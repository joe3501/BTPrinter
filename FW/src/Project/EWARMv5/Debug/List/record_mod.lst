###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     11/Dec/2015  09:31:16 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\BT Printer\FW\src\App\record_mod.c                    #
#    Command line =  "E:\BT Printer\FW\src\App\record_mod.c" -D DEBUG_VER     #
#                    -lcN "E:\BT Printer\FW\src\Project\EWARMv5\Debug\List\"  #
#                    -o "E:\BT Printer\FW\src\Project\EWARMv5\Debug\Obj\"     #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 5.4\arm\INC\DLib_Config_Normal.h" -I "E:\BT    #
#                    Printer\FW\src\Project\EWARMv5\..\" -I "E:\BT            #
#                    Printer\FW\src\Project\EWARMv5\..\..\App\" -I "E:\BT     #
#                    Printer\FW\src\Project\EWARMv5\..\..\Drivers\" -I        #
#                    "E:\BT Printer\FW\src\Project\EWARMv5\..\..\FatFs\" -I   #
#                    "E:\BT Printer\FW\src\Project\EWARMv5\..\..\Lib\inc\"    #
#                    -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS\uC-C #
#                    PU\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS #
#                    \uC-LIB\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\.. #
#                    \uCOS\uCOS-II\Ports\" -I "E:\BT                          #
#                    Printer\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Source #
#                    \" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS\u #
#                    C-Probe\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\.. #
#                    \usb_lib\" -I "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 5.4\arm\INC\" -Ol                              #
#    List file    =  E:\BT Printer\FW\src\Project\EWARMv5\Debug\List\record_m #
#                    od.lst                                                   #
#    Object file  =  E:\BT Printer\FW\src\Project\EWARMv5\Debug\Obj\record_mo #
#                    d.o                                                      #
#                                                                             #
#                                                                             #
###############################################################################

E:\BT Printer\FW\src\App\record_mod.c
      1          /**
      2          ***************************************************************************
      3          * @file record_mod.c
      4          * @brief 
      5          ***************************************************************************
      6          *
      7          * @version V0.2.1
      8          * @author jiangcx
      9          * @date 2010年12月08日
     10          * @note 加入ECC校验纠错机制，recordformat时传入的recopt参数或上0x80即可
     11          *       开启ECC校验纠错功能
     12          *
     13          ***************************************************************************
     14          *
     15          * @version V0.2.0
     16          * @author jiangcx
     17          * @date 2010年12月06日
     18          * @note 加入length参数,约定每条记录的第一个字节为标志字节
     19          *
     20          ***************************************************************************
     21          *
     22          * @version V0.1.2
     23          * @author jiangcx
     24          * @date 2010年12月06日
     25          * @note 修复断电恢复代码bug。此版本为不带length参数的最终版本。
     26          *       下一个版本号将为V0.2.0加入length参数，与校验纠错机制
     27          *
     28          ***************************************************************************
     29          *
     30          * @version V0.1.1
     31          * @author jiangcx
     32          * @date 2010年11月18日
     33          * @note 加入写入校验机制
     34          *       支持6个记录区，与一个参数区，参数和单条记录长度必须小于2K-1
     35          *
     36          ***************************************************************************
     37          *
     38          * @copy
     39          *
     40          * 此代码为深圳江波龙电子有限公司项目代码，任何人及公司未经许可不得复制传播，或用于
     41          * 本公司以外的项目。本司保留一切追究权利。
     42          *
     43          * <h1><center>&copy; COPYRIGHT 2010 netcom</center></h1>
     44          */
     45          
     46          
     47          //note:如果需要支持更多的记录分区，只需要修改宏定义  RECTYPENUM	为希望支持的分区类型数
     48          
     49          
     50          #include "spi_flash.h"
     51          #include "record_mod.h"
     52          #include "rec_ecc.h"
     53          #include <string.h>
     54          
     55          #ifdef	RECORD_DEBUG
     56          #include <stdio.h>
     57          #endif
     58          
     59          #define RECTYPENUM					0x01		//支持1个种类的记录区，@note 如果应用需要支持更多的单据，那么此定义也需要相应的修改，注意不能超过63
     60          #define RITHD						0x80		//调试时，如果遇见新Flash，则建立一个头RIT
     61          #define INDEX_MASK					0x3f		//记录类型的低6位表示记录索引
     62          
     63          typedef struct {
     64          	unsigned char		RIT_OEMName[16];    		// 0  ASCII		用于存放OEM厂商的名字，如："ShenZhenNetcom  "
     65          	unsigned char		RIT_ManName[16];    		// 10 ASCII	   	制造商名，如："ShenZhenNetcom  "
     66          	unsigned char		RIT_ModuleName[16];			// 20 ASCII		模块名，如："POSRESOURCES    "
     67          	unsigned short		RIT_ProdID;					// 30 WORD		产品ID：用户自己定义。如：0x0001或1234
     68          	unsigned short		RIT_Version;    			// 32 BCD码		版本号：用户自己定义。如：0x0001或1234
     69          	unsigned short		RIT_Date;            		// 34 BCD码		更新时间：0x06,0x28 表示6月28日
     70          	unsigned char		RIT_SN[10];            		// 36 ASCII		序列号，用户自己定义。如："1234567890"
     71          	unsigned int		RIT_TotalSect;        		// 40 DWORD		此份资源的总扇区数，包括这份头的512字节
     72          	unsigned int		RIT_DataSec;        		// 44 DWORD	***	此份资源数据部分占的扇区数
     73          	unsigned char		RIT_VerifyType;        		// 48 BYTE		此份资源的校验算法，此域暂不使用
     74          	unsigned char		RIT_Endian;        			// 49 BYTE		此份资源适用的CPU大小端模式。0x0B表示大端 0x0C表示小端
     75          	unsigned char		RIT_DataType;         		// 4A BYTE	***	此份资源的类型码：点阵字库：0x10 图片数据：0x11 字库链接：0x12 升级代码：0x80 升级资源数据：0x81 参数区：0x90 记录区：0x91
     76          	unsigned char		RIT_Reserved0;				// 4B BYTE		保留
     77          	unsigned int		RIT_StartAddr;        		// 4C DWORD		启动代码在ram中存放的起始地址，此项对于代码有效
     78          	unsigned int		RIT_RunAddr;        		// 50 DWORD		运行代码时PC跳转的地址
     79          	unsigned short   	RIT_DataID;					// 54 WORD		此份资源的ID号
     80          	unsigned char		RIT_Align;					// 56 BYTE		此份资源的最小对齐单位，为2^n字节
     81          	unsigned char		RIT_Reserved1;				// 57
     82          	unsigned char		RIT_StrVer[13];				// 58           资源的版本号，格式为20100610_0001
     83          	unsigned char		RIT_Reserved2[0x18B];		// 65 
     84          	unsigned int		RIT_DataCRC32;				// 1F0          数据区的CRC32，即从下一个扇区起，到RIT_CodeSec止的所有数据的CRC32值或CRC，此项根据xml文件中的配置来生成。
     85          	unsigned int		RIT_Next;            		// 1F4 ***      下一份RIT在磁盘中的绝对地址(扇区)
     86          	unsigned int		RIT_CheckSum;        		// 1F8 此份资源表RIT的CRC32校验值。， 
     87          	unsigned int		RIT_TrailSig;       		// 1FC 结束标志(0x00,0x00,0x55,0xAB)
     88          }TResInfoTable;
     89          
     90          #pragma pack(1)
     91          typedef struct {
     92          	unsigned int		RIT_DataSec;        		// 44 DWORD	***	此份资源数据部分占的扇区数
     93          	unsigned int		RIT_Next;            		// 1F4 ***      下一份RIT在磁盘中的绝对地址(扇区) 
     94          	unsigned int		RIT_TrailSig;       		// 1FC 结束标志(0x00,0x00,0x55,0xAB)
     95          	unsigned char		RIT_DataType;         		// 4A BYTE	***	此份资源的类型码
     96          }TSimpRIT;
     97          
     98          typedef struct
     99          {
    100          	unsigned int	rec_start;		// 记录区数据起始地址			存储到Flash
    101          	unsigned int	rec_total;		// 记录区数据存储区总大小		存储到Flash
    102          	unsigned int	rec_hdpt;		// Head指针，指向第0条记录	内存动态值
    103          	unsigned short	rec_size;		// 一条记录的字节数			存储到Flash
    104          	unsigned short	rec_space;		// 每条记录所占空间数			存储到Flash
    105          	unsigned short	rec_maxnum;		// 可存放最大的记录数			存储到Flash
    106          	unsigned short	rec_count;		// 当前有效记录数				内存动态值
    107          	unsigned char	rec_eccflag;	// ECC标识 0x80使能 0x00除能	存储到Flash
    108          	unsigned char	rec_valid;		// 系统初始化标志0x00|0xAA		内存动态值
    109          }TRecFSCB;	// Record File System Control Block
    110          #pragma pack()
    111          
    112          #define BLKSIZE						0x1000		// 4K块
    113          #define BLKMSK						0x00000FFF	// 4K块掩码
    114          
    115          #define	RITSIZE						512			// RIT大小
    116          #define	SECSIZE						512			// 扇区大小
    117          
    118          //记录状态标志定义
    119          #define REC_STATEMSK				0x8F
    120          #define REC_FREE					0xFF		// 空闲
    121          #define REC_INVALID					0xEF		// 无效
    122          #define REC_VALID					0xCF		// 有效
    123          #define REC_OBSOLETE				0x8F		// 过时
    124          
    125          //擦除4K块时的防掉电保护标志定义
    126          #define REC_FMTMSK					0xF8
    127          #define REC_FMTNOOP					0xFF		// 无擦除操作
    128          #define REC_FMTINOP					0xFE		// 正在擦除	
    129          #define REC_FMTEXOP					0xFC		// 被备份到数据交换块
    130          #define REC_FMTOVOP					0xF8		// 擦除完毕
    131          
    132          
    133          static TRecFSCB					recinfo[RECTYPENUM+1];
    134          static TSimpRIT					simprit;
    135          
    136          extern unsigned int				recmod_flasize;
    137          //ECC校验纠错计算缓冲区
    138          unsigned char		ecckey_read[3];
    139          unsigned char		ecckey_cal[3];
    140          unsigned char		eccdata_tmp[256];
    141          
    142          static int			rec_getindex(unsigned char rectype);
    143          static void			rec_readsimprit(unsigned int add);
    144          static int			rec_writesimprit(unsigned int add);
    145          static unsigned int	rec_getrecspc(unsigned int recsize, unsigned char eccflag);
    146          static int			rec_copy4kblk(unsigned int desadd, unsigned int srcadd, unsigned int len);
    147          static	unsigned char			tmpfgwi;		// 临时字节write in
    148          static	unsigned char			tmpfgrb;		// 临时字节read back
    149          static volatile int						test_var1;
    150          static volatile int						test_var2;
    151          
    152          /*-----------------  内部函数  -----------------------*/
    153          /**
    154          * @brief  获取记录文件系统必须的RIT信息
    155          * @param   add: RIT的首地址
    156          * @retval None
    157          */
    158          static void	rec_readsimprit(unsigned int add)
    159          {
    160          	spi_flash_raddr(add+0x44, 4, (unsigned char *)&simprit.RIT_DataSec);	//获取资源数据部分占的扇区数
    161          	spi_flash_raddr(add+0x4A, 1, (unsigned char *)&simprit.RIT_DataType);	//获取资源的类型码
    162          	spi_flash_raddr(add+0x1F4, 4, (unsigned char *)&simprit.RIT_Next);		//获取下一份RIT在磁盘中的扇区地址
    163          	spi_flash_raddr(add+0x1FC, 4, (unsigned char *)&simprit.RIT_TrailSig);	//获取结束标志
    164          }
    165          
    166          /**
    167          * @brief  计算一条记录所需的空间
    168          * @param  recsize: 一条记录的长度
    169          * @param  eccflag: ECC功能是否开启
    170          * @retval     2^n: 记录所需空间, 2^n 
    171          */
    172          static unsigned int	rec_getrecspc(unsigned int recsize, unsigned char eccflag)
    173          {
    174          	unsigned int	recspace;
    175          	int				i;
    176          	// 计算一条记录所需的空间, 空间分配以2^n为单位,
    177          	// 每条记录需要添加1byte断电保护标志
    178          	// 如果ECC功能开启则还需要加上N字节的ECC纠错校验码位，
    179          	// 否则加上1字节的异或校验位
    180          	if(eccflag)
    181          	{
    182          		recspace	= recsize + 1 + (recsize + 255) / 256 * 3;
    183          	}
    184          	else
    185          	{
    186          		recspace	= recsize + 2;
    187          	}
    188          	// 循环搜索最左端的1
    189          	for (i = 31; i > 0; i--)
    190          	{
    191          		if ((recspace & 0x80000000) == 0x80000000)
    192          		{
    193          			if (recspace == 0x80000000)
    194          			{
    195          				break;
    196          			}
    197          			else
    198          			{
    199          				i++;
    200          				break;
    201          			}
    202          		}
    203          		recspace <<= 1;
    204          	}
    205          	recspace = 0x1 << i;	//得到2^n大小
    206          	return recspace;
    207          }
    208          
    209          /**
    210          * @brief  写入记录文件系统必须的RIT信息
    211          * @param   add: RIT的首地址
    212          * @retval    0: 成功
    213          *           -1: 失败
    214          */
    215          static int	rec_writesimprit(unsigned int add)
    216          {
    217          	if (0 != spi_flash_waddr(add+0x44, 4, (unsigned char *)&simprit.RIT_DataSec))	//写入资源数据部分占的扇区数
    218          	{
    219          		return -1;
    220          	}
    221          	if (0 != spi_flash_waddr(add+0x4A, 1, (unsigned char *)&simprit.RIT_DataType))	//写入资源的类型码
    222          	{
    223          		return -1;
    224          	}
    225          	if (0 != spi_flash_waddr(add+0x1F4, 4, (unsigned char *)&simprit.RIT_Next))		//写入下一份RIT在磁盘中的扇区地址
    226          	{
    227          		return -1;
    228          	}
    229          	if (0 != spi_flash_waddr(add+0x1FC, 4, (unsigned char *)&simprit.RIT_TrailSig))	//写入结束标志
    230          	{
    231          		return -1;
    232          	}
    233          	return 0;
    234          }
    235          
    236          /**
    237          * @brief  将一个BLK的部分内容复制到另一个BLK
    238          * @param  desadd: 目标地址
    239          *         srcadd: 源地址
    240          *            len: 复制长度
    241          * @retval    0: 复制成功
    242          *           -1: 写flash出错
    243          */
    244          static int rec_copy4kblk(unsigned int desadd, unsigned int srcadd, unsigned int len)
    245          {
    246          	unsigned char	tmpbuf[16];
    247          	while(len / 16)	// 以16字节为单位分段复制
    248          	{
    249          		spi_flash_raddr(srcadd, 16, tmpbuf);
    250          		if (0 != spi_flash_waddr(desadd, 16, tmpbuf))
    251          		{
    252          			return -1;
    253          		}
    254          		len -= 16;
    255          		srcadd += 16;
    256          		desadd += 16;
    257          	}
    258          	// 将剩余的字节复制
    259          	MEMSET(tmpbuf,0xFF,16);
    260          	spi_flash_raddr(srcadd, len, tmpbuf);
    261          	if (0 != spi_flash_waddr(desadd, 16, tmpbuf))
    262          	{
    263          		return -1;
    264          	}
    265          	return 0;
    266          }
    267          
    268          /**
    269          * @brief  获取记录类型索引
    270          * @param  rectype: 参数区类型
    271          * @retval     记录索引0-2
    272          *         -1: 失败 
    273          */
    274          static int	rec_getindex(unsigned char rectype)
    275          {
    276          	if ((rectype & INDEX_MASK) < (RECTYPENUM+1))
    277          	{
    278          		return (rectype & INDEX_MASK);
    279          	} 
    280          	else
    281          	{
    282          		return -1;
    283          	}
    284          }
    285          
    286          
    287          /*----------------------- 导出函数 -----------------------*/
    288          /**
    289           * @brief  格式化SPI Flash，使之可以存放number条大小为recordsize的记录。
    290           * @param      recopt: 记录类型编号与ECC开启标志 或0x80开启ECC
    291           *         recordsize: 每条记录的大小，关闭ECC时最大支持2046，开启ECC时支持最大2023字节
    292           *             number: 记录块可存放记录的个数
    293           * @retval    0: 格式化成功
    294           *           -1: 不支持此类型记录
    295           *           -2: Flash尚未初始化
    296           *           -3: 记录长度大于支持长度
    297           *           -4: 读RIT出错，文件系统错误
    298           *           -5: Flash空间不够
    299           *           -6: 写Flash出错
    300           */
    301          int record_format(unsigned char recopt, unsigned int recordsize, unsigned int number)
    302          {
    303          	int						recindex;		// 记录区号索引
    304          	unsigned int			ritadd;			// RIT地址
    305          	unsigned int			ritold;			// 保存上一个RIT地址。
    306          	unsigned int			recordspace;	// 一条记录的空间
    307          	unsigned int			recordtotal;	// 整个记录区所需空间
    308          	unsigned int			tmpadd;			// 临时用地址
    309          
    310          	/********* 格式化步骤 **********/
    311          	/* 1.检查输入类型 **************/
    312          	recindex	= rec_getindex(recopt & 0x7F);
    313          	if (-1 == recindex)
    314          	{
    315          		return -1;		// 不支持此类型记录
    316          	}
    317          
    318          	/* 2.检查Flash状态 **************/
    319          	if (0 != spi_flash_valid())
    320          	{
    321          		return -2;		// Flash尚未初始化
    322          	}
    323          
    324          	/* 3.检查输入记录大小 **************/
    325          	if ((recopt & 0x80) == 0x80 && recordsize > 2023)
    326          	{
    327          		return -3;		// 记录长度大于支持长度
    328          	}
    329          	else if (recordsize > 2046)
    330          	{
    331          		return -3;		// 记录长度大于支持长度
    332          	}
    333          
    334          	/* 4.查询RIT，准备格式化 *******/
    335          	//如果flash是新的，这段代码可以在
    336          	//flash的0地址地方建立一个空的RIT，
    337          	//形成一个RIT链表头。
    338          loop:
    339          	ritadd	= 0;
    340          	rec_readsimprit(ritadd);
    341          	if( simprit.RIT_TrailSig != 0xAB550000)
    342          	{
    343          		if (0 != spi_flash_erasesector(0))
    344          		{
    345          			return -6;		// 写Flash出错
    346          		}
    347          		simprit.RIT_TrailSig	= 0xAB550000;
    348          		simprit.RIT_DataType	= RITHD;
    349          		simprit.RIT_DataSec		= 0;
    350          		simprit.RIT_Next		= 0xFFFFFFFF;
    351          		if (0 != rec_writesimprit(ritadd))
    352          		{
    353          			return -6;		// 写Flash出错
    354          		}
    355          	}
    356          	while(1)
    357          	{
    358          #ifdef	RECORD_DEBUG
    359          		printf("simprit.RIT_DataType is 0x%X\r\n", simprit.RIT_DataType);
    360          		printf("simprit.RIT_DataSec  is 0x%X\r\n", simprit.RIT_DataSec);
    361          		printf("simprit.RIT_Next     is 0x%X\r\n", simprit.RIT_Next);
    362          		printf("simprit.RIT_TrailSig is 0x%X\r\n\r\n", simprit.RIT_TrailSig);
    363          #endif
    364          		if( simprit.RIT_TrailSig != 0xAB550000 || simprit.RIT_Next == 0)
    365          			// simprit.RIT_Next == 0是因为以前的RIT文件结构以0结尾，这里做RIT出错处理
    366          		{
    367          			//如果发现此记录区的RIT表格式错误，那么将上一份RIT表的Next指针修改为结束符，表示资源链表已经结束
    368          			rec_readsimprit(ritold);
    369          			simprit.RIT_Next = 0xFFFFFFFF;
    370          			ritadd = ritold;
    371          		}
    372          
    373          		if ( simprit.RIT_DataType == ((recopt & INDEX_MASK) | 0xC0) )		// 情况1,发现需要格式化记录区已经存在
    374          		{
    375          			break;									// 直接跳出循环，重新格式化
    376          		}
    377          
    378          		ritold	= ritadd;							// 更新上次RIT的值
    379          
    380          		if (simprit.RIT_Next == 0xFFFFFFFF)			// 情况2,搜索至RIT链表结尾也没有找到需要格式化的记录区
    381          		{
    382          			ritadd	= ritadd + (simprit.RIT_DataSec + 1) * 512;
    383          			if (0 != (ritadd & BLKMSK))				// 如果地址不是4K对齐，则变成4K对齐
    384          			{
    385          				ritadd	= (ritadd | BLKMSK) + 1;
    386          			}
    387          			break;									// 计算新格式化记录区的起始位置后跳出。
    388          		}
    389          		ritadd	= simprit.RIT_Next * 512;			// 更新当前RIT的值
    390          		rec_readsimprit(ritadd);
    391          	}
    392          
    393          #ifdef	RECORD_DEBUG
    394          	printf("ritold is 0x%X\r\n", ritold);
    395          	printf("ritadd is 0x%X\r\n\r\n", ritadd);
    396          #endif
    397          
    398          	/* 5.以ritadd为基础进行格式化 *******/
    399          	// 根据是否开启ECC分别获取一条记录所需空间
    400          	if ((recopt & 0x80) == 0x80)
    401          	{
    402          		recordspace	= rec_getrecspc(recordsize, 1);		
    403          	} 
    404          	else
    405          	{
    406          		recordspace	= rec_getrecspc(recordsize, 0);
    407          	}
    408          	recordtotal	= recordspace * number;
    409          	if (0 != (recordtotal & BLKMSK))				// 如果不是4K对齐，则变成4K对齐
    410          	{
    411          		recordtotal	= (recordtotal | BLKMSK) + 1;
    412          	}
    413          	recordtotal	= recordtotal + 3 * BLKSIZE;		// 总大小等于记录所需的空间加上1个交换块1个断电保护块1个RIT所在块
    414          	if (ritadd + recordtotal > recmod_flasize)
    415          	{
    416          		return -5;	// Flash空间不够
    417          	}
    418          	// 写入上一个RIT链接到当前RIT到Flash中
    419          	//simprit.RIT_Next		= ritadd / 512;		//将上一个RIT链接到当前RIT
    420          	//if (0 != spi_flash_waddr(ritold+0x1F4, 4, (unsigned char *)&simprit.RIT_Next))
    421          	//{
    422          	//	return -6;		// 写Flash出错
    423          	//}
    424          #ifdef	RECORD_DEBUG
    425          	printf("start erase...\r\n");
    426          	printf("Start address is 0x%X\r\n", ritadd);
    427          	printf("End   address is 0x%X\r\n\r\n", ritadd + recordtotal);
    428          #endif
    429          	// 擦除需要格式化的数据区
    430          	//实际上格式化的时候可以不需要擦除数据区，因为在增加记录时，发现是往4K块首地址写数据时都会将4K块擦除一遍
    431          	//此部分是Joe.zhou于20120509屏蔽掉的。
    432          #if 1
    433          	for(tmpadd = ritadd; tmpadd < ritadd + recordtotal; tmpadd += BLKSIZE)
    434          	{
    435          		if (0 != spi_flash_erasesector(tmpadd))
    436          		{
    437          			return -6;		// 写Flash出错
    438          		}
    439          	}
    440          #endif
    441          
    442          	// 该记录区的写入RIT
    443          	simprit.RIT_DataSec		= (recordtotal - BLKSIZE) / 512;
    444          	simprit.RIT_DataType	= ((recopt & INDEX_MASK) | 0xC0);
    445          	simprit.RIT_TrailSig	= 0xAB550000;
    446          	simprit.RIT_Next		= 0xFFFFFFFF;
    447          #ifdef	RECORD_DEBUG
    448          	printf("simprit.RIT_DataType is 0x%X\r\n", simprit.RIT_DataType);
    449          	printf("simprit.RIT_DataSec  is 0x%X\r\n", simprit.RIT_DataSec);
    450          	printf("simprit.RIT_Next     is 0x%X\r\n", simprit.RIT_Next);
    451          	printf("simprit.RIT_TrailSig is 0x%X\r\n\r\n", simprit.RIT_TrailSig);
    452          #endif
    453          	if (0 != rec_writesimprit(ritadd))
    454          	{
    455          		return -6;		// 写Flash出错
    456          	}
    457          	//simprit.RIT_Next		= ritadd / 512;		//将上一个RIT链接到当前RIT
    458          	
    459          	// 将该记录区的信息头写入Flash中
    460          #ifdef	RECORD_DEBUG
    461          	printf("TRecFSCB'size is %d\r\n\r\n",sizeof(TRecFSCB));
    462          #endif
    463          	recinfo[recindex].rec_start		= ritadd + BLKSIZE;
    464          	recinfo[recindex].rec_total		= recordtotal - 2 * BLKSIZE;
    465          	//小技巧，格式化后将Head指针指向记录区的最后一条记录，由于写操作每次
    466          	//将Head加上一个记录空间再写，这样，写第一条记录时，Head指针就指向记录区
    467          	//首位置了。
    468          	recinfo[recindex].rec_hdpt		= ritadd + recordtotal - BLKSIZE - recordspace;
    469          	recinfo[recindex].rec_space		= (unsigned short)recordspace;
    470          	recinfo[recindex].rec_size		= (unsigned short)recordsize;
    471          	recinfo[recindex].rec_maxnum	= (unsigned short)number;
    472          	recinfo[recindex].rec_count		= 0;
    473          	recinfo[recindex].rec_eccflag	= recopt & 0x80;
    474          	recinfo[recindex].rec_valid		= 0x00;
    475          #ifdef	RECORD_DEBUG
    476          	printf("recinfo[%d].rec_start  is 0x%X\r\n", recindex, recinfo[recindex].rec_start);
    477          	printf("recinfo[%d].rec_total  is 0x%X\r\n", recindex, recinfo[recindex].rec_total);
    478          	printf("recinfo[%d].rec_hdpt   is 0x%X\r\n", recindex, recinfo[recindex].rec_hdpt);
    479          	printf("recinfo[%d].rec_size   is %d\r\n", recindex, recinfo[recindex].rec_size);
    480          	printf("recinfo[%d].rec_space  is %d\r\n", recindex, recinfo[recindex].rec_space);
    481          	printf("recinfo[%d].rec_maxnum is %d\r\n", recindex, recinfo[recindex].rec_maxnum);
    482          	printf("recinfo[%d].rec_count  is %d\r\n", recindex, recinfo[recindex].rec_count);
    483          	printf("recinfo[%d].rec_valid  is 0x%X\r\n\r\n", recindex, recinfo[recindex].rec_valid);
    484          #endif
    485          	if(0 != spi_flash_waddr(ritadd + RITSIZE, sizeof(TRecFSCB), (unsigned char *)&recinfo[recindex]))
    486          	{
    487          		return -6;		// 写Flash出错
    488          	}
    489          	// 写入上一个RIT链接到当前RIT到Flash中
    490          	tmpadd = ritadd/512;
    491          	if (0 != spi_flash_waddr(ritold+0x1F4, 4, (unsigned char *)&tmpadd))
    492          	{
    493          		return -6;		// 写Flash出错
    494          	}
    495          	recinfo[recindex].rec_valid		= 0xAA;
    496          	return 0;
    497          }
    498          
    499          
    500          
    501          /**
    502           * @brief  获取记录区数据信息recinfo[]内容,并执行断电恢复操作
    503           * @param  rectype: 参数区类型
    504           *                 	recinfo[recindex].rec_size		= (unsigned short)recordsize;
    505           *                  recinfo[recindex].rec_maxnum	= (unsigned short)number;
    506           * @retval    0: 初始化成功
    507           *           -1: 不支持此类型记录
    508           *           -2: Flash尚未初始化
    509           *           -3: 没有找到记录区
    510           *           -4: 读RIT出错，文件系统错误
    511           *           -5: 写Flash出错
    512           *           -6: 记录的长度与条数与原来格式化的不匹配
    513           */
    514          int record_init(unsigned char rectype, unsigned int recordsize, unsigned int number)
    515          {
    516          	int						recindex;		// 记录区号索引
    517          	unsigned int			ritadd;			// RIT地址
    518          	unsigned int			recordspace;	// 一条记录的空间
    519          	unsigned int			recordtotal;	// 整个记录区所需空间
    520          	unsigned int			recordstart;	// 记录区起始地址
    521          	unsigned int			scanpt;			// 断电恢复扫描指针
    522          	unsigned int			tmpadd;			// 临时用地址
    523          	unsigned int			headpt;			// 第0条记录指针
    524          	unsigned char			rcvflag;		// 记录状态标志
    525          	unsigned char			tmpflag;		// 临时用标志
    526          
    527          	/********* 初始化步骤 **********/
    528          	/* 1.检查输入类型 **************/
    529          	recindex	= rec_getindex(rectype);
    530          	if (-1 == recindex )
    531          	{
    532          		return -1;		// 不支持此类型记录
    533          	}
    534          
    535          	/* 2.检查Flash状态 **************/
    536          	if (0 != spi_flash_valid())
    537          	{
    538          		return -2;		// Flash尚未初始化
    539          	}
    540          
    541          
    542          	/* 3.查询RIT，准备初始化 *******/
    543          	ritadd	= 0;
    544          	while(1)
    545          	{
    546          		rec_readsimprit(ritadd);
    547          		if( simprit.RIT_TrailSig != 0xAB550000  || simprit.RIT_Next == 0)
    548          			// simprit.RIT_Next == 0是因为以前的RIT文件结构以0结尾，这里做RIT出错处理
    549          		{
    550          			return -4;								// 读RIT出错，文件系统错误
    551          		}
    552          		if (simprit.RIT_DataType == ((rectype & INDEX_MASK) | 0xC0))		// 找到记录区
    553          		{
    554          			break;
    555          		}
    556          		if (simprit.RIT_Next == 0xFFFFFFFF)			// 没有找到记录区
    557          		{
    558          			return -3;
    559          		}
    560          		ritadd	= simprit.RIT_Next * 512;			// 更新当前RIT的值
    561          	}
    562          
    563          
    564          
    565          #ifdef	RECORD_DEBUG
    566          	printf("ritadd is 0x%X\r\n", ritadd);
    567          #endif
    568          	/* 5.开始初始化 ****************/
    569          	// 获取记录区的控制块信息
    570          	spi_flash_raddr(ritadd + RITSIZE, sizeof(TRecFSCB), (unsigned char *)&recinfo[recindex]);
    571          	recordspace	= recinfo[recindex].rec_space;
    572          	recordstart	= recinfo[recindex].rec_start;
    573          	recordtotal	= recinfo[recindex].rec_total;
    574          
    575          	/* 4.检查记录长度和大小是否正确 **************/
    576          	if (recinfo[recindex].rec_size != (unsigned short)recordsize || recinfo[recindex].rec_maxnum != (unsigned short)number)
    577          	{
    578          		return -6;		// 记录的长度与条数与原来格式化的不匹配
    579          	}
    580          
    581          	// 执行断电恢复操作
    582          	//  <1> 扫描整个记录区查找是否有执行删除4K块时出现断电的情况，
    583          	//      如果有，重新删除一次，并将删除标志写成已经删除。
    584          	//      注：删除4K块断电保护机制，每次删除4K块时，在下一块的
    585          	//          第一个字节做上正在删除的标记。删除成功后再标记为
    586          	//          成功删除。
    587          	scanpt	= recordstart;
    588          	while(scanpt < recordstart + recordtotal)
    589          	{
    590          		spi_flash_raddr(scanpt, 1, &rcvflag);
    591          		if ((rcvflag | REC_FMTMSK) == REC_FMTINOP)	// 发现未删除完成的块（目标处理块）
    592          		{
    593          #ifdef	RECORD_DEBUG
    594          			printf("Find 1 block unfinished format!\r\n");
    595          #endif
    596          			if (scanpt == recordstart)
    597          			{
    598          				tmpadd	= recordstart + recordtotal - BLKSIZE;
    599          			}
    600          			else
    601          			{
    602          				tmpadd	= scanpt - BLKSIZE;
    603          			}
    604          			// 重新删除未删除完成的块
    605          			if (0 != spi_flash_erasesector(tmpadd))
    606          			{
    607          				return -5;		// 写Flash出错
    608          			}
    609          			// 将标志写为已经删除完成
    610          			rcvflag	= REC_FMTOVOP;
    611          			if (0 != spi_flash_waddr(scanpt, 1, &rcvflag))
    612          			{
    613          				return -5;		// 写Flash出错
    614          			}
    615          
    616          			// 断电时只可能出现一种情况，如果出现在删除4K块时，
    617          			// 则恢复4K块后无需进行后续扫描步骤，设置记录区控制块的
    618          			// Head指针，当前记录条数，初始化完成标志后返回
    619          
    620          			// 由于发生了删除4K块断电的情况，则可根据删除的这个4K块
    621          			// 判断Head指针应该指向这个4K块的前一条记录位置
    622          			if (tmpadd == recordstart)
    623          			{
    624          				tmpadd	= recordstart + recordtotal - recordspace;
    625          			}
    626          			else
    627          			{
    628          				tmpadd	= tmpadd - recordspace;
    629          			}
    630          			recinfo[recindex].rec_hdpt	= tmpadd;
    631          			recinfo[recindex].rec_valid	= 0xAA;
    632          			recinfo[recindex].rec_count	= (unsigned short)record_count(rectype);
    633          			return 0;
    634          		}
    635          		scanpt += BLKSIZE;
    636          	}
    637          
    638          	// 执行断电恢复操作
    639          	//  <2> 扫描整个记录区查找是否有执行记录替换操作时删除记录所在的4K块时出现断电的情况，
    640          	//      如果有，重新删除一次，并将交换块的记录copy回来。
    641          	//      注：删除4K块断电保护机制，每次删除4K块时，在下一块的
    642          	//          第一个字节做上正在删除的标记。删除成功后再标记为
    643          	//          成功删除。
    644          	scanpt	= recordstart;
    645          	while(scanpt < recordstart + recordtotal)
    646          	{
    647          		spi_flash_raddr(scanpt, 1, &rcvflag);
    648          		if ((rcvflag | REC_FMTMSK) == REC_FMTEXOP)	// 发现被修改后备份到交换块
    649          		{
    650          #ifdef	RECORD_DEBUG
    651          			printf("Find 1 block unfinished format!\r\n");
    652          #endif
    653          			if (scanpt == recordstart)
    654          			{
    655          				tmpadd	= recordstart + recordtotal - BLKSIZE;
    656          			}
    657          			else
    658          			{
    659          				tmpadd	= scanpt - BLKSIZE;
    660          			}
    661          			// 重新删除未删除完成的块
    662          			if (0 != spi_flash_erasesector(tmpadd))
    663          			{
    664          				return -5;		// 写Flash出错
    665          			}
    666          			
    667          			//将交换块的记录copy回来
    668          			if (0 != rec_copy4kblk(tmpadd,recordstart + recordtotal,BLKSIZE))
    669          			{
    670          				return -5;		// 写Flash出错
    671          			}
    672          			
    673          			// 将标志写为已经删除完成
    674          			rcvflag	= REC_FMTOVOP;
    675          			if (0 != spi_flash_waddr(scanpt, 1, &rcvflag))
    676          			{
    677          				return -5;		// 写Flash出错
    678          			}
    679          
    680          			// 断电时只可能出现一种情况，如果出现在删除4K块时，
    681          			// 则恢复4K块后无需进行后续扫描步骤，设置记录区控制块的
    682          			// Head指针，当前记录条数，初始化完成标志后返回
    683          
    684          			// 由于发生了删除4K块断电的情况，则可根据删除的这个4K块
    685          			// 判断Head指针应该指向这个4K块的前一条记录位置
    686          			if (tmpadd == recordstart)
    687          			{
    688          				tmpadd	= recordstart + recordtotal - recordspace;
    689          			}
    690          			else
    691          			{
    692          				tmpadd	= tmpadd - recordspace;
    693          			}
    694          			recinfo[recindex].rec_hdpt	= tmpadd;
    695          			recinfo[recindex].rec_valid	= 0xAA;
    696          			recinfo[recindex].rec_count	= (unsigned short)record_count(rectype);
    697          			return 0;
    698          		}
    699          		scanpt += BLKSIZE;
    700          	}
    701          
    702          	// <3> 扫描整个记录区，恢复写记录时的断电的信息，实际操作是：
    703          	//     如果发现写记录时断电的记录，则利用记录区最后的断电恢复
    704          	//     区，将这条没有写完的记录彻底删除掉。恢复写记录完成后
    705          	//     没有删除最老记录的情况。
    706          	scanpt	= recordstart;
    707          	while(scanpt < recordstart + recordtotal)
    708          	{
    709          		spi_flash_raddr(scanpt, 1, &rcvflag);
    710          		if ((rcvflag | REC_STATEMSK) == REC_INVALID)
    711          		{
    712          #ifdef	RECORD_DEBUG
    713          			printf("Find 1 record unfinished write!\r\n");
    714          #endif
    715          			// 如果没写完的记录所在地址不是4K对齐则利用记录区最后的断电恢复
    716          			// 区，将这条没有写完的记录彻底删除掉。
    717          			if (0 != (scanpt & BLKMSK))	
    718          			{
    719          				tmpadd	= scanpt & (~BLKMSK);
    720          				if (0 != spi_flash_erasesector(recordstart + recordtotal))	// 清空断电恢复区
    721          				{
    722          					return -5;		// 写Flash出错
    723          				}
    724          				// 将需要保留的数据临时存放到断电恢复区
    725          				if (0 != rec_copy4kblk(recordstart + recordtotal, tmpadd, scanpt-tmpadd))
    726          				{
    727          					return -5;		// 写Flash出错
    728          				}
    729          				// 清空该4K块
    730          				if (0 != spi_flash_erasesector(tmpadd))
    731          				{
    732          					return -5;		// 写Flash出错
    733          				}
    734          				//将临时存放在断电恢复区的数据存回来
    735          				if (0 != rec_copy4kblk(tmpadd, recordstart + recordtotal, scanpt-tmpadd))
    736          				{
    737          					return -5;		// 写Flash出错
    738          				}
    739          			}
    740          			// 如果没写完的记录所在地址是4K对齐则
    741          			// 直接删除该4K块。
    742          			else
    743          			{
    744          				if (0 != spi_flash_erasesector(scanpt))
    745          				{
    746          					return -5;		// 写Flash出错
    747          				}
    748          			}
    749          			// 恢复成功后，利用断电的记录位置算出记录区控制块的
    750          			// Head指针，当前记录条数，初始化完成标志后返回
    751          			if (scanpt == recordstart)
    752          			{
    753          				tmpadd	= recordstart + recordtotal - recordspace;
    754          			}
    755          			else
    756          			{
    757          				tmpadd	= scanpt - recordspace;
    758          			}
    759          			// 更新FSCB
    760          			recinfo[recindex].rec_valid	= 0xAA;
    761          			recinfo[recindex].rec_count	= (unsigned short)record_count(rectype);
    762          			recinfo[recindex].rec_hdpt	= tmpadd;
    763          			return 0;
    764          		}
    765          		// 下面的代码记录最后一条记录的位置，并计算总记
    766          		// 录数，如果总记录数大于最大记录数则说
    767          		// 明，上次出现断电事件并发生在写入最新的记录后
    768          		// 删除最老记录之时，这种概率极低。
    769          		if ((rcvflag | REC_STATEMSK) == REC_OBSOLETE)
    770          		{
    771          			if (scanpt == recordstart + recordtotal - recordspace)
    772          			{
    773          				tmpadd	= recordstart;
    774          			}
    775          			else
    776          			{
    777          				tmpadd	= scanpt + recordspace;
    778          			}
    779          #ifdef	RECORD_DEBUG
    780          			//printf("tmpadd is 0x%X\r\n",tmpadd);
    781          #endif
    782          			spi_flash_raddr(tmpadd, 1, &tmpflag);
    783          
    784          			if ((tmpflag | REC_STATEMSK) == REC_VALID)
    785          			{
    786          #ifdef	RECORD_DEBUG
    787          				printf("Find last record!\r\n");
    788          #endif
    789          				recinfo[recindex].rec_valid	= 0xAA;
    790          				if (recinfo[recindex].rec_maxnum < record_count(rectype))
    791          				{
    792          					tmpflag	= REC_OBSOLETE;
    793          					if (0 != spi_flash_waddr(tmpadd, 1, &tmpflag))
    794          					{
    795          						recinfo[recindex].rec_valid	= 0x00;
    796          						return -5;		// 写Flash出错
    797          					}
    798          				}
    799          				recinfo[recindex].rec_valid	= 0x00;
    800          			}
    801          		}
    802          
    803          		// 扫描记录第0条记录指针
    804          		if ((rcvflag | REC_STATEMSK) == REC_VALID)
    805          		{
    806          			if (scanpt == recordstart + recordtotal - recordspace)
    807          			{
    808          				tmpadd	= recordstart;
    809          			}
    810          			else
    811          			{
    812          				tmpadd	= scanpt + recordspace;
    813          			}
    814          			spi_flash_raddr(tmpadd, 1, &tmpflag);
    815          			if ((tmpflag | REC_STATEMSK) == REC_FREE || (tmpflag | REC_STATEMSK) == REC_OBSOLETE)
    816          			{
    817          #ifdef	RECORD_DEBUG
    818          				printf("Find head record!\r\n");
    819          #endif
    820          				headpt	= scanpt;
    821          			}
    822          		}
    823          		scanpt += recordspace;
    824          	}
    825          	// 扫描恢复完成后，设这记录区控制块的Head指针，
    826          	// 当前记录条数，初始化完成标志后返回
    827          	recinfo[recindex].rec_valid	= 0xAA;
    828          	recinfo[recindex].rec_count = record_count(rectype);
    829          	if (0 == recinfo[recindex].rec_count)
    830          	{
    831          		recinfo[recindex].rec_hdpt	= recordstart + recordtotal - recordspace;
    832          	}
    833          	else
    834          	{
    835          		recinfo[recindex].rec_hdpt	= headpt;
    836          	}
    837          #ifdef	RECORD_DEBUG
    838          	printf("Finished init OP!\r\n");
    839          	printf("recinfo[%d].rec_start  is 0x%X\r\n", recindex, recinfo[recindex].rec_start);
    840          	printf("recinfo[%d].rec_total  is 0x%X\r\n", recindex, recinfo[recindex].rec_total);
    841          	printf("recinfo[%d].rec_hdpt   is 0x%X\r\n", recindex, recinfo[recindex].rec_hdpt);
    842          	printf("recinfo[%d].rec_size   is %d\r\n", recindex, recinfo[recindex].rec_size);
    843          	printf("recinfo[%d].rec_space  is %d\r\n", recindex, recinfo[recindex].rec_space);
    844          	printf("recinfo[%d].rec_maxnum is %d\r\n", recindex, recinfo[recindex].rec_maxnum);
    845          	printf("recinfo[%d].rec_count  is %d\r\n", recindex, recinfo[recindex].rec_count);
    846          	printf("recinfo[%d].rec_valid  is 0x%X\r\n\r\n", recindex, recinfo[recindex].rec_valid);
    847          #endif
    848          	return 0;
    849          }
    850          
    851          /**
    852           * @brief  获取数据区有效记录条数
    853           * @param    rectype: 记录区类型
    854           * @retval  0..count: 记录条数
    855           *                -1: 不支持此类型记录
    856           *                -2: Flash尚未初始化
    857           *				  -3: 文件系统尚未初始化
    858           */
    859          int record_count(unsigned char rectype)
    860          {
    861          	int						recindex;		// 记录区号索引
    862          	int						count;			// 有效记录条数
    863          	unsigned short			recordspace;	// 一条记录的空间
    864          	unsigned int			recordtotal;	// 整个记录区所需空间
    865          	unsigned int			recordstart;	// 记录区起始地址
    866          	unsigned int			scanpt;			// 断电恢复扫描指针
    867          	unsigned char			rcvflag;		// 记录状态标志
    868          
    869          	/********* 获取记录条数步骤 **********/
    870          	/* 1.检查输入类型 ********************/
    871          	recindex	= rec_getindex(rectype);
    872          	if (-1 == recindex )
    873          	{
    874          		return -1;		// 不支持此类型记录
    875          	}
    876          
    877          	/* 2.检查Flash状态 ********************/
    878          	if (0 != spi_flash_valid())
    879          	{
    880          		return -2;		// Flash尚未初始化
    881          	}
    882          
    883          	/* 3.检查文件系统是否初始化 *********/
    884          	if (0xAA != recinfo[recindex].rec_valid)
    885          	{
    886          		return -3;		// 文件系统尚未初始化
    887          	}
    888          
    889          	/* 4.扫描整个记录区计算有效记录数 **/
    890          	recordspace	= recinfo[recindex].rec_space;
    891          	recordstart	= recinfo[recindex].rec_start;
    892          	recordtotal	= recinfo[recindex].rec_total;
    893          	count		= 0;
    894          	for(scanpt = recordstart; scanpt < recordstart + recordtotal; scanpt += recordspace)
    895          	{
    896          		spi_flash_raddr(scanpt, 1, &rcvflag);
    897          		if ((rcvflag | REC_STATEMSK) == REC_VALID)
    898          		{
    899          			count++;
    900          		}
    901          	}
    902          	return count;
    903          }
    904          
    905          //直接从内存返回当前记录区的记录数
    906          int record_count_ext(unsigned char rectype)
    907          {
    908          	int						recindex;		// 记录区号索引
    909          
    910          	/********* 获取记录条数步骤 **********/
    911          	/* 1.检查输入类型 ********************/
    912          	recindex	= rec_getindex(rectype);
    913          	if (-1 == recindex )
    914          	{
    915          		return -1;		// 不支持此类型记录
    916          	}
    917          
    918          	/* 2.检查Flash状态 ********************/
    919          	if (0 != spi_flash_valid())
    920          	{
    921          		return -2;		// Flash尚未初始化
    922          	}
    923          
    924          	/* 3.检查文件系统是否初始化 *********/
    925          	if (0xAA != recinfo[recindex].rec_valid)
    926          	{
    927          		return -3;		// 文件系统尚未初始化
    928          	}
    929          
    930          	return recinfo[recindex].rec_count;
    931          }
    932          
    933          /**
    934           * @brief  读取指定索引的记录
    935           * @param    index: 要读取的记录索引
    936           * @param  *record: 存放的地址
    937           * @param  rectype: 记录类型 当只需要读取标志字节时，将rectype参数与0x80进行或运算
    938           * @param      len: 要读取的记录长度
    939           * @retval    0: 读取成功
    940           *           -1: 不支持此类型记录
    941           *           -2: Flash尚未初始化
    942           *           -3: 文件系统尚未初始化
    943           *           -4: 输入参数长度大于参数所能容纳的长度
    944           *           -5: 无此记录
    945           *           -6: 读出错误
    946           * @note  约定记录的第一个字节做为标志字节，该
    947           *        字节不记入校验值中
    948           */
    949          int record_read(unsigned char rectype, int index, unsigned char *record, unsigned int len)
    950          {
    951          	int						i;			
    952          	int						recindex;		// 记录区号索引
    953          	unsigned char			chkcode;		// 记录存放的校验码
    954          	unsigned char			tmpchk;			// 计算出的校验码
    955          	unsigned int			recordtotal;	// 整个记录区所需空间
    956          	unsigned int			recordstart;	// 记录区起始地址
    957          	unsigned int			recordheadpt;	// 第0条记录指针
    958          	unsigned short			recordspace;	// 一条记录的空间
    959          	unsigned short			recordsize;		// 一条记录的大小
    960          	unsigned short			recordsizetmp;	// 临时用recordsize
    961          	unsigned short			recordcount;	// 当前记录条数
    962          	unsigned int			tmpadd;			// 临时用地址
    963          
    964          
    965          	/********* 读记录步骤 ****************/
    966          	/* 1.检查输入类型 ********************/
    967          	recindex	= rec_getindex(rectype);
    968          	if (-1 == recindex )
    969          	{
    970          		return -1;		// 不支持此类型记录
    971          	}
    972          
    973          	/* 2.检查Flash状态 ********************/
    974          	if (0 != spi_flash_valid())
    975          	{
    976          		return -2;		// Flash尚未初始化
    977          	}
    978          
    979          	/* 3.检查文件系统是否初始化 *********/
    980          	if (0xAA != recinfo[recindex].rec_valid)
    981          	{
    982          		return -3;		// 文件系统尚未初始化
    983          	}
    984          
    985          	/* 4.定位索引为index的记录位置 ******/
    986          	recordcount		= recinfo[recindex].rec_count;
    987          	recordheadpt	= recinfo[recindex].rec_hdpt;
    988          	recordstart		= recinfo[recindex].rec_start;
    989          	recordspace		= recinfo[recindex].rec_space;
    990          	recordtotal		= recinfo[recindex].rec_total;
    991          	recordsize		= recinfo[recindex].rec_size;
    992          
    993          	if (len > recordsize)
    994          	{
    995          		return -4;
    996          	}
    997          	else if (len != 0)
    998          	{
    999          		recordsize	= len;
   1000          	}
   1001          
   1002          	if (index >= recordcount)	// 索引号大于或等于当前总记录数
   1003          	{
   1004          		return -5;		// 无此记录
   1005          	}
   1006          	if (recordheadpt >= recordstart + index * recordspace)
   1007          	{
   1008          		tmpadd	= recordheadpt - index * recordspace;
   1009          	}
   1010          	else
   1011          	{
   1012          		tmpadd = recordtotal + recordheadpt - index * recordspace;
   1013          	}
   1014          	if ((rectype & 0xC0) == 0x80)	//只读修改标志
   1015          	{
   1016          		spi_flash_raddr(tmpadd+1, 1, record);
   1017          		return 0;
   1018          	}
   1019          	/***** 读出校验与纠错 *****/
   1020          	if (recinfo[recindex].rec_eccflag == 0x0)
   1021          	{
   1022          		// 读出的记录内容
   1023          		spi_flash_raddr(tmpadd+1, recordsize, record);
   1024          		// 读出的校验字节
   1025          		spi_flash_raddr(tmpadd+1+recordsize, 1, &chkcode);		//如果不是读取整条记录，那么校验字节没有意义
   1026          		// 校验不计算记录的第一个字节
   1027          		tmpchk	= record[1];
   1028          		for (i = 2; i < recordsize; i++)
   1029          		{
   1030          			tmpchk ^= record[i];
   1031          		}
   1032          		if (tmpchk != chkcode)
   1033          		{
   1034          			return -6;
   1035          		}
   1036          		return 0;
   1037          	} 
   1038          	else
   1039          	{
   1040          		//校验纠错不计算第一字节
   1041          		recordsizetmp	= recordsize;
   1042          		spi_flash_raddr(tmpadd+1, 1, record);
   1043          		recordsizetmp--;
   1044          		i = 0;
   1045          		while(recordsizetmp / 256)
   1046          		{
   1047          			spi_flash_raddr(tmpadd+2+256*i, 256, record+1+256*i);
   1048          			spi_flash_raddr(tmpadd+1+recordsize+3*i, 3, ecckey_read);
   1049          			calculate_ecc(record+1+256*i,256,ecckey_cal);
   1050          			if (0 != MEMCMP(ecckey_cal,ecckey_read,3))
   1051          			{
   1052          				correct_data(record+1+256*i, ecckey_read, ecckey_cal,256);
   1053          			}
   1054          			i++;
   1055          			recordsizetmp -= 256;
   1056          		}
   1057          		if (recordsizetmp != 0)
   1058          		{
   1059          			MEMSET(eccdata_tmp, 0, 256);
   1060          			spi_flash_raddr(tmpadd+2+256*i, recordsizetmp, eccdata_tmp);
   1061          			spi_flash_raddr(tmpadd+1+recordsize+3*i, 3, ecckey_read);
   1062          			calculate_ecc(eccdata_tmp, 256, ecckey_cal);
   1063          			if (0 != MEMCMP(ecckey_cal,ecckey_read,3))
   1064          			{
   1065          				correct_data(eccdata_tmp, ecckey_read, ecckey_cal, 256);
   1066          			}
   1067          			MEMCPY(record+1+256*i, eccdata_tmp, recordsizetmp);
   1068          		}
   1069          		return 0;
   1070          	}
   1071          }
   1072          
   1073          
   1074          /**
   1075           * @brief  修改标志字节
   1076           * @param  rectype: 记录类型
   1077           * @param    index: 要修改的记录编号
   1078           * @param  mrkflag: 要修改的标志
   1079           * @retval    0: 修改成功
   1080           *           -1: 不支持此类型记录
   1081           *           -2: Flash尚未初始化
   1082           *           -3: 文件系统尚未初始化
   1083           *           -4: 无此记录
   1084           *           -5: 写Flash出错
   1085           * @note  约定记录的第一个字节做为标志字节，该
   1086           *        字节不记入校验值中
   1087           */
   1088          int record_modify(unsigned char rectype, int index, unsigned char mrkflag)
   1089          {
   1090          	int						recindex;		// 记录区号索引
   1091          	unsigned int			recordtotal;	// 整个记录区所需空间
   1092          	unsigned int			recordstart;	// 记录区起始地址
   1093          	unsigned int			recordheadpt;	// 第0条记录指针
   1094          	unsigned short			recordspace;	// 一条记录的空间
   1095          	unsigned short			recordcount;	// 当前记录条数
   1096          	unsigned int			tmpadd;			// 临时用地址
   1097          
   1098          	/********* 读记录步骤 ****************/
   1099          	/* 1.检查输入类型 ********************/
   1100          	recindex	= rec_getindex(rectype);
   1101          	if (-1 == recindex )
   1102          	{
   1103          		return -1;		// 不支持此类型记录
   1104          	}
   1105          
   1106          	/* 2.检查Flash状态 ********************/
   1107          	if (0 != spi_flash_valid())
   1108          	{
   1109          		return -2;		// Flash尚未初始化
   1110          	}
   1111          
   1112          	/* 3.检查文件系统是否初始化 *********/
   1113          	if (0xAA != recinfo[recindex].rec_valid)
   1114          	{
   1115          		return -3;		// 文件系统尚未初始化
   1116          	}
   1117          
   1118          	/* 4.定位索引为index的记录位置 ******/
   1119          	recordcount		= recinfo[recindex].rec_count;
   1120          	recordheadpt	= recinfo[recindex].rec_hdpt;
   1121          	recordstart		= recinfo[recindex].rec_start;
   1122          	recordspace		= recinfo[recindex].rec_space;
   1123          	recordtotal		= recinfo[recindex].rec_total;
   1124          
   1125          	if (index >= recordcount)	// 索引号大于或等于当前总记录数
   1126          	{
   1127          		return -4;				// 无此记录
   1128          	}
   1129          	if (recordheadpt >= recordstart + index * recordspace)
   1130          	{
   1131          		tmpadd	= recordheadpt - index * recordspace;
   1132          	}
   1133          	else
   1134          	{
   1135          		tmpadd = recordtotal + recordheadpt - index * recordspace;
   1136          	}
   1137          	if (0 != spi_flash_waddr(tmpadd+1, 1, &mrkflag))	// 只写record的第一个字节
   1138          	{
   1139          		return -5;		// 写Flash出错
   1140          	}
   1141          	
   1142          #ifdef	RECORD_DEBUG
   1143          	printf("Addr: 0x%08X\r\n",tmpadd);
   1144          #endif
   1145          	return 0;
   1146          }
   1147          
   1148          
   1149          /**
   1150          * @brief  替换某一条记录
   1151          * @param  rectype: 记录类型
   1152          * @param    index: 要修改的记录编号
   1153          * @param	*pNewData:	替换原来记录的新数据
   1154          * @retval    0: 修改成功
   1155          *           -1: 不支持此类型记录
   1156          *           -2: Flash尚未初始化
   1157          *           -3: 文件系统尚未初始化
   1158          *           -4: 无此记录
   1159          *           -5: 写Flash出错
   1160          * @note  约定记录的第一个字节做为标志字节，该
   1161          *        字节不记入校验值中
   1162          */
   1163          int record_replace(unsigned char rectype, int index, unsigned char *pNewData)
   1164          {
   1165          	int						recindex;		// 记录区号索引
   1166          	unsigned int			recordtotal;	// 整个记录区所需空间
   1167          	unsigned int			recordstart;	// 记录区起始地址
   1168          	unsigned int			recordheadpt;	// 第0条记录指针
   1169          	unsigned short			recordspace;	// 一条记录的空间
   1170          	unsigned short			recordsize;		// 一条记录的大小
   1171          	unsigned short			recordcount;	// 当前记录条数
   1172          	unsigned int			tmpadd;			// 临时用地址
   1173          	unsigned int			i,target_blk;		// 要修改的记录所在的blk
   1174          	unsigned short			recordsizetmp;	// 记录大小临时变量
   1175          	unsigned int			swap_blk;		//交换块的地址
   1176          //	unsigned int			before_cnt;		//在一个擦除块中在要替换的记录之前的记录数
   1177          
   1178          	/********* 读记录步骤 ****************/
   1179          	/* 1.检查输入类型 ********************/
   1180          	recindex	= rec_getindex(rectype);
   1181          	if (-1 == recindex )
   1182          	{
   1183          		return -1;		// 不支持此类型记录
   1184          	}
   1185          
   1186          	/* 2.检查Flash状态 ********************/
   1187          	if (0 != spi_flash_valid())
   1188          	{
   1189          		return -2;		// Flash尚未初始化
   1190          	}
   1191          
   1192          	/* 3.检查文件系统是否初始化 *********/
   1193          	if (0xAA != recinfo[recindex].rec_valid)
   1194          	{
   1195          		return -3;		// 文件系统尚未初始化
   1196          	}
   1197          
   1198          	/* 4.定位索引为index的记录位置 ******/
   1199          	recordcount		= recinfo[recindex].rec_count;
   1200          	recordheadpt	= recinfo[recindex].rec_hdpt;
   1201          	recordstart		= recinfo[recindex].rec_start;
   1202          	recordspace		= recinfo[recindex].rec_space;
   1203          	recordtotal		= recinfo[recindex].rec_total;
   1204          	recordsize		= recinfo[recindex].rec_size;
   1205          
   1206          	if (index >= recordcount)	// 索引号大于或等于当前总记录数
   1207          	{
   1208          		return -4;				// 无此记录
   1209          	}
   1210          	if (recordheadpt >= recordstart + index * recordspace)
   1211          	{
   1212          		tmpadd	= recordheadpt - index * recordspace;
   1213          	}
   1214          	else
   1215          	{
   1216          		tmpadd = recordtotal + recordheadpt - index * recordspace;
   1217          	}
   1218          
   1219          	//先将该记录所在的block copy到记录区的交换块
   1220          	target_blk	= tmpadd & (~BLKMSK);	//要修改的记录所在的block
   1221          	swap_blk = recordstart + recordtotal;		//交换块的地址
   1222          	if (0 != spi_flash_erasesector(swap_blk))	// 清空数据交换块
   1223          	{
   1224          		return -5;		// 写Flash出错
   1225          	}
   1226          	// 将该记录之前的记录先copy到交换块
   1227          	if (0 != rec_copy4kblk(swap_blk, target_blk, tmpadd-target_blk))
   1228          	{
   1229          		return -5;		// 写Flash出错
   1230          	}
   1231          
   1232          	//将新记录增加进来
   1233          	/****** 分ECC和异或校验两种情况写记录 ****************/
   1234          	if (recinfo[recindex].rec_eccflag == 0x80)	//ECC
   1235          	{
   1236          		// ******* 写ECC
   1237          		recordsizetmp	= recordsize-1;
   1238          		i = 0;
   1239          		while(recordsizetmp / 256)
   1240          		{
   1241          			calculate_ecc(pNewData+1+i*256, 256, ecckey_cal);
   1242          			if (0 != spi_flash_waddr(swap_blk + (tmpadd - target_blk) + 1 + recordsize + i*3, 3, ecckey_cal))	// 写校验码
   1243          			{
   1244          				return -5;		// 写Flash出错
   1245          			}
   1246          			spi_flash_raddr(swap_blk + (tmpadd - target_blk)+1+recordsize+i*3, 3, ecckey_read);
   1247          			if (0 != MEMCMP(ecckey_read, ecckey_cal, 3))
   1248          			{
   1249          				spi_flash_raddr(swap_blk + (tmpadd - target_blk)+1+recordsize+i*3, 3, ecckey_read);
   1250          				if (0 != MEMCMP(ecckey_read, ecckey_cal, 3))
   1251          				{
   1252          					return -5;
   1253          				}
   1254          			}
   1255          			i++;
   1256          			recordsizetmp -= 256;
   1257          		}
   1258          		if (recordsizetmp != 0)
   1259          		{
   1260          			MEMSET(eccdata_tmp, 0, 256);
   1261          			MEMCPY(eccdata_tmp,pNewData+1+i*256,recordsizetmp);
   1262          			calculate_ecc(eccdata_tmp, 256, ecckey_cal);
   1263          			if (0 != spi_flash_waddr(swap_blk + (tmpadd - target_blk)+1+recordsize+i*3, 3, ecckey_cal))	// 写校验码
   1264          			{
   1265          				return -5;		// 写Flash出错
   1266          			}
   1267          			spi_flash_raddr(swap_blk + (tmpadd - target_blk)+1+recordsize+i*3, 3, ecckey_read);
   1268          			if (0 != MEMCMP(ecckey_read, ecckey_cal, 3))
   1269          			{
   1270          				spi_flash_raddr(swap_blk + (tmpadd - target_blk)+1+recordsize+i*3, 3, ecckey_read);
   1271          				if (0 != MEMCMP(ecckey_read, ecckey_cal, 3))
   1272          				{
   1273          					return -5;
   1274          				}
   1275          			}
   1276          		}
   1277          		// *************  写记录
   1278          		if (0 != spi_flash_waddr(swap_blk + (tmpadd - target_blk)+1, recordsize,pNewData))	// 写记录
   1279          		{
   1280          			return -5;		// 写Flash出错
   1281          		}
   1282          		for (i = 0; i < recordsize; i++)
   1283          		{
   1284          			spi_flash_raddr(swap_blk + (tmpadd - target_blk)+1+i, 1, &tmpfgrb);
   1285          			if (pNewData[i] != tmpfgrb)
   1286          			{
   1287          				spi_flash_raddr(swap_blk + (tmpadd - target_blk)+1+i, 1, &tmpfgrb);
   1288          				if (pNewData[i] != tmpfgrb)
   1289          				{
   1290          					return -5;
   1291          				}
   1292          			}
   1293          		}
   1294          	} 
   1295          	else	// 异或校验
   1296          	{
   1297          		// 1.计算校验码 每条记录的第一个字节不计入校验，供用户做标志位用
   1298          		tmpfgwi	= pNewData[1];
   1299          		for (i = 2; i < recordsize; i++)
   1300          		{
   1301          			tmpfgwi	^= pNewData[i];
   1302          		}
   1303          		if (0 != spi_flash_waddr(swap_blk + (tmpadd - target_blk)+1+recordsize, 1, &tmpfgwi))	// 写校验码
   1304          		{
   1305          			return -5;		// 写Flash出错
   1306          		}
   1307          		spi_flash_raddr(swap_blk + (tmpadd - target_blk)+1+recordsize, 1, &tmpfgrb);
   1308          		if (tmpfgwi != tmpfgrb)
   1309          		{
   1310          			spi_flash_raddr(swap_blk + (tmpadd - target_blk)+1+recordsize, 1, &tmpfgrb);
   1311          			if (tmpfgwi != tmpfgrb)
   1312          			{
   1313          				return -5;
   1314          			}
   1315          		}
   1316          
   1317          		if (0 != spi_flash_waddr(swap_blk + (tmpadd - target_blk)+1, recordsize, pNewData))	// 写记录
   1318          		{
   1319          			return -5;		// 写Flash出错
   1320          		}
   1321          
   1322          		//这个比较有点慢哦，可以一次读取出来比较应该会快很多
   1323          		for (i = 0; i < recordsize; i++)
   1324          		{
   1325          			spi_flash_raddr(swap_blk + (tmpadd - target_blk)+1+i, 1, &tmpfgrb);
   1326          			if (pNewData[i] != tmpfgrb)
   1327          			{
   1328          				spi_flash_raddr(swap_blk + (tmpadd - target_blk)+1+i, 1, &tmpfgrb);
   1329          				if (pNewData[i] != tmpfgrb)
   1330          				{
   1331          					return -5;
   1332          				}
   1333          			}
   1334          		}
   1335          	}
   1336          
   1337          	//写记录有效标记
   1338          	tmpfgwi	= REC_VALID;
   1339          	if (0 != spi_flash_waddr(swap_blk + (tmpadd - target_blk), 1, &tmpfgwi))
   1340          	{
   1341          		return -5;		// 写Flash出错
   1342          	}
   1343          	spi_flash_raddr(swap_blk + (tmpadd - target_blk), 1, &tmpfgrb);
   1344          	if (tmpfgwi != tmpfgrb)
   1345          	{
   1346          		spi_flash_raddr(swap_blk + (tmpadd - target_blk), 1, &tmpfgrb);
   1347          		if (tmpfgwi != tmpfgrb)
   1348          		{
   1349          			return -5;
   1350          		}
   1351          	}
   1352          
   1353          	//将该记录区之后的记录copy到交换块
   1354          	if (0 != rec_copy4kblk(swap_blk + (tmpadd - target_blk) + recordspace, tmpadd + recordspace, BLKSIZE - (tmpadd-target_blk) - recordspace))
   1355          	{
   1356          		return -5;		// 写Flash出错
   1357          	}
   1358          
   1359          	//到此为止，要替换的记录所在的记录块里面的记录全部被copy到交换块里面了
   1360          
   1361          	//在擦除要替换的记录所在的记录块之前需要对其下一个记录块做标记，表示此记录块已经被备份到了交换块，可以断电恢复
   1362          	tmpfgwi	= REC_FMTEXOP;
   1363          	tmpadd	= target_blk + BLKSIZE;
   1364          	if (tmpadd == recordstart + recordtotal)
   1365          	{
   1366          		tmpadd	= recordstart;
   1367          	}
   1368          	if (0 != spi_flash_waddr(tmpadd, 1, &tmpfgwi))
   1369          	{
   1370          		return -5;		// 写Flash出错
   1371          	}
   1372          	//擦除要替换的记录所在的记录块
   1373          	if (0 != spi_flash_erasesector(target_blk))
   1374          	{
   1375          		return -5;		// 写Flash出错
   1376          	}
   1377          
   1378          	//将交换块的记录copy回来
   1379          	if (0 != rec_copy4kblk(target_blk,swap_blk,BLKSIZE))
   1380          	{
   1381          		return -5;		// 写Flash出错
   1382          	}
   1383          
   1384          	tmpfgwi	= REC_FMTOVOP;
   1385          	if (0 != spi_flash_waddr(tmpadd, 1, &tmpfgwi))
   1386          	{
   1387          		return -5;		// 写Flash出错
   1388          	}
   1389          	return 0;
   1390          }
   1391          
   1392          
   1393          /**
   1394           * @brief  写入记录
   1395           * @param  *record: 存放的地址
   1396           * @param  rectype: 记录类型
   1397           * @param      len: 要读取的记录长度
   1398           * @retval    0: 写入成功
   1399           *           -1: 不支持此类型记录
   1400           *           -2: Flash尚未初始化
   1401           *           -3: 文件系统尚未初始化
   1402           *           -4: 输入参数长度大于参数所能容纳的长度
   1403           *           -5: 写入记录失败
   1404           *           -6: 写Flash出错
   1405           */
   1406          int record_write(unsigned char rectype, unsigned char *record, unsigned int len)
   1407          {
   1408          	int						i;	
   1409          	int						recindex;		// 记录区号索引
   1410          	unsigned int			recordtotal;	// 整个记录区所需空间
   1411          	unsigned int			recordstart;	// 记录区起始地址
   1412          	unsigned int			recordheadpt;	// 第0条记录指针
   1413          	unsigned short			recordspace;	// 一条记录的空间
   1414          	unsigned short			recordsize;		// 一条记录的大小
   1415          	unsigned short			recordsizetmp;	// 记录大小临时变量
   1416          	unsigned short			recordcount;	// 当前记录条数
   1417          	unsigned short			recordmaxnum;	// 记录区可存放最大记录数
   1418          	unsigned int			tmpadd;			// 临时用地址
   1419          	//unsigned char			tmpfgwi;		// 临时字节write in				
   1420          	//unsigned char			tmpfgrb;		// 临时字节read back
   1421          
   1422          	/********* 写记录步骤 ****************/
   1423          	/* 1.检查输入类型 ********************/
   1424          	recindex	= rec_getindex(rectype);
   1425          	if (-1 == recindex )
   1426          	{
   1427          		return -1;		// 不支持此类型记录
   1428          	}
   1429          
   1430          	/* 2.检查Flash状态 ********************/
   1431          	if (0 != spi_flash_valid())
   1432          	{
   1433          		return -2;		// Flash尚未初始化
   1434          	}
   1435          
   1436          	/* 3.检查文件系统是否初始化 *********/
   1437          	if (0xAA != recinfo[recindex].rec_valid)
   1438          	{
   1439          		return -3;		// 文件系统尚未初始化
   1440          	}
   1441          	
   1442          	recordcount		= recinfo[recindex].rec_count;
   1443          	recordheadpt	= recinfo[recindex].rec_hdpt;
   1444          	recordstart		= recinfo[recindex].rec_start;
   1445          	recordspace		= recinfo[recindex].rec_space;
   1446          	recordtotal		= recinfo[recindex].rec_total;
   1447          	recordsize		= recinfo[recindex].rec_size;
   1448          	recordmaxnum	= recinfo[recindex].rec_maxnum;
   1449          
   1450          	/* 4.检查输入长度 ********************/
   1451          	if (len > recordsize)
   1452          	{
   1453          		return -4;
   1454          	}
   1455          	else if (len != 0)
   1456          	{
   1457          		recordsize	= len;
   1458          	}
   1459          
   1460          	/* 5.写记录 ***************************/
   1461          	recordheadpt	+= recordspace;
   1462          
   1463          	if (0 == (recordheadpt & BLKMSK))	// 如果将写入的新记录位置是4K块首地址则需要删除该块以写入新记录
   1464          	{
   1465          		if (recordheadpt == recordstart + recordtotal)	// 如果已经到了记录区尾部，则重新指向开始位置
   1466          		{
   1467          			recordheadpt = recordstart;
   1468          		}
   1469          		// 删除一块4K块
   1470          		tmpfgwi	= REC_FMTINOP;
   1471          		tmpadd	= recordheadpt + BLKSIZE;
   1472          		if (tmpadd == recordstart + recordtotal)
   1473          		{
   1474          			tmpadd	= recordstart;
   1475          		}
   1476          		if (0 != spi_flash_waddr(tmpadd, 1, &tmpfgwi))
   1477          		{
   1478          			return -5;		// 写Flash出错
   1479          		}
   1480          		if (0 != spi_flash_erasesector(recordheadpt))
   1481          		{
   1482          			return -5;		// 写Flash出错
   1483          		}
   1484          		tmpfgwi	= REC_FMTOVOP;
   1485          		if (0 != spi_flash_waddr(tmpadd, 1, &tmpfgwi))
   1486          		{
   1487          			return -5;		// 写Flash出错
   1488          		}
   1489          	}
   1490          
   1491          	// 写记录步骤
   1492          	// 每写一段数据马上读回比较，如果写入与读回不同则利用断电交换区，
   1493          	// 删除掉刚写入的所有数据，并返回出错
   1494          	// 分为ECC和简单异或校验两种情况
   1495          
   1496          	/********** 写断电标志设置为无效 *********************/
   1497          	tmpfgwi	= REC_INVALID;
   1498          	test_var1 = recordheadpt;
   1499          	if (0 != spi_flash_waddr(recordheadpt, 1, &tmpfgwi))
   1500          	{
   1501          		return -5;		// 写Flash出错
   1502          	}
   1503          
   1504          	test_var2 = recordheadpt;
   1505          	spi_flash_raddr(recordheadpt, 1, &tmpfgrb);
   1506          	if (tmpfgwi != tmpfgrb)
   1507          	{
   1508          		spi_flash_raddr(recordheadpt, 1, &tmpfgrb);
   1509          		if (tmpfgwi != tmpfgrb)
   1510          		{
   1511          			goto Rollback;
   1512          		}
   1513          	}
   1514          	
   1515          	/****** 分ECC和异或校验两种情况写记录 ****************/
   1516          	if (recinfo[recindex].rec_eccflag == 0x80)	//ECC
   1517          	{
   1518          		// ******* 写ECC
   1519          		recordsizetmp	= recordsize-1;
   1520          		i = 0;
   1521          		while(recordsizetmp / 256)
   1522          		{
   1523          			calculate_ecc(record+1+i*256, 256, ecckey_cal);
   1524          			if (0 != spi_flash_waddr(recordheadpt+1+recordsize+i*3, 3, ecckey_cal))	// 写校验码
   1525          			{
   1526          				return -5;		// 写Flash出错
   1527          			}
   1528          			spi_flash_raddr(recordheadpt+1+recordsize+i*3, 3, ecckey_read);
   1529          			if (0 != MEMCMP(ecckey_read, ecckey_cal, 3))
   1530          			{
   1531          				spi_flash_raddr(recordheadpt+1+recordsize+i*3, 3, ecckey_read);
   1532          				if (0 != MEMCMP(ecckey_read, ecckey_cal, 3))
   1533          				{
   1534          					goto Rollback;
   1535          				}
   1536          			}
   1537          			i++;
   1538          			recordsizetmp -= 256;
   1539          		}
   1540          		if (recordsizetmp != 0)
   1541          		{
   1542          			MEMSET(eccdata_tmp, 0, 256);
   1543          			MEMCPY(eccdata_tmp,record+1+i*256,recordsizetmp);
   1544          			calculate_ecc(eccdata_tmp, 256, ecckey_cal);
   1545          			if (0 != spi_flash_waddr(recordheadpt+1+recordsize+i*3, 3, ecckey_cal))	// 写校验码
   1546          			{
   1547          				return -5;		// 写Flash出错
   1548          			}
   1549          			spi_flash_raddr(recordheadpt+1+recordsize+i*3, 3, ecckey_read);
   1550          			if (0 != MEMCMP(ecckey_read, ecckey_cal, 3))
   1551          			{
   1552          				spi_flash_raddr(recordheadpt+1+recordsize+i*3, 3, ecckey_read);
   1553          				if (0 != MEMCMP(ecckey_read, ecckey_cal, 3))
   1554          				{
   1555          					goto Rollback;
   1556          				}
   1557          			}
   1558          		}
   1559          		// *************  写记录
   1560          		if (0 != spi_flash_waddr(recordheadpt+1, recordsize, record))	// 写记录
   1561          		{
   1562          			return -5;		// 写Flash出错
   1563          		}
   1564          		for (i = 0; i < recordsize; i++)
   1565          		{
   1566          			spi_flash_raddr(recordheadpt+1+i, 1, &tmpfgrb);
   1567          			if (record[i] != tmpfgrb)
   1568          			{
   1569          				spi_flash_raddr(recordheadpt+1+i, 1, &tmpfgrb);
   1570          				if (record[i] != tmpfgrb)
   1571          				{
   1572          					goto Rollback;
   1573          				}
   1574          			}
   1575          		}
   1576          	} 
   1577          	else	// 异或校验
   1578          	{
   1579          		// 1.计算校验码 每条记录的第一个字节不计入校验，供用户做标志位用
   1580          		tmpfgwi	= record[1];
   1581          		for (i = 2; i < recordsize; i++)
   1582          		{
   1583          			tmpfgwi	^= record[i];
   1584          		}
   1585          		if (0 != spi_flash_waddr(recordheadpt+1+recordsize, 1, &tmpfgwi))	// 写校验码
   1586          		{
   1587          			return -5;		// 写Flash出错
   1588          		}
   1589          		spi_flash_raddr(recordheadpt+1+recordsize, 1, &tmpfgrb);
   1590          		if (tmpfgwi != tmpfgrb)
   1591          		{
   1592          			spi_flash_raddr(recordheadpt+1+recordsize, 1, &tmpfgrb);
   1593          			if (tmpfgwi != tmpfgrb)
   1594          			{
   1595          				goto Rollback;
   1596          			}
   1597          		}
   1598          
   1599          		if (0 != spi_flash_waddr(recordheadpt+1, recordsize, record))	// 写记录
   1600          		{
   1601          			return -5;		// 写Flash出错
   1602          		}
   1603          
   1604          		//这个比较有点慢哦，可以一次读取出来比较应该会快很多
   1605          		for (i = 0; i < recordsize; i++)
   1606          		{
   1607          			spi_flash_raddr(recordheadpt+1+i, 1, &tmpfgrb);
   1608          			if (record[i] != tmpfgrb)
   1609          			{
   1610          				spi_flash_raddr(recordheadpt+1+i, 1, &tmpfgrb);
   1611          				if (record[i] != tmpfgrb)
   1612          				{
   1613          					goto Rollback;
   1614          				}
   1615          			}
   1616          		}
   1617          	}
   1618          	/*********** 写断电标志设置为有效 *********************/
   1619          	tmpfgwi	= REC_VALID;
   1620          	if (0 != spi_flash_waddr(recordheadpt, 1, &tmpfgwi))
   1621          	{
   1622          		return -5;		// 写Flash出错
   1623          	}
   1624          	spi_flash_raddr(recordheadpt, 1, &tmpfgrb);
   1625          	if (tmpfgwi != tmpfgrb)
   1626          	{
   1627          		spi_flash_raddr(recordheadpt, 1, &tmpfgrb);
   1628          		if (tmpfgwi != tmpfgrb)
   1629          		{
   1630          			goto Rollback;
   1631          		}
   1632          	}
   1633          	recinfo[recindex].rec_hdpt	= recordheadpt;		// 更新Head指针
   1634          	// 如果当前记录数达到最大记录数值则删除最老记录，否则当前记录加1
   1635          	if (recordcount == recordmaxnum)
   1636          	{
   1637          		if (recordheadpt >= recordstart + recordspace * recordmaxnum)
   1638          		{
   1639          			tmpadd	= recordheadpt - recordspace * recordmaxnum;
   1640          		}
   1641          		else
   1642          		{
   1643          			tmpadd	= recordtotal + recordheadpt - recordspace * recordmaxnum;
   1644          		}
   1645          		tmpfgwi	= REC_OBSOLETE;
   1646          		if (0 != spi_flash_waddr(tmpadd, 1, &tmpfgwi))
   1647          		{
   1648          			return -5;		// 写Flash出错
   1649          		}
   1650          	}
   1651          	else
   1652          	{
   1653          		recinfo[recindex].rec_count++;
   1654          	}
   1655          	return 0;
   1656          
   1657          /********** 写入失败时的恢复代码 ************/
   1658          Rollback:
   1659          	tmpadd	= recordheadpt & (~BLKMSK);
   1660          	if (0 != spi_flash_erasesector(recordstart + recordtotal))	// 清空断电恢复区
   1661          	{
   1662          		return -5;		// 写Flash出错
   1663          	}
   1664          	// 将需要保留的数据临时存放到断电恢复区
   1665          	if (0 != rec_copy4kblk(recordstart + recordtotal, tmpadd, recordheadpt-tmpadd))
   1666          	{
   1667          		return -5;		// 写Flash出错
   1668          	}
   1669          	// 清空该4K块
   1670          	if (0 != spi_flash_erasesector(tmpadd))
   1671          	{
   1672          		return -5;		// 写Flash出错
   1673          	}
   1674          	// 将临时存放在断电恢复区的数据存回来
   1675          	if (0 != rec_copy4kblk(tmpadd, recordstart + recordtotal, recordheadpt-tmpadd))
   1676          	{
   1677          		return -5;		// 写Flash出错
   1678          	}
   1679          	return -6;			// 写入记录失败
   1680          }
   1681          
   1682          
   1683          /**
   1684          * @brief  删除指定记录区的所有记录
   1685          * @param  rectype: 记录区类型
   1686          * @retval    0: 删除成功
   1687          *           -1: 不支持此类型记录
   1688          *           -2: Flash尚未初始化
   1689          *           -3: 文件系统尚未初始化
   1690          *           -4: 写Flash出错
   1691          */
   1692          int record_delall(unsigned char rectype)
   1693          {
   1694          	int						recindex;		// 记录区号索引
   1695          	unsigned int			recordtotal;	// 整个记录区所需空间
   1696          	unsigned int			recordstart;	// 记录区起始地址
   1697          	unsigned int			recordheadpt;	// 第0条记录指针
   1698          	unsigned short			recordspace;	// 一条记录的空间
   1699          	unsigned short			recordcount;	// 当前记录条数
   1700          	unsigned char			rcvflag;		// 记录状态标志
   1701          
   1702          	/******* 删除所有记录步骤 ***********/
   1703          	/* 1.检查输入类型 ********************/
   1704          	recindex	= rec_getindex(rectype);
   1705          	if (-1 == recindex )
   1706          	{
   1707          		return -1;		// 不支持此类型记录
   1708          	}
   1709          
   1710          	/* 2.检查Flash状态 ********************/
   1711          	if (0 != spi_flash_valid())
   1712          	{
   1713          		return -2;		// Flash尚未初始化
   1714          	}
   1715          
   1716          	/* 3.检查文件系统是否初始化 *********/
   1717          	if (0xAA != recinfo[recindex].rec_valid)
   1718          	{
   1719          		return -3;		// 文件系统尚未初始化
   1720          	}
   1721          
   1722          	recordcount		= recinfo[recindex].rec_count;
   1723          	recordheadpt	= recinfo[recindex].rec_hdpt;
   1724          	recordstart		= recinfo[recindex].rec_start;
   1725          	recordspace		= recinfo[recindex].rec_space;
   1726          	recordtotal		= recinfo[recindex].rec_total;
   1727          
   1728          	/* 4.将所有记录标志成过时 ***********/
   1729          	rcvflag			= REC_OBSOLETE;
   1730          	while (recordcount > 0)
   1731          	{
   1732          		if (0 != spi_flash_waddr(recordheadpt, 1, &rcvflag))
   1733          		{
   1734          			return -4;		// 写Flash失败
   1735          		}
   1736          		if (recordheadpt == recordstart)
   1737          		{
   1738          			recordheadpt = recordstart + recordtotal;
   1739          		}
   1740          		recordheadpt -= recordspace;
   1741          		recordcount--;
   1742          	}
   1743          	recinfo[recindex].rec_count	= recordcount;
   1744          	return 0;
   1745          }
   1746          
   1747          
   1748          /**
   1749          * @brief  获取记录区参数
   1750          * @param  rectype: 记录类型
   1751          * @param  recblkinfo: 记录信息结构体指针
   1752          * @retval    0:获取成功
   1753          *           -1:不支持此类型记录
   1754          *           -2:Flash尚未初始化
   1755          *           -3:文件系统尚未初始化
   1756          */
   1757          int get_recordinfo(unsigned char rectype, tRECBLKInfo *recblkinfo)
   1758          {
   1759          	int						recindex;		// 记录区号索引
   1760          
   1761          	/******* 获取记录区步骤 **************/
   1762          	/* 1.检查输入类型 ********************/
   1763          	recindex	= rec_getindex(rectype);
   1764          	if (-1 == recindex )
   1765          	{
   1766          		return -1;		// 不支持此类型记录
   1767          	}
   1768          
   1769          	/* 2.检查Flash状态 ********************/
   1770          	if (0 != spi_flash_valid())
   1771          	{
   1772          		return -2;		// Flash尚未初始化
   1773          	}
   1774          
   1775          	/* 3.检查文件系统是否初始化 *********/
   1776          	if (0xAA != recinfo[recindex].rec_valid)
   1777          	{
   1778          		return -3;		// 文件系统尚未初始化
   1779          	}
   1780          
   1781          	/* 4.获取信息 *************************/
   1782          	recblkinfo->recblk_startadd	= recinfo[recindex].rec_start - BLKSIZE;
   1783          	recblkinfo->recblk_totsize	= recinfo[recindex].rec_total + 2 * BLKSIZE;
   1784          	recblkinfo->recblk_datadd	= recinfo[recindex].rec_start;
   1785          	recblkinfo->recblk_datcnt	= recinfo[recindex].rec_count;
   1786          	recblkinfo->recblk_datotal	= recinfo[recindex].rec_total;
   1787          	recblkinfo->recblk_datsize	= recinfo[recindex].rec_size;
   1788          	recblkinfo->recblk_datspac	= recinfo[recindex].rec_space;
   1789          	recblkinfo->recblk_maxcap	= recinfo[recindex].rec_maxnum;
   1790          	recblkinfo->recblk_hdpt		= recinfo[recindex].rec_hdpt;
   1791          	recblkinfo->recblk_eccen	= recinfo[recindex].rec_eccflag;
   1792          	return 0;
   1793          }
   1794          
   1795          /**
   1796           * @brief  格式化一个大小为paramsize的参数区。
   1797           * @param  recordsize: 参数区的大小
   1798           * @retval    0: 格式化成功
   1799           *           -1: 不支持此类型记录
   1800           *           -2: Flash尚未初始化
   1801           *           -3: 参数长度大于2K-2
   1802           *           -4: 读RIT出错，文件系统错误
   1803           *           -5: Flash空间不够
   1804           *           -6: 写Flash出错
   1805           */
   1806          int param_format(unsigned int paramsize)
   1807          {
   1808          	return record_format(PARBLK, paramsize, 8);
   1809          }
   1810          
   1811          /**
   1812           * @brief  读取参数
   1813           * @param   *param: 存放的地址
   1814           *             len: 要读取的参数长度
   1815           * @retval    0: 读取成功
   1816           *           -1: 不支持此类型记录
   1817           *           -2: Flash尚未初始化
   1818           *           -3: 文件系统尚未初始化
   1819           *           -4: 无此记录
   1820           *           -5: 输入参数长度大于参数所能容纳的长度
   1821           *           -6: 读参数出错
   1822           */
   1823          int param_read(unsigned char *param, unsigned int len)
   1824          {
   1825          	int						i,index;			
   1826          	int						recindex;		// 记录区号索引
   1827          	unsigned char			chkcode;		// 记录存放的校验码
   1828          	unsigned char			tmpchk;			// 计算出的校验码
   1829          	unsigned int			recordtotal;	// 整个记录区所需空间
   1830          	unsigned int			recordstart;	// 记录区起始地址
   1831          	unsigned int			recordheadpt;	// 第0条记录指针
   1832          	unsigned short			recordspace;	// 一条记录的空间
   1833          	unsigned short			recordsize;		// 一条记录的大小
   1834          	unsigned short			recordcount;	// 当前记录条数
   1835          	unsigned int			tmpadd;			// 临时用地址
   1836          
   1837          
   1838          	/********* 读记录步骤 ****************/
   1839          	/* 1.检查输入类型 ********************/
   1840          	recindex	= rec_getindex(PARBLK);
   1841          	if (-1 == recindex )
   1842          	{
   1843          		return -1;		// 不支持此类型记录
   1844          	}
   1845          
   1846          	/* 2.检查Flash状态 ********************/
   1847          	if (0 != spi_flash_valid())
   1848          	{
   1849          		return -2;		// Flash尚未初始化
   1850          	}
   1851          
   1852          	/* 3.检查文件系统是否初始化 *********/
   1853          	if (0xAA != recinfo[recindex].rec_valid)
   1854          	{
   1855          		return -3;		// 文件系统尚未初始化
   1856          	}
   1857          
   1858          	/* 4.定位索引为index的记录位置 ******/
   1859          	recordcount		= recinfo[recindex].rec_count;
   1860          	recordheadpt	= recinfo[recindex].rec_hdpt;
   1861          	recordstart		= recinfo[recindex].rec_start;
   1862          	recordspace		= recinfo[recindex].rec_space;
   1863          	recordtotal		= recinfo[recindex].rec_total;
   1864          	recordsize		= recinfo[recindex].rec_size;
   1865          	
   1866          	if (recordcount == 0)
   1867          	{
   1868          		return -4;			// 无此记录
   1869          	}
   1870          
   1871          	if (len > recordsize)
   1872          	{
   1873          		return -5;			// 输入参数长度大于参数所能容纳的长度
   1874          	}
   1875          	else
   1876          	{
   1877          		recordsize	= len;
   1878          	}
   1879          
   1880          	for (index = 0; index < 4; index++)
   1881          	{
   1882          		if (recordheadpt >= recordstart + index * recordspace)
   1883          		{
   1884          			tmpadd	= recordheadpt - index * recordspace;
   1885          		}
   1886          		else
   1887          		{
   1888          			tmpadd = recordtotal + recordheadpt - index * recordspace;
   1889          		}
   1890          		spi_flash_raddr(tmpadd+2, recordsize, param);
   1891          
   1892          		// 校验读出的记录内容
   1893          		spi_flash_raddr(tmpadd+1, 1, &chkcode);
   1894          		tmpchk	= param[0];
   1895          		for (i = 1; i < recordsize; i++)
   1896          		{
   1897          			tmpchk ^= param[i];
   1898          		}
   1899          		if (tmpchk == chkcode)
   1900          		{
   1901          			return 0;
   1902          		}
   1903          	}
   1904          	return -6;	// 读参数出错
   1905          }
   1906          
   1907          /**
   1908           * @brief  写入参数
   1909           * @param  *param: 存放的地址
   1910           * @param     len: 写入长度
   1911           * @retval    0: 写入成功
   1912           *           -1: 不支持此类型记录
   1913           *           -2: Flash尚未初始化
   1914           *           -3: 文件系统尚未初始化
   1915           *           -4: 输入参数长度大于参数所能容纳的长度
   1916           *			 -5: 写Flash出错
   1917           */
   1918          int param_write(unsigned char *param, unsigned int len)
   1919          {
   1920          	int						i, j;	
   1921          	int						recindex;		// 记录区号索引
   1922          	unsigned int			recordtotal;	// 整个记录区所需空间
   1923          	unsigned int			recordstart;	// 记录区起始地址
   1924          	unsigned int			recordheadpt;	// 第0条记录指针
   1925          	unsigned short			recordspace;	// 一条记录的空间
   1926          	unsigned short			recordsize;		// 一条记录的大小
   1927          	unsigned short			recordcount;	// 当前记录条数
   1928          	unsigned short			recordmaxnum;	// 记录区可存放最大记录数
   1929          	unsigned int			tmpadd;			// 临时用地址
   1930          	unsigned char			rcvflag;		// 记录状态标志
   1931          	unsigned char			chkcode;		// 校验码
   1932          
   1933          	/********* 写参数步骤 ****************/
   1934          	/* 1.检查输入类型 ********************/
   1935          	recindex	= rec_getindex(PARBLK);
   1936          	if (-1 == recindex )
   1937          	{
   1938          		return -1;		// 不支持此类型记录
   1939          	}
   1940          
   1941          	/* 2.检查Flash状态 ********************/
   1942          	if (0 != spi_flash_valid())
   1943          	{
   1944          		return -2;		// Flash尚未初始化
   1945          	}
   1946          
   1947          	/* 3.检查文件系统是否初始化 *********/
   1948          	if (0xAA != recinfo[recindex].rec_valid)
   1949          	{
   1950          		return -3;		// 文件系统尚未初始化
   1951          	}
   1952          
   1953          	/* 4.写记录 ***************************/
   1954          	recordcount		= recinfo[recindex].rec_count;
   1955          	recordheadpt	= recinfo[recindex].rec_hdpt;
   1956          	recordstart		= recinfo[recindex].rec_start;
   1957          	recordspace		= recinfo[recindex].rec_space;
   1958          	recordtotal		= recinfo[recindex].rec_total;
   1959          	recordsize		= recinfo[recindex].rec_size;
   1960          	recordmaxnum	= recinfo[recindex].rec_maxnum;
   1961          
   1962          	if (len > recordsize)
   1963          	{
   1964          		return -4;			// 输入参数长度大于参数所能容纳的长度
   1965          	}
   1966          	else
   1967          	{
   1968          		recordsize	= len;
   1969          	}
   1970          
   1971          	for(j = 0; j < 4; j++)	// 写入4次参数
   1972          	{
   1973          		recordheadpt	+= recordspace;
   1974          
   1975          		if (0 == (recordheadpt & BLKMSK))	// 如果将写入的新纪录位置是4K块首地址则需要删除该块以写入新记录
   1976          		{
   1977          			if (recordheadpt == recordstart + recordtotal)	// 如果已经到了记录区尾部，则重新指向开始位置
   1978          			{
   1979          				recordheadpt = recordstart;
   1980          			}
   1981          			// 删除一块4K块
   1982          			spi_flash_raddr(recordheadpt, 1, &rcvflag);
   1983          			if (REC_OBSOLETE == (rcvflag | REC_STATEMSK))
   1984          			{
   1985          				rcvflag	= REC_FMTINOP;
   1986          				tmpadd	= recordheadpt + BLKSIZE;
   1987          				if (tmpadd == recordstart + recordtotal)
   1988          				{
   1989          					tmpadd	= recordstart;
   1990          				}
   1991          				if (0 != spi_flash_waddr(tmpadd, 1, &rcvflag))
   1992          				{
   1993          					return -5;		// 写Flash出错
   1994          				}
   1995          				if (0 != spi_flash_erasesector(recordheadpt))
   1996          				{
   1997          					return -5;		// 写Flash出错
   1998          				}
   1999          				rcvflag	= REC_FMTOVOP;
   2000          				if (0 != spi_flash_waddr(tmpadd, 1, &rcvflag))
   2001          				{
   2002          					return -5;		// 写Flash出错
   2003          				}
   2004          			}
   2005          		}
   2006          
   2007          		// 写参数步骤
   2008          		// 1.计算校验码
   2009          		chkcode	= param[0];
   2010          		for (i = 1; i < recordsize; i++)
   2011          		{
   2012          			chkcode	^= param[i];
   2013          		}
   2014          		// 2.写记录
   2015          		rcvflag	= REC_INVALID;
   2016          		if (0 != spi_flash_waddr(recordheadpt, 1, &rcvflag))
   2017          		{
   2018          			return -5;		// 写Flash出错
   2019          		}
   2020          		if (0 != spi_flash_waddr(recordheadpt+2, recordsize, param))
   2021          		{
   2022          			return -5;		// 写Flash出错
   2023          		}
   2024          		rcvflag	= REC_VALID;
   2025          		if (0 != spi_flash_waddr(recordheadpt, 1, &rcvflag))
   2026          		{
   2027          			return -5;		// 写Flash出错
   2028          		}
   2029          		// 3.写校验码
   2030          		if (0 != spi_flash_waddr(recordheadpt+1, 1, &chkcode))
   2031          		{
   2032          			return -5;		// 写Flash出错
   2033          		}
   2034          
   2035          		recinfo[recindex].rec_hdpt	= recordheadpt;		// 更新Head指针
   2036          
   2037          		// 如果当前记录数达到最大记录数值则删除最老记录，否则当前记录加1
   2038          		if (recordcount == recordmaxnum)
   2039          		{
   2040          			if (recordheadpt >= recordstart + recordspace * recordmaxnum)
   2041          			{
   2042          				tmpadd	= recordheadpt - recordspace * recordmaxnum;
   2043          			}
   2044          			else
   2045          			{
   2046          				tmpadd	= recordtotal + recordheadpt - recordspace * recordmaxnum;
   2047          			}
   2048          			rcvflag	= REC_OBSOLETE;
   2049          			if (0 != spi_flash_waddr(tmpadd, 1, &rcvflag))
   2050          			{
   2051          				return -5;		// 写Flash出错
   2052          			}
   2053          		}
   2054          		else
   2055          		{
   2056          			recinfo[recindex].rec_count++;
   2057          		}
   2058          	}
   2059          	return 0;
   2060          }
   2061          
   2062          /**
   2063           * @brief  获取参数区数据信息recinfo[]内容,并执行断电恢复操作
   2064           * @param  None
   2065           * @retval    0: 初始化成功
   2066           *           -1: 不支持此类型记录
   2067           *           -2: Flash尚未初始化
   2068           *           -3: 没有找到参数区
   2069           *           -4: 读RIT出错，文件系统错误
   2070           *           -5: 写Flash出错
   2071           *           -6: 记录的长度与条数与原来格式化的不匹配
   2072           */
   2073          
   2074          int param_init(unsigned int paramsize)
   2075          {
   2076          	return record_init(PARBLK,paramsize,8);
   2077          }

   Maximum stack usage in bytes:

     Function         .cstack
     --------         -------
     get_recordinfo       16
     param_format          8
     param_init            8
     param_read           40
     param_write          48
     rec_copy4kblk        32
     rec_getindex          0
     rec_getrecspc         0
     rec_readsimprit       8
     rec_writesimprit      8
     record_count         32
     record_count_ext      8
     record_delall        32
     record_format        40
     record_init          40
     record_modify        24
     record_read          32
     record_replace       48
     record_write         48


   Section sizes:

     Function/Label   Bytes
     --------------   -----
     recinfo            44
     simprit            16
     ecckey_read         4
     ecckey_cal          4
     eccdata_tmp       256
     tmpfgwi             1
     tmpfgrb             1
     test_var1           4
     test_var2           4
     rec_readsimprit    56
     rec_getrecspc      58
     rec_writesimprit   98
     rec_copy4kblk      98
     rec_getindex       24
     record_format     700
     record_init      1148
     record_count      150
     record_count_ext   70
     record_read       588
     record_modify     172
     record_replace   1268
     record_write     1348
     record_delall     188
     get_recordinfo    200
     param_format       14
     param_read        264
     param_write       564
     param_init         14
     ??DataTable5        4
     ??DataTable6        4
     ??DataTable7        4
     ??DataTable41       4
     ??DataTable50       4
     ??DataTable96       4
     ??DataTable97       4
     ??DataTable99       4
     ??DataTable105      4

 
   334 bytes in section .bss
 7 058 bytes in section .text
 
 7 058 bytes of CODE memory
   334 bytes of DATA memory

Errors: none
Warnings: 7
