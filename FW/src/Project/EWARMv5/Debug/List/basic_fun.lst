###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     12/Dec/2015  15:20:02 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\BT Printer\FW\src\App\basic_fun.c                     #
#    Command line =  "E:\BT Printer\FW\src\App\basic_fun.c" -D DEBUG_VER      #
#                    -lcN "E:\BT Printer\FW\src\Project\EWARMv5\Debug\List\"  #
#                    -o "E:\BT Printer\FW\src\Project\EWARMv5\Debug\Obj\"     #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 5.4\arm\INC\DLib_Config_Normal.h" -I "E:\BT    #
#                    Printer\FW\src\Project\EWARMv5\..\" -I "E:\BT            #
#                    Printer\FW\src\Project\EWARMv5\..\..\App\" -I "E:\BT     #
#                    Printer\FW\src\Project\EWARMv5\..\..\Drivers\" -I        #
#                    "E:\BT Printer\FW\src\Project\EWARMv5\..\..\FatFs\" -I   #
#                    "E:\BT Printer\FW\src\Project\EWARMv5\..\..\Lib\inc\"    #
#                    -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS\uC-C #
#                    PU\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS #
#                    \uC-LIB\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\.. #
#                    \uCOS\uCOS-II\Ports\" -I "E:\BT                          #
#                    Printer\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Source #
#                    \" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS\u #
#                    C-Probe\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\.. #
#                    \usb_lib\" -I "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 5.4\arm\INC\" -Ol                              #
#    List file    =  E:\BT Printer\FW\src\Project\EWARMv5\Debug\List\basic_fu #
#                    n.lst                                                    #
#    Object file  =  E:\BT Printer\FW\src\Project\EWARMv5\Debug\Obj\basic_fun #
#                    .o                                                       #
#                                                                             #
#                                                                             #
###############################################################################

E:\BT Printer\FW\src\App\basic_fun.c
      1          #include "basic_fun.h"
      2          #include "string.h"
      3          #include "usb_app_config.h"
      4          
      5          #if(USB_DEVICE_CONFIG &_USE_USB_KEYBOARD_DEVICE)
      6          extern  unsigned int	keyboard_output_report_value;
      7          typedef struct {
      8          	unsigned char	speical_key;
      9          	unsigned char	keyvalue;
     10          	unsigned char	asciivalue;
     11          	unsigned char   rfu;
     12          } TUSBKeyValue_Ascii;
     13          
     14          /**
     15          *	@brief USB键值与ascii码对应表
     16          */
     17          const TUSBKeyValue_Ascii UsbKeyValue_Ascii_Tbl[] = 
     18          {
     19          	{0,40,'\x0d',0},
     20          	{0,4,'a',0},{2,4,'A',0},{0,5,'b',0},{2,5,'B',0},{0,6,'c',0},{2,6,'C',0},{0,7,'d',0},{2,7,'D',0},{0,8,'e',0},{2,8,'E',0},
     21          	{0,9,'f',0},{2,9,'F',0},{0,10,'g',0},{2,10,'G',0},{0,11,'h',0},{2,11,'H',0},{0,12,'i',0},{2,12,'I',0},{0,13,'j',0},{2,13,'J',0},
     22          	{0,14,'k',0},{2,14,'K',0},{0,15,'l',0},{2,15,'L',0},{0,16,'m',0},{2,16,'M',0},{0,17,'n',0},{2,17,'N',0},{0,18,'o',0},{2,18,'O',0},
     23          	{0,19,'p',0},{2,19,'P',0},{0,20,'q',0},{2,20,'Q',0},{0,21,'r',0},{2,21,'R',0},{0,22,'s',0},{2,22,'S',0},{0,23,'t',0},{2,23,'T',0},
     24          	{0,24,'u',0},{2,24,'U',0},{0,25,'v',0},{2,25,'V',0},{0,26,'w',0},{2,26,'W',0},{0,27,'x',0},{2,27,'X',0},{0,28,'y',0},{2,28,'Y',0},
     25          	{0,29,'z',0},{2,29,'Z',0},{0,30,'1',0},{2,30,'!',0},{0,31,'2',0},{2,31,'@',0},{0,32,'3',0},{2,32,'#',0},{0,33,'4',0},{2,33,'$',0},
     26          	{0,34,'5',0},{2,34,'%',0},{0,35,'6',0},{2,35,'^',0},{0,36,'7',0},{2,36,'&',0},{0,37,'8',0},{2,37,'*',0},{0,38,'9',0},{2,38,'(',0},
     27          	{0,39,'0',0},{2,39,')',0},{0,44,' ',0},{0,45,'-',0},{2,45,'_',0},{0,46,'=',0},{2,46,'+',0},{0,47,'[',0},{2,47,'{',0},{0,48,']',0},
     28          	{2,48,'}',0},{0,49,'\\',0},{2,49,'|',0},{0,51,';',0},{2,51,':',0},{0,52,'\'',0},{2,52,'"',0},{0,53,'`',0},{2,53,'~',0},{0,54,',',0},
     29          	{2,54,'<',0},{0,55,'.',0},{2,55,'>',0},{0,56,'/',0},{2,56,'?',0}
     30          };
     31          #endif
     32          
     33          /**
     34          * @brief 将整型转成ascii
     35          * @param[in] unsigned int int_value: 被转换的整数
     36          * @param[out] unsigned char *pValue; 转换成的ascii字符串
     37          * @param[out] unsigned int *plen: 整数对应的ascii字符串的有效长度
     38          */
     39          void itoascii(unsigned int int_value, unsigned char *pValue, unsigned int *plen)
     40          {
     41          	unsigned int			i;
     42          	unsigned int			temp_value = int_value;
     43          
     44          	if (int_value == 0)
     45          	{
     46          		pValue[0] = '0';
     47          		*plen = 1;
     48          		return;
     49          	}
     50          	i = 0;
     51          	while (int_value)
     52          	{
     53          		i++;
     54          		int_value				/= 10;
     55          	}
     56          	*plen	= i;
     57          
     58          	while(i)
     59          	{
     60          		i--;
     61          		pValue[i]			= temp_value % 10 + '0';
     62          		temp_value			/= 10;
     63          	}
     64          }
     65          
     66          /**
     67          * @brief 将整型转成 规定长度的 ascii, 如59转换成3字节的Ascii，就是"059"
     68          * @param[in] unsigned int int_value: 被转换的整数
     69          * @param[in] unsigned char type: 0 十进制; 1: 十六进制
     70          * @param[out] unsigned char *pValue; 转换成的ascii字符串
     71          * @param[out] unsigned int *plen: 整数对应的ascii字符串的有效长度
     72          */
     73          #if 0
     74          void int_to_ascii(unsigned int int_value, unsigned char *pValue, unsigned int len, unsigned char type)
     75          {
     76          	unsigned int			i,j;
     77          	unsigned int			temp_value = int_value;
     78          
     79          	i = 0;
     80          	while (int_value)
     81          	{
     82          		i++;
     83          		if (type == 0)
     84          		{
     85          			int_value				/= 10;
     86          		}
     87          		else
     88          		{
     89          			int_value				/= 16;
     90          		}
     91          		
     92          	}
     93          	
     94          	j = 0;
     95          	if (i < len)	//前面补0
     96          	{
     97          		for (j = 0; j < len-i; j++)
     98          		{
     99          			pValue[j] = '0';
    100          		}
    101          	}
    102          
    103          	while(len > j)
    104          	{
    105          		len--;
    106          		if (type == 0)
    107          		{
    108          			pValue[len]			= temp_value % 10 + '0';
    109          			temp_value			/= 10;
    110          		}
    111          		else
    112          		{
    113          			pValue[len]			= temp_value % 16;
    114          			if (pValue[len] < 0x0A)
    115          			{
    116          				pValue[len]		+= '0';
    117          			}
    118          			else
    119          			{
    120          				pValue[len]		= pValue[len] - 0x0A + 'A';
    121          			}
    122          			temp_value			/= 16;
    123          		}
    124          	}
    125          }
    126          #endif
    127          
    128          
    129          /**
    130          * @brief 将16进制数值转换为字符串
    131          * @param[in]	DWORD	hex_val			需要转换的DWROD值
    132          * @param[in]	BYTE	type			进制		eg:  10:10进制   0x10:16进制
    133          * @param[in]	BYTE	outlen			需要转换的字符串长度	如果指定的长度超过了转换出来之后的长度，那么前面补‘0’，如果指定的长度小于转换之后的长度，那么按实际长度输出	
    134          * @param[out]	BYTE *outstr			转换结果存放的地址
    135          * @return BYTE	转换之后的长度
    136          * @note 
    137          */
    138          unsigned char hex_to_str(unsigned int hex_val, unsigned char type, unsigned char outlen, unsigned char *outstr)
    139          {
    140          	unsigned char	offset;
    141          	unsigned char	i, j;
    142          	unsigned int	q;			//因子
    143          
    144          	if (0 == hex_val)
    145          	{
    146          		outstr[0] = '0';
    147          		outstr[1] = 0;
    148          		return 1;
    149          	}
    150          
    151          	offset = 0;
    152          	while(hex_val > 0)
    153          	{
    154          		q = hex_val%type;
    155          		hex_val /= type;
    156          		outstr[offset++] = HexToAscii(q);
    157          	}
    158          
    159          	while(offset < outlen)
    160          	{
    161          		outstr[offset++] = 0x30;
    162          	}
    163          	outstr[offset] = 0;
    164          
    165          
    166          	i = 0;
    167          	j = offset-1;
    168          	while(i < j)
    169          	{
    170          		q = outstr[i];
    171          		outstr[i] = outstr[j];
    172          		outstr[j] = q;
    173          		i++;
    174          		j--;
    175          	}
    176          
    177          	return offset;
    178          }
    179          /**
    180          ***************************************************************************
    181          *@brief	int型数据转换成BCD码
    182          *@param[in] 
    183          *@return 
    184          *@warning
    185          *@see	
    186          *@note 
    187          ***************************************************************************
    188          */
    189          int HexToBCD(unsigned int indata,unsigned char *outdata,unsigned char out_len)
    190          {
    191          	unsigned char i;
    192          	unsigned char	tmp;
    193          	if (out_len > 5)		//因为int值最多也只能转换为5个字节的BCD码
    194          	{
    195          		return -1;
    196          	}
    197          	for (i = 0;i < out_len;i++)
    198          	{
    199          		tmp = indata%100;
    200          		outdata[out_len - 1 - i] = (tmp/10 << 4) + (tmp%10);
    201          		indata /= 100;
    202          	}
    203          	return 0;
    204          
    205          }
    206          
    207          /**
    208          ***********************************************************************
    209          * @brief 将输入的BCD码转换为十进制
    210          * @param[in] unsigned char *indata  要转换的输入值
    211          * @param[in] unsigned char len      要转换的输入值的长度
    212          * @param[in] unsigned char *outdata  转换的结果存放的地址
    213          * @return 0: 转换OK  -1:转换失败，输入的数据不是BCD码
    214          * @note 高位在前,输入的数据不能太长，否则会造成int溢出
    215          ***********************************************************************
    216          */
    217          int BCDToHex(unsigned char* indata,unsigned char len,unsigned int *outdata)
    218          {
    219          	unsigned int hex;
    220          	unsigned char i;
    221          
    222          	if (len > 5)
    223          	{
    224          		//溢出
    225          		return -1;
    226          	}
    227          	hex = 0;
    228          	for (i = 0;i < len;)
    229          	{
    230          		if (((indata[i]&0xf0) >> 4) > 0x09)
    231          		{
    232          			return -1;		//不是BCD码表示的数据
    233          		}
    234          
    235          		if ((indata[i]&0x0f) > 0x09)
    236          		{
    237          			return -1;	//不是BCD码表示的数据
    238          		}
    239          
    240          		hex += ((indata[i]&0xf0) >> 4)*10 + (indata[i]&0x0f);
    241          
    242          		if (++i != len)
    243          		{
    244          			hex *= 100;
    245          		}
    246          	}
    247          	*outdata = hex;
    248          	return 0;
    249          }
    250          
    251          /**
    252          * @brief BCD数据域转换为字符串
    253          * @param[in]	unsigned char* bcd_field	需要处理的BCD数据域的指针
    254          * @param[in]	unsigned int len			此数据域的规定长度		
    255          * @param[out]	unsigned char *out			转换结果存放的地址
    256          * @return		转换后的字符串长度
    257          * @note 
    258          */
    259          unsigned int bcd_field_to_str(unsigned char *bcd_field,unsigned int len,unsigned char *out)
    260          {
    261          	unsigned int i,j = 0;
    262          	/*
    263          	for (i = 0; i < len; i++)
    264          	{
    265          	if (bcd_field[i] != 0)
    266          	{
    267          	break;
    268          	}
    269          	}
    270          	*/
    271          	i = 0;
    272          	for (;i < len;i++)
    273          	{
    274          		out[j++] = HexToAscii((bcd_field[i] & 0xf0) >> 4);
    275          		out[j++] = HexToAscii(bcd_field[i] & 0x0f);
    276          	}
    277          	out[j] = 0;		//字符串结束符
    278          	return j;
    279          }
    280          
    281          /**
    282          * @brief 将字符串转换为前补0的BCD数据域
    283          * @param[in]	unsigned char* str			需要处理的字符串的指针
    284          * @param[in]	unsigned int len			此BCD field的规定长度		
    285          * @param[out]	unsigned char *bcd_field	转换结果存放的BCD field
    286          * @return		
    287          * @note 
    288          */
    289          void str_to_bcd_field(unsigned char *str,unsigned char *bcd_field,unsigned int len)
    290          {
    291          	unsigned int	i,j = 0;
    292          	unsigned int	str_len;
    293          
    294          	str_len = STRLEN((char const*)str);
    295          	if (str_len < len*2)
    296          	{
    297          		i = len - ((str_len+1)/2);
    298          		MEMSET(bcd_field,0,i);
    299          		if (str_len%2 != 0 )
    300          		{
    301          			//奇数长度
    302          			bcd_field[i++] = Ascii_To_Hex(str[0]);
    303          			j = 1;
    304          		}
    305          		for (;j < str_len;j += 2)
    306          		{
    307          			bcd_field[i++] = (Ascii_To_Hex(str[j]) << 4) + Ascii_To_Hex(str[j + 1]);
    308          		}
    309          	}
    310          	else
    311          	{
    312          		for (i=0;i<len;i++)
    313          		{
    314          			bcd_field[i] = (Ascii_To_Hex(str[2*i]) << 4) + Ascii_To_Hex(str[2*i + 1]);
    315          		}
    316          	}
    317          
    318          	return ;
    319          }
    320          
    321          /**
    322          * @brief 将输入的Hex值转换为其ASCII值
    323          * @param[in] BYTE hex  要转换的输入值
    324          * @return ASCII
    325          * @note 只对0，1，...，F 这16个Hex值进行转换,其中a,b,c,d,e,f这几个值转换为其大写字母的ASCII值
    326          */
    327          unsigned char HexToAscii(unsigned char hex)
    328          {
    329          	if(hex<0x0a)
    330          		return (0x30+hex);
    331          	else
    332          		return (0x37+hex);
    333          }
    334          
    335          /**
    336          * @brief 将由ASCII码表示的数据转换为其对应的Hex值
    337          * @author joe
    338          * @param[in] BYTE  asciiValue
    339          * @return 转换的Hex值
    340          * @note 
    341          */
    342          unsigned char Ascii_To_Hex(unsigned char  asciiValue)
    343          {
    344          	if((asciiValue>=0x30)&&(asciiValue<=0x39))
    345          	{
    346          		return (asciiValue-0x30);
    347          	}
    348          	else if((asciiValue>=0x41)&&(asciiValue<=0x46))
    349          	{
    350          		return (asciiValue-0x37);
    351          	}
    352          	else if((asciiValue>=0x61)&&(asciiValue<=0x66))
    353          	{
    354          		return (asciiValue-0x57);
    355          	}
    356          	return asciiValue;
    357          }
    358          
    359          /**
    360          * @brief 将Ascii转换成int
    361          * @note: 没有做溢出处理
    362          */
    363          int ascii_to_int(unsigned char *pValue)
    364          {
    365          	int						i;
    366          	int						value = 0;
    367          
    368          	for(i=0; ;i++)
    369          	{
    370          		if( *pValue == 0x00 )
    371          			return value;
    372          		value				*= 10;
    373          		value				+= (*pValue) - '0';
    374          		pValue ++;
    375          	}
    376          	///return value;
    377          }
    378          
    379          /**
    380           * @brief 二分查找算法
    381           * @return -1:没找到； 其他: 数组下标
    382           */
    383          #if 0
    384          int binary_search(unsigned short *search_list, unsigned int len, unsigned short key)
    385          {
    386          	unsigned int low = 0, high = len-1, mid = 0;
    387          
    388          	if (search_list[low] == key)
    389          	{
    390          		return 0;
    391          	}
    392          
    393          	while (low <= high)
    394          	{
    395          		mid = low + (high-low)/2; //使用(low+high)/2会有整数溢出的情况
    396          		if (search_list[mid] == key)
    397          		{
    398          			return mid;
    399          		}
    400          		else if (search_list[mid] > key)
    401          		{
    402          			high = mid -1;
    403          		}
    404          		else
    405          		{
    406          			low = mid + 1;
    407          		}
    408          	}
    409          
    410          	return -1;
    411          }
    412          
    413          /*
    414           *@brief: 将ascii转化为HID 按键编码
    415           *@note: ascii 0-9 -> 0x30-0x39; A-Z -> 0x41-0x5a; a-z -> 0x61->0x7a
    416           *		 keyboard code 1-9 -> 0x1E-0x26 0->0x27; a(A)->z(Z) 0x04-0x1D 
    417           */
    418          
    419          void ascii_to_keycode(unsigned char *pAscii, unsigned char *pKeycode, unsigned int len)
    420          {
    421          	int i = 0;
    422          	unsigned char cur_value;
    423          
    424          	for (i = 0; i < len; i++)
    425          	{
    426          		cur_value	= pAscii[i];
    427          		if (cur_value == '0')
    428          		{
    429          			pKeycode[i] = 0x27;
    430          		}
    431          		else if ('0' < cur_value && cur_value <= '9')
    432          		{
    433          			pKeycode[i] = cur_value - 19;
    434          		}
    435          		else if ('A' <= cur_value && cur_value <= 'Z')
    436          		{
    437          			pKeycode[i] = cur_value - 61;
    438          		}
    439          		else if ('a' <= cur_value && cur_value <= 'z')
    440          		{
    441          			pKeycode[i] = cur_value - 93;
    442          		}
    443          		else if (cur_value == ' ' || cur_value == ':')
    444          		{
    445          			pKeycode[i] = 0x2C;
    446          		}
    447          		else
    448          		{
    449          			pKeycode[i] = 0;
    450          		}
    451          	}
    452          }
    453          #endif
    454          
    455          #if(USB_DEVICE_CONFIG &_USE_USB_KEYBOARD_DEVICE)
    456          /*
    457          *@brief: 将ascii字符转换为符合键盘输入报表描述符的数据格式的键值 
    458          */
    459          void ascii_to_keyreport(unsigned char ascii, unsigned char*report)
    460          {
    461          	int i;
    462          
    463          	report[0] = 0x00;
    464          	report[1] = 0x00;
    465          	report[2] = 0x00;
    466          
    467          	for(i = 0; i < sizeof(UsbKeyValue_Ascii_Tbl)/sizeof(TUSBKeyValue_Ascii); i++)
    468          	{
    469          		if (((ascii >= 'a')&&(ascii <= 'z'))||((ascii >= 'A')&&(ascii <= 'Z')))
    470          		{
    471          			if (ascii == UsbKeyValue_Ascii_Tbl[i].asciivalue)
    472          			{
    473          				if(keyboard_output_report_value & 0x02)
    474          				{
    475          					//表示系统当前已经按下了CapsLcok键，所以发送小写字母时反而需要按住shift
    476          					report[0] = ((UsbKeyValue_Ascii_Tbl[i].speical_key == 0)?0x02:0x00);
    477          				}
    478          				else
    479          				{
    480          					report[0] = UsbKeyValue_Ascii_Tbl[i].speical_key;
    481          				}
    482          				report[2] = UsbKeyValue_Ascii_Tbl[i].keyvalue;
    483          				return;
    484          			}
    485          		}
    486          		else
    487          		{
    488          			if (ascii == UsbKeyValue_Ascii_Tbl[i].asciivalue)
    489          			{
    490          				report[0] = UsbKeyValue_Ascii_Tbl[i].speical_key;
    491          				report[2] = UsbKeyValue_Ascii_Tbl[i].keyvalue;
    492          				return;
    493          			}
    494          		}
    495          
    496          	}
    497          	return;
    498          }
    499          
    500          
    501          /*
    502          *@brief: 将ascii字符转换为符合键盘输入报表描述符的数据格式的键值
    503          *@note: ascii 0-9 -> 0x30-0x39; A-Z -> 0x41-0x5a; a-z -> 0x61->0x7a
    504          *		 keyboard code 1-9 -> 0x1E-0x26 0->0x27; a(A)->z(Z) 0x04-0x1D 
    505          */
    506          void ascii_to_keyreport2(unsigned char ascii,unsigned char*report)
    507          {
    508          	int i;
    509          
    510          	MEMSET(report,0,9);
    511          
    512          	for(i = 0; i < sizeof(UsbKeyValue_Ascii_Tbl)/sizeof(TUSBKeyValue_Ascii); i++)
    513          	{
    514          		if (ascii == UsbKeyValue_Ascii_Tbl[i].asciivalue)
    515          		{
    516          			report[1] = UsbKeyValue_Ascii_Tbl[i].speical_key;
    517          			report[3] = UsbKeyValue_Ascii_Tbl[i].keyvalue;
    518          			return;
    519          		}
    520          	}
    521          	return;
    522          }
    523          
    524          /*
    525          *@brief: 将ascii字符转换为符合键盘输入报表描述符的数据格式的键值,同时发送多个键值
    526          *@note: ascii 0-9 -> 0x30-0x39; A-Z -> 0x41-0x5a; a-z -> 0x61->0x7a
    527          *		 keyboard code 1-9 -> 0x1E-0x26 0->0x27; a(A)->z(Z) 0x04-0x1D 
    528          *     同时发送多个键值时只能保证所有的键值要么都需要按抓shift键发送要么都不需要按住shift键发送
    529          *     所以如果一次需要构造多个键值时,此函数碰到需要切换shift键时将会返回实际此报表中发送的键值数
    530          *	  最多一次可以发送6个键值
    531          */
    532          unsigned char ascii_to_keyreport2_ext(unsigned char *ascii,unsigned char len,unsigned char*report)
    533          {
    534          	int i,j;
    535          	unsigned char special_key;
    536          	unsigned char last_ascii = 0;
    537          
    538          	MEMSET(report,0,9);
    539          
    540          	//if(len > 6) len = 6;		//一次传6个键值，发现手机操作系统会丢键值
    541          	if(len > 1) len = 1;
    542          
    543          
    544          	for(j = 0;j < len;j++)
    545          	{
    546          		if (last_ascii == ascii[j])
    547          		{
    548          			return j;
    549          		}
    550          
    551          		last_ascii = ascii[j];
    552          		for(i = 0; i < sizeof(UsbKeyValue_Ascii_Tbl)/sizeof(TUSBKeyValue_Ascii); i++)
    553          		{
    554          			if (ascii[j] == UsbKeyValue_Ascii_Tbl[i].asciivalue)
    555          			{
    556          				if(j == 0)
    557          				{
    558          					special_key = UsbKeyValue_Ascii_Tbl[i].speical_key;
    559          					report[0] = special_key;
    560          				}
    561          				else
    562          				{
    563          					if(UsbKeyValue_Ascii_Tbl[i].speical_key != special_key)
    564          					{
    565          						return j;
    566          					}
    567          				}
    568          				report[2+j] = UsbKeyValue_Ascii_Tbl[i].keyvalue;
    569          				break;
    570          			}
    571          		}
    572          	}
    573          
    574          	return j;
    575          }
    576          #endif
    577          
    578          /*
    579          *@brief: 构造时间显示字符串
    580          *@note:  mode:1  构造成形如2010-03-05 11:12:30
    581          *		 mode:0  构造成形如2010/03/05 11:12:30
    582          */
    583          void build_time_dis_str(unsigned char *date_time_bcd,unsigned char *dis_str,unsigned char mode)
    584          {
    585          	unsigned char tmp[15];
    586          
    587          	bcd_field_to_str(date_time_bcd,7,tmp);
    588          	MEMCPY(dis_str,tmp,4);
    589          	if (mode)
    590          	{
    591          		dis_str[4] ='-';
    592          	}
    593          	else
    594          	{
    595          		dis_str[4] ='/';
    596          	}
    597          	MEMCPY(dis_str+5,tmp+4,2);
    598          	if (mode)
    599          	{
    600          		dis_str[7] ='-';
    601          	}
    602          	else
    603          	{
    604          		dis_str[7] ='/';
    605          	}
    606          	MEMCPY(dis_str+8,tmp+6,2);
    607          	dis_str[10]= ' ';
    608          	MEMCPY(dis_str+11,tmp+8,2);
    609          	dis_str[13] = ':';
    610          	MEMCPY(dis_str+14,tmp+10,2);
    611          	dis_str[16] = ':';
    612          	MEMCPY(dis_str+17,tmp+12,2);
    613          	dis_str[19] = 0;
    614          }
    615          
    616          
    617          //判断最后一个字节是否是一个汉字的前半字节
    618          int if_last_char_valid(unsigned char *buf,unsigned int len)
    619          {
    620          	unsigned char *p = buf;
    621          	unsigned int	i = 0;
    622          
    623          	while (i < len)
    624          	{
    625          		if (*p < 0x80)
    626          		{
    627          			p++;
    628          			i++;
    629          		}
    630          		else
    631          		{
    632          			p+=2;
    633          			i +=2;
    634          		}
    635          	}
    636          
    637          	if (i == len)
    638          	{
    639          		return 0;	
    640          	}
    641          
    642          	return 1;		//最后一个字节是一个汉字的前半个字节
    643          }
    644          int	if_include_unicode_character(unsigned char *buf,unsigned int len)
    645          {
    646          	unsigned char *p = buf;
    647          	unsigned int	i = 0;
    648          
    649          	while (i < len)
    650          	{
    651          		if (*p > 0x80)
    652          		{
    653          			return 1;
    654          		}
    655                          i++;
    656          	}
    657          	return 0;
    658          }
    659          /*
    660          * @brief: 浮点数转换为字符串
    661          * @param[in] float d	
    662          * @param[in] char* str
    663          */
    664          char *F2S(float d, char* str)  
    665          {  
    666          	char str1[40];  
    667          	int i,j=0;  
    668          	int index=0;  
    669          	int dotPos = 0;  
    670          	unsigned long num;  
    671          	//  正负号   
    672          	if ( d < 0 )  
    673          	{  
    674          		str[index++] = '-';  
    675          		d = 0 - d;  
    676          	}  
    677          	//  判断小数点位置   
    678          	//  156.89      --> 0.15689      dotPos = 3   
    679          	//  1.5689      --> 0.15689      dotPos = 1   
    680          	//  0.0015689   --> 0.15689      dotPos = -2   
    681          	//  0.0000000015689 -->  0.15689 dotPos = -8   
    682          	//  0.0000000000015689  --> 0.015689 dotPos = -10   
    683          	for (i=0; i<10; i++)  
    684          	{  
    685          		if (d >= 1)  
    686          		{  
    687          			d = d / 10;  
    688          			dotPos += 1; 
    689          		}  
    690          		else if (d < 0.1)  
    691          		{  
    692          			d = d * 10;  
    693          			dotPos -= 1;  
    694          		}  
    695          		else  
    696          			break;  
    697          	}  
    698          
    699          	// 取七位有效数字，末位四舍五入   
    700          	//  0.15689  --> 1568900   
    701          	//  0.015689 --> 0156890   
    702          	for (i=0; i<9; i++)  
    703          		d *= 10;  
    704          	num = (unsigned long)(d + 0.5);  
    705          
    706          	while ( num>0 )  
    707          	{  
    708          		str1[j++] = num%10+'0';     // 0098651      098651   
    709          		num /= 10;  
    710          	}  
    711          
    712          	if (dotPos < 1)  
    713          	{  
    714          		str[index++] = '0';  
    715          		str[index++] = '.';  
    716          		for (i=0; i<0-dotPos; i++)  
    717          			str[index++] = '0';  
    718          		for (i=0; i<j; i++)  
    719          			str[index++] = str1[j-1-i];       
    720          	}  
    721          	else  
    722          	{  
    723          		for (i=0; i<dotPos; i++)  
    724          			str[index++] = str1[j-1-i];  
    725          		str[index++] = '.';  
    726          		for (; i<j; i++)  
    727          			str[index++] = str1[j-1-i];  
    728          	}     
    729          
    730          	// 清零       123.0000 --> 123.   
    731          	while ( str[--index]=='0' );  
    732          	index++;  
    733          	// 清除最后面的一个小数点 '.'      123. --> 123   
    734          	while ( str[--index]=='.' );  
    735          
    736          
    737          	str[++index] = '\0';  
    738          	return(str);  
    739          }  
    740          
    741          
    742          /**
    743           * This function will set the content of memory to specified value
    744           *
    745           * @param s the address of source memory
    746           * @param c the value shall be set in content
    747           * @param count the copied length
    748           *
    749           * @return the address of source memory
    750           */
    751          void *kt_memset(void *s, int c, unsigned int count)
    752          {
    753          #ifdef KT_TINY_SIZE
    754              char *xs = (char *)s;
    755          
    756              while (count--)
    757                  *xs++ = c;
    758          
    759              return s;
    760          #else
    761          #define LBLOCKSIZE      (sizeof(unsigned int))
    762          #define UNALIGNED(X)    ((unsigned int)X & (LBLOCKSIZE - 1))
    763          #define TOO_SMALL(LEN)  ((LEN) < LBLOCKSIZE)
    764          
    765              int i;
    766              char *m = (char *)s;
    767              unsigned int buffer;
    768              unsigned int *aligned_addr;
    769              unsigned int d = c & 0xff;
    770          
    771              if (!TOO_SMALL(count) && !UNALIGNED(s))
    772              {
    773                  /* If we get this far, we know that n is large and m is word-aligned. */
    774                  aligned_addr = (unsigned int *)s;
    775          
    776                  /* Store D into each char sized location in BUFFER so that
    777                   * we can set large blocks quickly.
    778                   */
    779                  if (LBLOCKSIZE == 4)
    780                  {
    781                      buffer = (d << 8) | d;
    782                      buffer |= (buffer << 16);
    783                  }
    784                  else
    785                  {
    786                      buffer = 0;
    787                      for (i = 0; i < LBLOCKSIZE; i ++)
    788                          buffer = (buffer << 8) | d;
    789                  }
    790          
    791                  while (count >= LBLOCKSIZE * 4)
    792                  {
    793                      *aligned_addr++ = buffer;
    794                      *aligned_addr++ = buffer;
    795                      *aligned_addr++ = buffer;
    796                      *aligned_addr++ = buffer;
    797                      count -= 4 * LBLOCKSIZE;
    798                  }
    799          
    800                  while (count >= LBLOCKSIZE)
    801                  {
    802                      *aligned_addr++ = buffer;
    803                      count -= LBLOCKSIZE;
    804                  }
    805          
    806                  /* Pick up the remainder with a bytewise loop. */
    807                  m = (char *)aligned_addr;
    808              }
    809          
    810              while (count--)
    811              {
    812                  *m++ = (char)d;
    813              }
    814          
    815              return s;
    816          
    817          #undef LBLOCKSIZE
    818          #undef UNALIGNED
    819          #undef TOO_SMALL
    820          #endif
    821          }
    822          
    823          /**
    824           * This function will copy memory content from source address to destination
    825           * address.
    826           *
    827           * @param dst the address of destination memory
    828           * @param src  the address of source memory
    829           * @param count the copied length
    830           *
    831           * @return the address of destination memory
    832           */
    833          void *kt_memcpy(void *dst, const void *src, unsigned int count)
    834          {
    835          #ifdef KT_TINY_SIZE
    836              char *tmp = (char *)dst, *s = (char *)src;
    837          
    838              while (count--)
    839                  *tmp++ = *s++;
    840          
    841              return dst;
    842          #else
    843          
    844          #define UNALIGNED(X, Y)                                               \
    845                                  (((unsigned int)X & (sizeof(unsigned int) - 1)) | \
    846                                   ((unsigned int)Y & (sizeof(unsigned int) - 1)))
    847          #define BIGBLOCKSIZE    (sizeof(unsigned int) << 2)
    848          #define LITTLEBLOCKSIZE (sizeof(unsigned int))
    849          #define TOO_SMALL(LEN)  ((LEN) < BIGBLOCKSIZE)
    850          
    851              char *dst_ptr = (char *)dst;
    852              char *src_ptr = (char *)src;
    853              unsigned int *aligned_dst;
    854              unsigned int *aligned_src;
    855              int len = count;
    856          
    857              /* If the size is small, or either SRC or DST is unaligned,
    858              then punt into the byte copy loop.  This should be rare. */
    859              if (!TOO_SMALL(len) && !UNALIGNED(src_ptr, dst_ptr))
    860              {
    861                  aligned_dst = (unsigned int *)dst_ptr;
    862                  aligned_src = (unsigned int *)src_ptr;
    863          
    864                  /* Copy 4X long words at a time if possible. */
    865                  while (len >= BIGBLOCKSIZE)
    866                  {
    867                      *aligned_dst++ = *aligned_src++;
    868                      *aligned_dst++ = *aligned_src++;
    869                      *aligned_dst++ = *aligned_src++;
    870                      *aligned_dst++ = *aligned_src++;
    871                      len -= BIGBLOCKSIZE;
    872                  }
    873          
    874                  /* Copy one long word at a time if possible. */
    875                  while (len >= LITTLEBLOCKSIZE)
    876                  {
    877                      *aligned_dst++ = *aligned_src++;
    878                      len -= LITTLEBLOCKSIZE;
    879                  }
    880          
    881                  /* Pick up any residual with a byte copier. */
    882                  dst_ptr = (char *)aligned_dst;
    883                  src_ptr = (char *)aligned_src;
    884              }
    885          
    886              while (len--)
    887                  *dst_ptr++ = *src_ptr++;
    888          
    889              return dst;
    890          #undef UNALIGNED
    891          #undef BIGBLOCKSIZE
    892          #undef LITTLEBLOCKSIZE
    893          #undef TOO_SMALL
    894          #endif
    895          }
    896          
    897          /**
    898           * This function will move memory content from source address to destination
    899           * address.
    900           *
    901           * @param dest the address of destination memory
    902           * @param src  the address of source memory
    903           * @param n the copied length
    904           *
    905           * @return the address of destination memory
    906           */
    907          void *kt_memmove(void *dest, const void *src, unsigned int n)
    908          {
    909              char *tmp = (char *)dest, *s = (char *)src;
    910          
    911              if (s < tmp && tmp < s + n)
    912              {
    913                  tmp += n;
    914                  s += n;
    915          
    916                  while (n--)
    917                      *(--tmp) = *(--s);
    918              }
    919              else
    920              {
    921                  while (n--)
    922                      *tmp++ = *s++;
    923              }
    924          
    925              return dest;
    926          }
    927          
    928          /**
    929           * This function will compare two areas of memory
    930           *
    931           * @param cs one area of memory
    932           * @param ct znother area of memory
    933           * @param count the size of the area
    934           *
    935           * @return the result
    936           */
    937          unsigned int kt_memcmp(const void *cs, const void *ct, unsigned int count)
    938          {
    939              const unsigned char *su1, *su2;
    940              int res = 0;
    941          
    942              for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
    943                  if ((res = *su1 - *su2) != 0)
    944                      break;
    945          
    946              return res;
    947          }
    948          
    949          /**
    950           * This function will return the first occurrence of a string.
    951           *
    952           * @param s1 the source string
    953           * @param s2 the find string
    954           *
    955           * @return the first occurrence of a s2 in s1, or kt_NULL if no found.
    956           */
    957          char *kt_strstr(const char *s1, const char *s2)
    958          {
    959              int l1, l2;
    960          
    961              l2 = kt_strlen(s2);
    962              if (!l2)
    963                  return (char *)s1;
    964              l1 = kt_strlen(s1);
    965              while (l1 >= l2)
    966              {
    967                  l1 --;
    968                  if (!kt_memcmp(s1, s2, l2))
    969                      return (char *)s1;
    970                  s1 ++;
    971              }
    972          
    973              return NULL;
    974          }
    975          
    976          /**
    977           * This function will compare two strings while ignoring differences in case
    978           *
    979           * @param a the string to be compared
    980           * @param b the string to be compared
    981           *
    982           * @return the result
    983           */
    984          unsigned int kt_strcasecmp(const char *a, const char *b)
    985          {
    986              int ca, cb;
    987          
    988              do
    989              {
    990                  ca = *a++ & 0xff;
    991                  cb = *b++ & 0xff;
    992                  if (ca >= 'A' && ca <= 'Z')
    993                      ca += 'a' - 'A';
    994                  if (cb >= 'A' && cb <= 'Z')
    995                      cb += 'a' - 'A';
    996              }
    997              while (ca == cb && ca != '\0');
    998          
    999              return ca - cb;
   1000          }
   1001          
   1002          /**
   1003           * This function will copy string no more than n bytes.
   1004           *
   1005           * @param dst the string to copy
   1006           * @param src the string to be copied
   1007           * @param n the maximum copied length
   1008           *
   1009           * @return the result
   1010           */
   1011          char *kt_strncpy(char *dst, const char *src, unsigned int n)
   1012          {
   1013              if (n != 0)
   1014              {
   1015                  char *d = dst;
   1016                  const char *s = src;
   1017          
   1018                  do
   1019                  {
   1020                      if ((*d++ = *s++) == 0)
   1021                      {
   1022                          /* NUL pad the remaining n-1 bytes */
   1023                          while (--n != 0)
   1024                              *d++ = 0;
   1025                          break;
   1026                      }
   1027                  } while (--n != 0);
   1028              }
   1029          
   1030              return (dst);
   1031          }
   1032          
   1033          /**
   1034           * This function will compare two strings with specified maximum length
   1035           *
   1036           * @param cs the string to be compared
   1037           * @param ct the string to be compared
   1038           * @param count the maximum compare length
   1039           *
   1040           * @return the result
   1041           */
   1042          unsigned int kt_strncmp(const char *cs, const char *ct, unsigned int count)
   1043          {
   1044              register signed char __res = 0;
   1045          
   1046              while (count)
   1047              {
   1048                  if ((__res = *cs - *ct++) != 0 || !*cs++)
   1049                      break;
   1050                  count --;
   1051              }
   1052          
   1053              return __res;
   1054          }
   1055          
   1056          /**
   1057           * This function will compare two strings without specified length
   1058           *
   1059           * @param cs the string to be compared
   1060           * @param ct the string to be compared
   1061           *
   1062           * @return the result
   1063           */
   1064          unsigned int kt_strcmp(const char *cs, const char *ct)
   1065          {
   1066              while (*cs && *cs == *ct)
   1067                  cs++, ct++;
   1068          
   1069              return (*cs - *ct);
   1070          }
   1071          
   1072          /**
   1073           * This function will return the length of a string, which terminate will
   1074           * null character.
   1075           *
   1076           * @param s the string
   1077           *
   1078           * @return the length of string
   1079           */
   1080          unsigned int kt_strlen(const char *s)
   1081          {
   1082              const char *sc;
   1083          
   1084              for (sc = s; *sc != '\0'; ++sc) /* nothing */
   1085                  ;
   1086          
   1087              return sc - s;
   1088          }

   Maximum stack usage in bytes:

     Function                     .cstack
     --------                     -------
     Ascii_To_Hex                      0
     BCDToHex                         16
     F2S                              64
     HexToAscii                        0
     HexToBCD                         16
     ascii_to_int                      0
     bcd_field_to_str                 24
     build_time_dis_str               32
     hex_to_str                       24
     if_include_unicode_character      0
     if_last_char_valid                0
     itoascii                          8
     kt_memcmp                         8
     kt_memcpy                         8
     kt_memmove                        8
     kt_memset                         8
     kt_strcasecmp                     0
     kt_strcmp                         0
     kt_strlen                         0
     kt_strncmp                        8
     kt_strncpy                        8
     kt_strstr                        24
     str_to_bcd_field                 32


   Section sizes:

     Function/Label               Bytes
     --------------               -----
     itoascii                       68
     hex_to_str                    152
     HexToBCD                       88
     BCDToHex                      118
     bcd_field_to_str               70
     str_to_bcd_field              144
     HexToAscii                     18
     Ascii_To_Hex                   58
     ascii_to_int                   32
     build_time_dis_str            140
     if_last_char_valid             36
     if_include_unicode_character   24
     F2S                           324
     kt_memset                      22
     kt_memcpy                      26
     kt_memmove                     60
     kt_memcmp                      34
     kt_strstr                      62
     kt_strcasecmp                  40
     kt_strncpy                     48
     kt_strncmp                     52
     kt_strcmp                      28
     kt_strlen                      16

 
 1 660 bytes in section .text
 
 1 660 bytes of CODE memory

Errors: none
Warnings: 1
