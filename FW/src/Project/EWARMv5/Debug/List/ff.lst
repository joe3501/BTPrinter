###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     17/Nov/2015  15:49:39 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\BT Printer\FW\src\FatFs\ff.c                          #
#    Command line =  "E:\BT Printer\FW\src\FatFs\ff.c" -D DEBUG_VER -lcN      #
#                    "E:\BT Printer\FW\src\Project\EWARMv5\Debug\List\" -o    #
#                    "E:\BT Printer\FW\src\Project\EWARMv5\Debug\Obj\"        #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 5.4\arm\INC\DLib_Config_Full.h" -I "E:\BT      #
#                    Printer\FW\src\Project\EWARMv5\..\" -I "E:\BT            #
#                    Printer\FW\src\Project\EWARMv5\..\..\App\" -I "E:\BT     #
#                    Printer\FW\src\Project\EWARMv5\..\..\Drivers\" -I        #
#                    "E:\BT Printer\FW\src\Project\EWARMv5\..\..\FatFs\" -I   #
#                    "E:\BT Printer\FW\src\Project\EWARMv5\..\..\Lib\inc\"    #
#                    -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS\uC-C #
#                    PU\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS #
#                    \uC-LIB\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\.. #
#                    \uCOS\uCOS-II\Ports\" -I "E:\BT                          #
#                    Printer\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Source #
#                    \" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS\u #
#                    C-Probe\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\.. #
#                    \usb_lib\" -I "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 5.4\arm\INC\" -Ol                              #
#    List file    =  E:\BT Printer\FW\src\Project\EWARMv5\Debug\List\ff.lst   #
#    Object file  =  E:\BT Printer\FW\src\Project\EWARMv5\Debug\Obj\ff.o      #
#                                                                             #
#                                                                             #
###############################################################################

E:\BT Printer\FW\src\FatFs\ff.c
      1          /*----------------------------------------------------------------------------/
      2          /  FatFs - FAT file system module  R0.07e                    (C)ChaN, 2009
      3          /-----------------------------------------------------------------------------/
      4          / FatFs module is a generic FAT file system module for small embedded systems.
      5          / This is a free software that opened for education, research and commercial
      6          / developments under license policy of following trems.
      7          /
      8          /  Copyright (C) 2009, ChaN, all right reserved.
      9          /
     10          / * The FatFs module is a free software and there is NO WARRANTY.
     11          / * No restriction on use. You can use, modify and redistribute it for
     12          /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
     13          / * Redistributions of source code must retain the above copyright notice.
     14          /
     15          /-----------------------------------------------------------------------------/
     16          / Feb 26,'06 R0.00  Prototype.
     17          /
     18          / Apr 29,'06 R0.01  First stable version.
     19          /
     20          / Jun 01,'06 R0.02  Added FAT12 support.
     21          /                   Removed unbuffered mode.
     22          /                   Fixed a problem on small (<32M) patition.
     23          / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
     24          /
     25          / Sep 22,'06 R0.03  Added f_rename().
     26          /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
     27          / Dec 11,'06 R0.03a Improved cluster scan algolithm to write files fast.
     28          /                   Fixed f_mkdir() creates incorrect directory on FAT32.
     29          /
     30          / Feb 04,'07 R0.04  Supported multiple drive system.
     31          /                   Changed some interfaces for multiple drive system.
     32          /                   Changed f_mountdrv() to f_mount().
     33          /                   Added f_mkfs().
     34          / Apr 01,'07 R0.04a Supported multiple partitions on a plysical drive.
     35          /                   Added a capability of extending file size to f_lseek().
     36          /                   Added minimization level 3.
     37          /                   Fixed an endian sensitive code in f_mkfs().
     38          / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
     39          /                   Added FSInfo support.
     40          /                   Fixed DBCS name can result FR_INVALID_NAME.
     41          /                   Fixed short seek (<= csize) collapses the file object.
     42          /
     43          / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
     44          /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
     45          /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
     46          / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
     47          /                   Fixed off by one error at FAT sub-type determination.
     48          /                   Fixed btr in f_read() can be mistruncated.
     49          /                   Fixed cached sector is not flushed when create and close
     50          /                   without write.
     51          /
     52          / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
     53          /                   Improved performance of f_lseek() on moving to the same
     54          /                   or following cluster.
     55          /
     56          / Apr 01,'09 R0.07  Merged Tiny-FatFs as a buffer configuration option.
     57          /                   Added long file name support.
     58          /                   Added multiple code page support.
     59          /                   Added re-entrancy for multitask operation.
     60          /                   Added auto cluster size selection to f_mkfs().
     61          /                   Added rewind option to f_readdir().
     62          /                   Changed result code of critical errors.
     63          /                   Renamed string functions to avoid name collision.
     64          / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
     65          /                   Added multiple sector size support.
     66          / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
     67          /                   Fixed wrong cache control in f_lseek().
     68          /                   Added relative path feature.
     69          /                   Added f_chdir() and f_chdrive().
     70          /                   Added proper case conversion to extended char.
     71          / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
     72          /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
     73          /                   Fixed name matching error on the 13 char boundary.
     74          /                   Added a configuration option, _LFN_UNICODE.
     75          /                   Changed f_readdir() to return the SFN with always upper
     76          /                   case on non-LFN cfg.
     77          /---------------------------------------------------------------------------*/
     78          
     79          #include "ff.h"			/* FatFs configurations and declarations */
     80          #include "diskio.h"		/* Declarations of low level disk I/O functions */
     81          
     82          #define FALSE	0
     83          #define TRUE 1
     84          /*--------------------------------------------------------------------------
     85          
     86             Module Private Definitions
     87          
     88          ---------------------------------------------------------------------------*/
     89          
     90          #if _FATFS != 0x007E
     91          #error Wrong include file (ff.h).
     92          #endif
     93          
     94          #if _FS_REENTRANT
     95          #if _USE_LFN == 1
     96          #error Static LFN work area must not be used in re-entrant configuration.
     97          #endif
     98          #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
     99          #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
    100          
    101          #else
    102          #define	ENTER_FF(fs)
    103          #define LEAVE_FF(fs, res)	return res
    104          
    105          #endif
    106          
    107          #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
    108          
    109          #ifndef NULL
    110          #define	NULL	0
    111          #endif
    112          
    113          /* Name status flags */
    114          #define NS			11		/* Offset of name status byte */
    115          #define NS_LOSS		0x01	/* Out of 8.3 format */
    116          #define NS_LFN		0x02	/* Force to create LFN entry */
    117          #define NS_LAST		0x04	/* Last segment */
    118          #define NS_BODY		0x08	/* Lower case flag (body) */
    119          #define NS_EXT		0x10	/* Lower case flag (ext) */
    120          #define NS_DOT		0x20	/* Dot entry */
    121          
    122          
    123          
    124          
    125          /*--------------------------------------------------------------------------
    126          
    127             Private Work Area
    128          
    129          ---------------------------------------------------------------------------*/
    130          
    131          #if _DRIVES < 1 || _DRIVES > 9
    132          #error Number of drives must be 1-9.
    133          #endif
    134          static
    135          FATFS *FatFs[_DRIVES];	/* Pointer to the file system objects (logical drives) */
    136          
    137          static
    138          WORD Fsid;				/* File system mount ID */
    139          
    140          #if _FS_RPATH
    141          static
    142          BYTE Drive;				/* Current drive */
    143          #endif
    144          
    145          
    146          #if _USE_LFN == 1	/* LFN with static LFN working buffer */
    147          static
    148          WCHAR LfnBuf[_MAX_LFN + 1];
    149          #define	NAMEBUF(sp,lp)	BYTE sp[12]; WCHAR *lp = LfnBuf
    150          #define INITBUF(dj,sp,lp)	dj.fn = sp; dj.lfn = lp
    151          
    152          #elif _USE_LFN > 1	/* LFN with dynamic LFN working buffer */
    153          #define	NAMEBUF(sp,lp)	BYTE sp[12]; WCHAR lbuf[_MAX_LFN + 1], *lp = lbuf
    154          #define INITBUF(dj,sp,lp)	dj.fn = sp; dj.lfn = lp
    155          
    156          #else				/* No LFN */
    157          #define	NAMEBUF(sp,lp)	BYTE sp[12]
    158          #define INITBUF(dj,sp,lp)	dj.fn = sp
    159          
    160          #endif
    161          
    162          
    163          
    164          
    165          /*--------------------------------------------------------------------------
    166          
    167             Module Private Functions
    168          
    169          ---------------------------------------------------------------------------*/
    170          
    171          
    172          /*-----------------------------------------------------------------------*/
    173          /* String functions                                                      */
    174          /*-----------------------------------------------------------------------*/
    175          
    176          /* Copy memory to memory */
    177          static
    178          void mem_cpy (void* dst, const void* src, int cnt) {
    179          	char *d = (char*)dst;
    180          	const char *s = (const char *)src;
    181          	while (cnt--) *d++ = *s++;
    182          }
    183          
    184          /* Fill memory */
    185          static
    186          void mem_set (void* dst, int val, int cnt) {
    187          	char *d = (char*)dst;
    188          	while (cnt--) *d++ = (char)val;
    189          }
    190          
    191          /* Compare memory to memory */
    192          static
    193          int mem_cmp (const void* dst, const void* src, int cnt) {
    194          	const char *d = (const char *)dst, *s = (const char *)src;
    195          	int r = 0;
    196          	while (cnt-- && (r = *d++ - *s++) == 0) ;
    197          	return r;
    198          }
    199          
    200          /* Check if chr is contained in the string */
    201          static
    202          int chk_chr (const char* str, int chr) {
    203          	while (*str && *str != chr) str++;
    204          	return *str;
    205          }
    206          
    207          
    208          
    209          /*-----------------------------------------------------------------------*/
    210          /* Request/Release grant to access the volume                            */
    211          /*-----------------------------------------------------------------------*/
    212          #if _FS_REENTRANT
    213          
    214          static
    215          BOOL lock_fs (
    216          	FATFS *fs		/* File system object */
    217          )
    218          {
    219          	return ff_req_grant(fs->sobj);
    220          }
    221          
    222          
    223          static
    224          void unlock_fs (
    225          	FATFS *fs,		/* File system object */
    226          	FRESULT res		/* Result code to be returned */
    227          )
    228          {
    229          	if (res != FR_NOT_ENABLED &&
    230          		res != FR_INVALID_DRIVE &&
    231          		res != FR_INVALID_OBJECT &&
    232          		res != FR_TIMEOUT) {
    233          		ff_rel_grant(fs->sobj);
    234          	}
    235          }
    236          #endif
    237          
    238          
    239          
    240          /*-----------------------------------------------------------------------*/
    241          /* Change window offset                                                  */
    242          /*-----------------------------------------------------------------------*/
    243          
    244          static
    245          FRESULT move_window (
    246          	FATFS *fs,		/* File system object */
    247          	DWORD sector	/* Sector number to make apperance in the fs->win[] */
    248          )					/* Move to zero only writes back dirty window */
    249          {
    250          	DWORD wsect;
    251          
    252          
    253          	wsect = fs->winsect;
    254          	if (wsect != sector) {	/* Changed current window */
    255          #if !_FS_READONLY
    256          		if (fs->wflag) {	/* Write back dirty window if needed */
    257          			if (disk_write(fs->drive, fs->win, wsect, 1) != RES_OK)
    258          				return FR_DISK_ERR;
    259          			fs->wflag = 0;
    260          			if (wsect < (fs->fatbase + fs->sects_fat)) {	/* In FAT area */
    261          				BYTE nf;
    262          				for (nf = fs->n_fats; nf > 1; nf--) {	/* Refrect the change to all FAT copies */
    263          					wsect += fs->sects_fat;
    264          					disk_write(fs->drive, fs->win, wsect, 1);
    265          				}
    266          			}
    267          		}
    268          #endif
    269          		if (sector) {
    270          			if (disk_read(fs->drive, fs->win, sector, 1) != RES_OK)
    271          				return FR_DISK_ERR;
    272          			fs->winsect = sector;
    273          		}
    274          	}
    275          
    276          	return FR_OK;
    277          }
    278          
    279          
    280          
    281          
    282          /*-----------------------------------------------------------------------*/
    283          /* Clean-up cached data                                                  */
    284          /*-----------------------------------------------------------------------*/
    285          #if !_FS_READONLY
    286          static
    287          FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
    288          	FATFS *fs	/* File system object */
    289          )
    290          {
    291          	FRESULT res;
    292          
    293          
    294          	res = move_window(fs, 0);
    295          	if (res == FR_OK) {
    296          		/* Update FSInfo sector if needed */
    297          		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
    298          			fs->winsect = 0;
    299          			mem_set(fs->win, 0, 512);
    300          			ST_WORD(fs->win+BS_55AA, 0xAA55);
    301          			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
    302          			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
    303          			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
    304          			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
    305          			disk_write(fs->drive, fs->win, fs->fsi_sector, 1);
    306          			fs->fsi_flag = 0;
    307          		}
    308          		/* Make sure that no pending write process in the physical drive */
    309          		if (disk_ioctl(fs->drive, CTRL_SYNC, (void*)NULL) != RES_OK)
    310          			res = FR_DISK_ERR;
    311          	}
    312          
    313          	return res;
    314          }
    315          #endif
    316          
    317          
    318          
    319          
    320          /*-----------------------------------------------------------------------*/
    321          /* FAT access - Read value of a FAT entry                                */
    322          /*-----------------------------------------------------------------------*/
    323          
    324          
    325          DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Interal error, Else:Cluster status */
    326          	FATFS *fs,	/* File system object */
    327          	DWORD clst	/* Cluster# to get the link information */
    328          )
    329          {
    330          	UINT wc, bc;
    331          	DWORD fsect;
    332          
    333          
    334          	if (clst < 2 || clst >= fs->max_clust)	/* Range check */
    335          		return 1;
    336          
    337          	fsect = fs->fatbase;
    338          	switch (fs->fs_type) {
    339          	case FS_FAT12 :
    340          		bc = clst; bc += bc / 2;
    341          		if (move_window(fs, fsect + (bc / SS(fs)))) break;
    342          		wc = fs->win[bc & (SS(fs) - 1)]; bc++;
    343          		if (move_window(fs, fsect + (bc / SS(fs)))) break;
    344          		wc |= (WORD)fs->win[bc & (SS(fs) - 1)] << 8;
    345          		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    346          
    347          	case FS_FAT16 :
    348          		if (move_window(fs, fsect + (clst / (SS(fs) / 2)))) break;
    349          		return LD_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)]);
    350          
    351          	case FS_FAT32 :
    352          		if (move_window(fs, fsect + (clst / (SS(fs) / 4)))) break;
    353          		return LD_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)]) & 0x0FFFFFFF;
    354          	}
    355          
    356          	return 0xFFFFFFFF;	/* An error occured at the disk I/O layer */
    357          }
    358          
    359          
    360          
    361          
    362          /*-----------------------------------------------------------------------*/
    363          /* FAT access - Change value of a FAT entry                              */
    364          /*-----------------------------------------------------------------------*/
    365          #if !_FS_READONLY
    366          
    367          FRESULT put_fat (
    368          	FATFS *fs,	/* File system object */
    369          	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->max_clust - 1 */
    370          	DWORD val	/* New value to mark the cluster */
    371          )
    372          {
    373          	UINT bc;
    374          	BYTE *p;
    375          	DWORD fsect;
    376          	FRESULT res;
    377          
    378          
    379          	if (clst < 2 || clst >= fs->max_clust) {	/* Range check */
    380          		res = FR_INT_ERR;
    381          
    382          	} else {
    383          		fsect = fs->fatbase;
    384          		switch (fs->fs_type) {
    385          		case FS_FAT12 :
    386          			bc = clst; bc += bc / 2;
    387          			res = move_window(fs, fsect + (bc / SS(fs)));
    388          			if (res != FR_OK) break;
    389          			p = &fs->win[bc & (SS(fs) - 1)];
    390          			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    391          			bc++;
    392          			fs->wflag = 1;
    393          			res = move_window(fs, fsect + (bc / SS(fs)));
    394          			if (res != FR_OK) break;
    395          			p = &fs->win[bc & (SS(fs) - 1)];
    396          			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    397          			break;
    398          
    399          		case FS_FAT16 :
    400          			res = move_window(fs, fsect + (clst / (SS(fs) / 2)));
    401          			if (res != FR_OK) break;
    402          			ST_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)], (WORD)val);
    403          			break;
    404          
    405          		case FS_FAT32 :
    406          			res = move_window(fs, fsect + (clst / (SS(fs) / 4)));
    407          			if (res != FR_OK) break;
    408          			ST_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)], val);
    409          			break;
    410          
    411          		default :
    412          			res = FR_INT_ERR;
    413          		}
    414          		fs->wflag = 1;
    415          	}
    416          
    417          	return res;
    418          }
    419          #endif /* !_FS_READONLY */
    420          
    421          
    422          
    423          
    424          /*-----------------------------------------------------------------------*/
    425          /* FAT handling - Remove a cluster chain                                 */
    426          /*-----------------------------------------------------------------------*/
    427          #if !_FS_READONLY
    428          static
    429          FRESULT remove_chain (
    430          	FATFS *fs,			/* File system object */
    431          	DWORD clst			/* Cluster# to remove a chain from */
    432          )
    433          {
    434          	FRESULT res;
    435          	DWORD nxt;
    436          
    437          
    438          	if (clst < 2 || clst >= fs->max_clust) {	/* Check the range of cluster# */
    439          		res = FR_INT_ERR;
    440          
    441          	} else {
    442          		res = FR_OK;
    443          		while (clst < fs->max_clust) {			/* Not a last link? */
    444          			nxt = get_fat(fs, clst);			/* Get cluster status */
    445          			if (nxt == 0) break;				/* Empty cluster? */
    446          			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    447          			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    448          			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    449          			if (res != FR_OK) break;
    450          			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
    451          				fs->free_clust++;
    452          				fs->fsi_flag = 1;
    453          			}
    454          			clst = nxt;	/* Next cluster */
    455          		}
    456          	}
    457          
    458          	return res;
    459          }
    460          #endif
    461          
    462          
    463          
    464          
    465          /*-----------------------------------------------------------------------*/
    466          /* FAT handling - Stretch or Create a cluster chain                      */
    467          /*-----------------------------------------------------------------------*/
    468          #if !_FS_READONLY
    469          static
    470          DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
    471          	FATFS *fs,			/* File system object */
    472          	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
    473          )
    474          {
    475          	DWORD cs, ncl, scl, mcl;
    476          
    477          
    478          	mcl = fs->max_clust;
    479          	if (clst == 0) {		/* Create new chain */
    480          		scl = fs->last_clust;			/* Get suggested start point */
    481          		if (scl == 0 || scl >= mcl) scl = 1;
    482          	}
    483          	else {					/* Stretch existing chain */
    484          		cs = get_fat(fs, clst);			/* Check the cluster status */
    485          		if (cs < 2) return 1;			/* It is an invalid cluster */
    486          		if (cs < mcl) return cs;		/* It is already followed by next cluster */
    487          		scl = clst;
    488          	}
    489          
    490          	ncl = scl;				/* Start cluster */
    491          	for (;;) {
    492          		ncl++;							/* Next cluster */
    493          		if (ncl >= mcl) {				/* Wrap around */
    494          			ncl = 2;
    495          			if (ncl > scl) return 0;	/* No free custer */
    496          		}
    497          		cs = get_fat(fs, ncl);			/* Get the cluster status */
    498          		if (cs == 0) break;				/* Found a free cluster */
    499          		if (cs == 0xFFFFFFFF || cs == 1)/* An error occured */
    500          			return cs;
    501          		if (ncl == scl) return 0;		/* No free custer */
    502          	}
    503          
    504          	if (put_fat(fs, ncl, 0x0FFFFFFF))	/* Mark the new cluster "in use" */
    505          		return 0xFFFFFFFF;
    506          	if (clst != 0) {					/* Link it to the previous one if needed */
    507          		if (put_fat(fs, clst, ncl))
    508          			return 0xFFFFFFFF;
    509          	}
    510          
    511          	fs->last_clust = ncl;				/* Update FSINFO */
    512          	if (fs->free_clust != 0xFFFFFFFF) {
    513          		fs->free_clust--;
    514          		fs->fsi_flag = 1;
    515          	}
    516          
    517          	return ncl;		/* Return new cluster number */
    518          }
    519          #endif /* !_FS_READONLY */
    520          
    521          
    522          
    523          
    524          /*-----------------------------------------------------------------------*/
    525          /* Get sector# from cluster#                                             */
    526          /*-----------------------------------------------------------------------*/
    527          
    528          
    529          DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
    530          	FATFS *fs,		/* File system object */
    531          	DWORD clst		/* Cluster# to be converted */
    532          )
    533          {
    534          	clst -= 2;
    535          	if (clst >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
    536          	return clst * fs->csize + fs->database;
    537          }
    538          
    539          
    540          
    541          
    542          /*-----------------------------------------------------------------------*/
    543          /* Directory handling - Seek directory index                             */
    544          /*-----------------------------------------------------------------------*/
    545          
    546          static
    547          FRESULT dir_seek (
    548          	DIR *dj,		/* Pointer to directory object */
    549          	WORD idx		/* Directory index number */
    550          )
    551          {
    552          	DWORD clst;
    553          	WORD ic;
    554          
    555          
    556          	dj->index = idx;
    557          	clst = dj->sclust;
    558          	if (clst == 1 || clst >= dj->fs->max_clust)	/* Check start cluster range */
    559          		return FR_INT_ERR;
    560          	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    561          		clst = dj->fs->dirbase;
    562          
    563          	if (clst == 0) {	/* Static table */
    564          		dj->clust = clst;
    565          		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
    566          			return FR_INT_ERR;
    567          		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / 32);	/* Sector# */
    568          	}
    569          	else {				/* Dynamic table */
    570          		ic = SS(dj->fs) / 32 * dj->fs->csize;	/* Entries per cluster */
    571          		while (idx >= ic) {	/* Follow cluster chain */
    572          			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    573          			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    574          			if (clst < 2 || clst >= dj->fs->max_clust)	/* Reached to end of table or int error */
    575          				return FR_INT_ERR;
    576          			idx -= ic;
    577          		}
    578          		dj->clust = clst;
    579          		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / 32);	/* Sector# */
    580          	}
    581          
    582          	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / 32)) * 32;	/* Ptr to the entry in the sector */
    583          
    584          	return FR_OK;	/* Seek succeeded */
    585          }
    586          
    587          
    588          
    589          
    590          /*-----------------------------------------------------------------------*/
    591          /* Directory handling - Move directory index next                        */
    592          /*-----------------------------------------------------------------------*/
    593          
    594          static
    595          FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not streach */
    596          	DIR *dj,		/* Pointer to directory object */
    597          	BOOL streach	/* FALSE: Do not streach table, TRUE: Streach table if needed */
    598          )
    599          {
    600          	DWORD clst;
    601          	WORD i;
    602          
    603          
    604          	i = dj->index + 1;
    605          	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    606          		return FR_NO_FILE;
    607          
    608          	if (!(i % (SS(dj->fs) / 32))) {	/* Sector changed? */
    609          		dj->sect++;					/* Next sector */
    610          
    611          		if (dj->clust == 0) {	/* Static table */
    612          			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
    613          				return FR_NO_FILE;
    614          		}
    615          		else {					/* Dynamic table */
    616          			if (((i / (SS(dj->fs) / 32)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    617          				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
    618          				if (clst <= 1) return FR_INT_ERR;
    619          				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    620          				if (clst >= dj->fs->max_clust) {				/* When it reached end of dynamic table */
    621          #if !_FS_READONLY
    622          					BYTE c;
    623          					if (!streach) return FR_NO_FILE;			/* When do not streach, report EOT */
    624          					clst = create_chain(dj->fs, dj->clust);		/* Streach cluster chain */
    625          					if (clst == 0) return FR_DENIED;			/* No free cluster */
    626          					if (clst == 1) return FR_INT_ERR;
    627          					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    628          					/* Clean-up streached table */
    629          					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    630          					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
    631          					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
    632          					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    633          						dj->fs->wflag = 1;
    634          						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    635          						dj->fs->winsect++;
    636          					}
    637          					dj->fs->winsect -= c;						/* Rewind window address */
    638          #else
    639          					return FR_NO_FILE;			/* Report EOT */
    640          #endif
    641          				}
    642          				dj->clust = clst;				/* Initialize data for new cluster */
    643          				dj->sect = clust2sect(dj->fs, clst);
    644          			}
    645          		}
    646          	}
    647          
    648          	dj->index = i;
    649          	dj->dir = dj->fs->win + (i % (SS(dj->fs) / 32)) * 32;
    650          
    651          	return FR_OK;
    652          }
    653          
    654          
    655          
    656          
    657          /*-----------------------------------------------------------------------*/
    658          /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
    659          /*-----------------------------------------------------------------------*/
    660          #if _USE_LFN
    661          static
    662          const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory entry */
    663          
    664          
    665          static
    666          BOOL cmp_lfn (			/* TRUE:Matched, FALSE:Not matched */
    667          	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
    668          	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
    669          )
    670          {
    671          	int i, s;
    672          	WCHAR wc, uc;
    673          
    674          
    675          	i = ((dir[LDIR_Ord] & 0xBF) - 1) * 13;	/* Get offset in the LFN buffer */
    676          	s = 0; wc = 1;
    677          	do {
    678          		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
    679          		if (wc) {	/* Last char has not been processed */
    680          			wc = ff_wtoupper(uc);		/* Convert it to upper case */
    681          			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
    682          				return FALSE;			/* Not matched */
    683          		} else {
    684          			if (uc != 0xFFFF) return FALSE;	/* Check filler */
    685          		}
    686          	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
    687          
    688          	if ((dir[LDIR_Ord] & 0x40) && wc && lfnbuf[i])	/* Last segment matched but different length */
    689          		return FALSE;
    690          
    691          	return TRUE;					/* The part of LFN matched */
    692          }
    693          
    694          
    695          
    696          static
    697          BOOL pick_lfn (			/* TRUE:Succeeded, FALSE:Buffer overflow */
    698          	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
    699          	BYTE *dir			/* Pointer to the directory entry */
    700          )
    701          {
    702          	int i, s;
    703          	WCHAR wc, uc;
    704          
    705          
    706          	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
    707          
    708          	s = 0; wc = 1;
    709          	do {
    710          		uc = LD_WORD(dir+LfnOfs[s]);			/* Pick an LFN character from the entry */
    711          		if (wc) {	/* Last char has not been processed */
    712          			if (i >= _MAX_LFN) return FALSE;	/* Buffer overflow? */
    713          			lfnbuf[i++] = wc = uc;				/* Store it */
    714          		} else {
    715          			if (uc != 0xFFFF) return FALSE;		/* Check filler */
    716          		}
    717          	} while (++s < 13);						/* Read all character in the entry */
    718          
    719          	if (dir[LDIR_Ord] & 0x40) {				/* Put terminator if it is the last LFN part */
    720          		if (i >= _MAX_LFN) return FALSE;	/* Buffer overflow? */
    721          		lfnbuf[i] = 0;
    722          	}
    723          
    724          	return TRUE;
    725          }
    726          
    727          
    728          #if !_FS_READONLY
    729          static
    730          void fit_lfn (
    731          	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
    732          	BYTE *dir,				/* Pointer to the directory entry */
    733          	BYTE ord,				/* LFN order (1-20) */
    734          	BYTE sum				/* SFN sum */
    735          )
    736          {
    737          	int i, s;
    738          	WCHAR wc;
    739          
    740          
    741          	dir[LDIR_Chksum] = sum;			/* Set check sum */
    742          	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
    743          	dir[LDIR_Type] = 0;
    744          	ST_WORD(dir+LDIR_FstClusLO, 0);
    745          
    746          	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
    747          	s = wc = 0;
    748          	do {
    749          		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
    750          		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
    751          		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
    752          	} while (++s < 13);
    753          	if (wc == 0xFFFF || !lfnbuf[i]) ord |= 0x40;	/* Bottom LFN part is the start of LFN sequence */
    754          	dir[LDIR_Ord] = ord;			/* Set the LFN order */
    755          }
    756          
    757          #endif
    758          #endif
    759          
    760          
    761          
    762          /*-----------------------------------------------------------------------*/
    763          /* Create numbered name                                                  */
    764          /*-----------------------------------------------------------------------*/
    765          #if _USE_LFN
    766          void gen_numname (
    767          	BYTE *dst,			/* Pointer to genartated SFN */
    768          	const BYTE *src,	/* Pointer to source SFN to be modified */
    769          	const WCHAR *lfn,	/* Pointer to LFN */
    770          	WORD num			/* Sequense number */
    771          )
    772          {
    773          	char ns[8];
    774          	int i, j;
    775          
    776          
    777          	mem_cpy(dst, src, 11);
    778          
    779          	if (num > 5) {	/* On many collisions, generate a hash number instead of sequencial number */
    780          		do num = (num >> 1) + (num << 15) + (WORD)*lfn++; while (*lfn);
    781          	}
    782          
    783          	/* itoa */
    784          	i = 7;
    785          	do {
    786          		ns[i--] = (num % 10) + '0';
    787          		num /= 10;
    788          	} while (num);
    789          	ns[i] = '~';
    790          
    791          	/* Append the number */
    792          	for (j = 0; j < i && dst[j] != ' '; j++) {
    793          		if (IsDBCS1(dst[j])) {
    794          			if (j == i - 1) break;
    795          			j++;
    796          		}
    797          	}
    798          	do {
    799          		dst[j++] = (i < 8) ? ns[i++] : ' ';
    800          	} while (j < 8);
    801          }
    802          #endif
    803          
    804          
    805          
    806          
    807          /*-----------------------------------------------------------------------*/
    808          /* Calculate sum of an SFN                                               */
    809          /*-----------------------------------------------------------------------*/
    810          #if _USE_LFN
    811          static
    812          BYTE sum_sfn (
    813          	const BYTE *dir		/* Ptr to directory entry */
    814          )
    815          {
    816          	BYTE sum = 0;
    817          	int n = 11;
    818          
    819          	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
    820          	return sum;
    821          }
    822          #endif
    823          
    824          
    825          
    826          
    827          /*-----------------------------------------------------------------------*/
    828          /* Directory handling - Find an object in the directory                  */
    829          /*-----------------------------------------------------------------------*/
    830          
    831          static
    832          FRESULT dir_find (
    833          	DIR *dj			/* Pointer to the directory object linked to the file name */
    834          )
    835          {
    836          	FRESULT res;
    837          	BYTE c, *dir;
    838          #if _USE_LFN
    839          	BYTE a, ord, sum;
    840          #endif
    841          
    842          	res = dir_seek(dj, 0);			/* Rewind directory object */
    843          	if (res != FR_OK) return res;
    844          
    845          #if _USE_LFN
    846          	ord = sum = 0xFF;
    847          #endif
    848          	do {
    849          		res = move_window(dj->fs, dj->sect);
    850          		if (res != FR_OK) break;
    851          		dir = dj->dir;					/* Ptr to the directory entry of current index */
    852          		c = dir[DIR_Name];
    853          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    854          #if _USE_LFN	/* LFN configuration */
    855          		a = dir[DIR_Attr] & AM_MASK;
    856          		if (c == 0xE5 || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
    857          			ord = 0xFF;
    858          		} else {
    859          			if (a == AM_LFN) {			/* An LFN entry is found */
    860          				if (dj->lfn) {
    861          					if (c & 0x40) {		/* Is it start of LFN sequence? */
    862          						sum = dir[LDIR_Chksum];
    863          						c &= 0xBF; ord = c;	/* LFN start order */
    864          						dj->lfn_idx = dj->index;
    865          					}
    866          					/* Check validity of the LFN entry and compare it with given name */
    867          					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
    868          				}
    869          			} else {					/* An SFN entry is found */
    870          				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
    871          				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
    872          				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
    873          			}
    874          		}
    875          #else		/* Non LFN configuration */
    876          		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    877          			break;
    878          #endif
    879          		res = dir_next(dj, FALSE);		/* Next entry */
    880          	} while (res == FR_OK);
    881          
    882          	return res;
    883          }
    884          
    885          
    886          
    887          
    888          /*-----------------------------------------------------------------------*/
    889          /* Read an object from the directory                                     */
    890          /*-----------------------------------------------------------------------*/
    891          #if _FS_MINIMIZE <= 1
    892          static
    893          FRESULT dir_read (
    894          	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
    895          )
    896          {
    897          	FRESULT res;
    898          	BYTE c, *dir;
    899          #if _USE_LFN
    900          	BYTE a, ord = 0xFF, sum = 0xFF;
    901          #endif
    902          
    903          	res = FR_NO_FILE;
    904          	while (dj->sect) {
    905          		res = move_window(dj->fs, dj->sect);
    906          		if (res != FR_OK) break;
    907          		dir = dj->dir;					/* Ptr to the directory entry of current index */
    908          		c = dir[DIR_Name];
    909          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    910          #if _USE_LFN	/* LFN configuration */
    911          		a = dir[DIR_Attr] & AM_MASK;
    912          		if (c == 0xE5 || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
    913          			ord = 0xFF;
    914          		} else {
    915          			if (a == AM_LFN) {			/* An LFN entry is found */
    916          				if (c & 0x40) {			/* Is it start of LFN sequence? */
    917          					sum = dir[LDIR_Chksum];
    918          					c &= 0xBF; ord = c;
    919          					dj->lfn_idx = dj->index;
    920          				}
    921          				/* Check LFN validity and capture it */
    922          				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
    923          			} else {					/* An SFN entry is found */
    924          				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
    925          					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
    926          				break;
    927          			}
    928          		}
    929          #else		/* Non LFN configuration */
    930          		if (c != 0xE5 && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
    931          			break;
    932          #endif
    933          		res = dir_next(dj, FALSE);				/* Next entry */
    934          		if (res != FR_OK) break;
    935          	}
    936          
    937          	if (res != FR_OK) dj->sect = 0;
    938          
    939          	return res;
    940          }
    941          #endif
    942          
    943          
    944          
    945          /*-----------------------------------------------------------------------*/
    946          /* Register an object to the directory                                   */
    947          /*-----------------------------------------------------------------------*/
    948          #if !_FS_READONLY
    949          static
    950          FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
    951          	DIR *dj				/* Target directory with object name to be created */
    952          )
    953          {
    954          	FRESULT res;
    955          	BYTE c, *dir;
    956          #if _USE_LFN	/* LFN configuration */
    957          	WORD n, ne, is;
    958          	BYTE sn[12], *fn, sum;
    959          	WCHAR *lfn;
    960          
    961          
    962          	fn = dj->fn; lfn = dj->lfn;
    963          	mem_cpy(sn, fn, 12);
    964          
    965          	if (_FS_RPATH && (sn[NS] & NS_DOT)) return FR_INVALID_NAME;	/* Cannot create dot entry */
    966          
    967          	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
    968          		fn[NS] = 0; dj->lfn = NULL;			/* Find only SFN */
    969          		for (n = 1; n < 100; n++) {
    970          			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
    971          			res = dir_find(dj);				/* Check if the name collides with existing SFN */
    972          			if (res != FR_OK) break;
    973          		}
    974          		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
    975          		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
    976          		fn[NS] = sn[NS]; dj->lfn = lfn;
    977          	}
    978          
    979          	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve reserve an SFN + LFN entries. */
    980          		for (ne = 0; lfn[ne]; ne++) ;
    981          		ne = (ne + 25) / 13;
    982          	} else {						/* Otherwise reserve only an SFN entry. */
    983          		ne = 1;
    984          	}
    985          
    986          	/* Reserve contiguous entries */
    987          	res = dir_seek(dj, 0);
    988          	if (res != FR_OK) return res;
    989          	n = is = 0;
    990          	do {
    991          		res = move_window(dj->fs, dj->sect);
    992          		if (res != FR_OK) break;
    993          		c = *dj->dir;				/* Check the entry status */
    994          		if (c == 0xE5 || c == 0) {	/* Is it a blank entry? */
    995          			if (n == 0) is = dj->index;	/* First index of the contigulus entry */
    996          			if (++n == ne) break;	/* A contiguous entry that requiered count is found */
    997          		} else {
    998          			n = 0;					/* Not a blank entry. Restart to search */
    999          		}
   1000          		res = dir_next(dj, TRUE);	/* Next entry with table streach */
   1001          	} while (res == FR_OK);
   1002          
   1003          	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
   1004          		res = dir_seek(dj, is);
   1005          		if (res == FR_OK) {
   1006          			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
   1007          			ne--;
   1008          			do {					/* Store LFN entries in bottom first */
   1009          				res = move_window(dj->fs, dj->sect);
   1010          				if (res != FR_OK) break;
   1011          				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
   1012          				dj->fs->wflag = 1;
   1013          				res = dir_next(dj, FALSE);	/* Next entry */
   1014          			} while (res == FR_OK && --ne);
   1015          		}
   1016          	}
   1017          
   1018          #else	/* Non LFN configuration */
   1019          	res = dir_seek(dj, 0);
   1020          	if (res == FR_OK) {
   1021          		do {	/* Find a blank entry for the SFN */
   1022          			res = move_window(dj->fs, dj->sect);
   1023          			if (res != FR_OK) break;
   1024          			c = *dj->dir;
   1025          			if (c == 0xE5 || c == 0) break;	/* Is it a blank entry? */
   1026          			res = dir_next(dj, TRUE);		/* Next entry with table streach */
   1027          		} while (res == FR_OK);
   1028          	}
   1029          #endif
   1030          
   1031          	if (res == FR_OK) {		/* Initialize the SFN entry */
   1032          		res = move_window(dj->fs, dj->sect);
   1033          		if (res == FR_OK) {
   1034          			dir = dj->dir;
   1035          			mem_set(dir, 0, 32);		/* Clean the entry */
   1036          			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
   1037          			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
   1038          			dj->fs->wflag = 1;
   1039          		}
   1040          	}
   1041          
   1042          	return res;
   1043          }
   1044          #endif /* !_FS_READONLY */
   1045          
   1046          
   1047          
   1048          
   1049          /*-----------------------------------------------------------------------*/
   1050          /* Remove an object from the directory                                   */
   1051          /*-----------------------------------------------------------------------*/
   1052          #if !_FS_READONLY && !_FS_MINIMIZE
   1053          static
   1054          FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
   1055          	DIR *dj				/* Directory object pointing the entry to be removed */
   1056          )
   1057          {
   1058          	FRESULT res;
   1059          #if _USE_LFN	/* LFN configuration */
   1060          	WORD i;
   1061          
   1062          	i = dj->index;	/* SFN index */
   1063          	res = dir_seek(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
   1064          	if (res == FR_OK) {
   1065          		do {
   1066          			res = move_window(dj->fs, dj->sect);
   1067          			if (res != FR_OK) break;
   1068          			*dj->dir = 0xE5;			/* Mark the entry "deleted" */
   1069          			dj->fs->wflag = 1;
   1070          			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
   1071          			res = dir_next(dj, FALSE);	/* Next entry */
   1072          		} while (res == FR_OK);
   1073          		if (res == FR_NO_FILE) res = FR_INT_ERR;
   1074          	}
   1075          
   1076          #else			/* Non LFN configuration */
   1077          	res = dir_seek(dj, dj->index);
   1078          	if (res == FR_OK) {
   1079          		res = move_window(dj->fs, dj->sect);
   1080          		if (res == FR_OK) {
   1081          			*dj->dir = 0xE5;			/* Mark the entry "deleted" */
   1082          			dj->fs->wflag = 1;
   1083          		}
   1084          	}
   1085          #endif
   1086          
   1087          	return res;
   1088          }
   1089          #endif /* !_FS_READONLY */
   1090          
   1091          
   1092          
   1093          
   1094          /*-----------------------------------------------------------------------*/
   1095          /* Pick a segment and create the object name in directory form           */
   1096          /*-----------------------------------------------------------------------*/
   1097          
   1098          static
   1099          FRESULT create_name (
   1100          	DIR *dj,			/* Pointer to the directory object */
   1101          	const XCHAR **path	/* Pointer to pointer to the segment in the path string */
   1102          )
   1103          {
   1104          #ifdef _EXCVT
   1105          	static const BYTE cvt[] = _EXCVT;
   1106          #endif
   1107          
   1108          #if _USE_LFN	/* LFN configuration */
   1109          	BYTE b, cf;
   1110          	WCHAR w, *lfn;
   1111          	int i, ni, si, di;
   1112          	const XCHAR *p;
   1113          
   1114          	/* Create LFN in Unicode */
   1115          	si = di = 0;
   1116          	p = *path;
   1117          	lfn = dj->lfn;
   1118          	for (;;) {
   1119          		w = p[si++];					/* Get a character */
   1120          		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
   1121          		if (di >= _MAX_LFN)				/* Reject too long name */
   1122          			return FR_INVALID_NAME;
   1123          #if !_LFN_UNICODE
   1124          		w &= 0xFF;
   1125          		if (IsDBCS1(w)) {				/* If it is a DBC 1st byte */
   1126          			b = p[si++];				/* Get 2nd byte */
   1127          			if (!IsDBCS2(b))			/* Reject invalid code for DBC */
   1128          				return FR_INVALID_NAME;
   1129          			w = (w << 8) + b;
   1130          		}
   1131          		w = ff_convert(w, 1);			/* Convert OEM to Unicode */
   1132          		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
   1133          #endif
   1134          		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
   1135          			return FR_INVALID_NAME;
   1136          		lfn[di++] = w;					/* Store the Unicode char */
   1137          	}
   1138          	*path = &p[si];						/* Rerurn pointer to the next segment */
   1139          	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   1140          #if _FS_RPATH
   1141          	if ((di == 1 && lfn[di - 1] == '.') || /* Is this a dot entry? */
   1142          		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {
   1143          		lfn[di] = 0;
   1144          		for (i = 0; i < 11; i++)
   1145          			dj->fn[i] = (i < di) ? '.' : ' ';
   1146          		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
   1147          		return FR_OK;
   1148          	}
   1149          #endif
   1150          	while (di) {						/* Strip trailing spaces and dots */
   1151          		w = lfn[di - 1];
   1152          		if (w != ' ' && w != '.') break;
   1153          		di--;
   1154          	}
   1155          	if (!di) return FR_INVALID_NAME;	/* Reject null string */
   1156          
   1157          	lfn[di] = 0;						/* LFN is created */
   1158          
   1159          	/* Create SFN in directory form */
   1160          	mem_set(dj->fn, ' ', 11);
   1161          	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
   1162          	if (si) cf |= NS_LOSS | NS_LFN;
   1163          	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
   1164          
   1165          	b = i = 0; ni = 8;
   1166          	for (;;) {
   1167          		w = lfn[si++];					/* Get an LFN char */
   1168          		if (!w) break;					/* Break on enf of the LFN */
   1169          		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
   1170          			cf |= NS_LOSS | NS_LFN; continue;
   1171          		}
   1172          
   1173          		if (i >= ni || si == di) {		/* Extension or end of SFN */
   1174          			if (ni == 11) {				/* Long extension */
   1175          				cf |= NS_LOSS | NS_LFN; break;
   1176          			}
   1177          			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
   1178          			if (si > di) break;			/* No extension */
   1179          			si = di; i = 8; ni = 11;	/* Enter extension section */
   1180          			b <<= 2; continue;
   1181          		}
   1182          
   1183          		if (w >= 0x80) {				/* Non ASCII char */
   1184          #ifdef _EXCVT
   1185          			w = ff_convert(w, 0);		/* Unicode -> OEM code */
   1186          			if (w) w = cvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
   1187          #else
   1188          			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
   1189          #endif
   1190          			cf |= NS_LFN;				/* Force create LFN entry */
   1191          		}
   1192          
   1193          		if (_DF1S && w >= 0x100) {		/* Double byte char */
   1194          			if (i >= ni - 1) {
   1195          				cf |= NS_LOSS | NS_LFN; i = ni; continue;
   1196          			}
   1197          			dj->fn[i++] = (BYTE)(w >> 8);
   1198          		} else {						/* Single byte char */
   1199          			if (!w || chk_chr("+,;[=]", w)) {		/* Replace illegal chars for SFN */
   1200          				w = '_'; cf |= NS_LOSS | NS_LFN;	/* Lossy conversion */
   1201          			} else {
   1202          				if (IsUpper(w)) {		/* ASCII large capital */
   1203          					b |= 2;
   1204          				} else {
   1205          					if (IsLower(w)) {	/* ASCII small capital */
   1206          						b |= 1; w -= 0x20;
   1207          					}
   1208          				}
   1209          			}
   1210          		}
   1211          		dj->fn[i++] = (BYTE)w;
   1212          	}
   1213          
   1214          	if (dj->fn[0] == 0xE5) dj->fn[0] = 0x05;	/* If the first char collides with deleted mark, replace it with 0x05 */
   1215          
   1216          	if (ni == 8) b <<= 2;
   1217          	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
   1218          		cf |= NS_LFN;
   1219          	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
   1220          		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
   1221          		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
   1222          	}
   1223          
   1224          	dj->fn[NS] = cf;	/* SFN is created */
   1225          
   1226          	return FR_OK;
   1227          
   1228          
   1229          #else	/* Non-LFN configuration */
   1230          	BYTE b, c, d, *sfn;
   1231          	int ni, si, i;
   1232          	const char *p;
   1233          
   1234          	/* Create file name in directory form */
   1235          	sfn = dj->fn;
   1236          	mem_set(sfn, ' ', 11);
   1237          	si = i = b = 0; ni = 8;
   1238          	p = *path;
   1239          #if _FS_RPATH
   1240          	if (p[si] == '.') { /* Is this a dot entry? */
   1241          		for (;;) {
   1242          			c = p[si++];
   1243          			if (c != '.' || si >= 3) break;
   1244          			sfn[i++] = c;
   1245          		}
   1246          		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
   1247          		*path = &p[si];									/* Rerurn pointer to the next segment */
   1248          		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
   1249          		return FR_OK;
   1250          	}
   1251          #endif
   1252          	for (;;) {
   1253          		c = p[si++];
   1254          		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
   1255          		if (c == '.' || i >= ni) {
   1256          			if (ni != 8 || c != '.') return FR_INVALID_NAME;
   1257          			i = 8; ni = 11;
   1258          			b <<= 2; continue;
   1259          		}
   1260          		if (c >= 0x80) {				/* Extended char */
   1261          #ifdef _EXCVT
   1262          			c = cvt[c - 0x80];			/* Convert extend char (SBCS) */
   1263          #else
   1264          			b |= 3;						/* Eliminate NT flag if ext char is exist */
   1265          #if !_DF1S	/* ASCII only cfg */
   1266          			return FR_INVALID_NAME;
   1267          #endif
   1268          #endif
   1269          		}
   1270          		if (IsDBCS1(c)) {				/* DBC 1st byte? */
   1271          			d = p[si++];				/* Get 2nd byte */
   1272          			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
   1273          				return FR_INVALID_NAME;
   1274          			sfn[i++] = c;
   1275          			sfn[i++] = d;
   1276          		} else {						/* Single byte code */
   1277          			if (chk_chr(" \"*+,[=]|\x7F", c))	/* Reject illegal chrs for SFN */
   1278          				return FR_INVALID_NAME;
   1279          			if (IsUpper(c)) {			/* ASCII large capital? */
   1280          				b |= 2;
   1281          			} else {
   1282          				if (IsLower(c)) {		/* ASCII small capital? */
   1283          					b |= 1; c -= 0x20;
   1284          				}
   1285          			}
   1286          			sfn[i++] = c;
   1287          		}
   1288          	}
   1289          	*path = &p[si];						/* Rerurn pointer to the next segment */
   1290          	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   1291          
   1292          	if (!i) return FR_INVALID_NAME;		/* Reject null string */
   1293          	if (sfn[0] == 0xE5) sfn[0] = 0x05;	/* When first char collides with 0xE5, replace it with 0x05 */
   1294          
   1295          	if (ni == 8) b <<= 2;
   1296          	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Extension has only small capital) */
   1297          	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Filename has only small capital) */
   1298          
   1299          	sfn[NS] = c;		/* Store NT flag, File name is created */
   1300          
   1301          	return FR_OK;
   1302          #endif
   1303          }
   1304          
   1305          
   1306          
   1307          
   1308          /*-----------------------------------------------------------------------*/
   1309          /* Get file information from directory entry                             */
   1310          /*-----------------------------------------------------------------------*/
   1311          #if _FS_MINIMIZE <= 1
   1312          static
   1313          void get_fileinfo (		/* No return code */
   1314          	DIR *dj,			/* Pointer to the directory object */
   1315          	FILINFO *fno	 	/* Pointer to the file information to be filled */
   1316          )
   1317          {
   1318          	int i;
   1319          	BYTE c, nt, *dir;
   1320          	char *p;
   1321          
   1322          
   1323          	p = fno->fname;
   1324          	if (dj->sect) {
   1325          		dir = dj->dir;
   1326          		nt = dir[DIR_NTres];		/* NT flag */
   1327          		for (i = 0; i < 8; i++) {	/* Copy name body */
   1328          			c = dir[i];
   1329          			if (c == ' ') break;
   1330          			if (c == 0x05) c = 0xE5;
   1331          			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
   1332          			*p++ = c;
   1333          		}
   1334          		if (dir[8] != ' ') {		/* Copy name extension */
   1335          			*p++ = '.';
   1336          			for (i = 8; i < 11; i++) {
   1337          				c = dir[i];
   1338          				if (c == ' ') break;
   1339          				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
   1340          				*p++ = c;
   1341          			}
   1342          		}
   1343          		fno->fattrib = dir[DIR_Attr];				/* Attribute */
   1344          		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
   1345          		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
   1346          		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
   1347          	}
   1348          	*p = 0;
   1349          
   1350          #if _USE_LFN
   1351          	if (fno->lfname) {
   1352          		XCHAR *tp = fno->lfname;
   1353          		WCHAR w, *lfn;
   1354          
   1355          		i = 0;
   1356          		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
   1357          			lfn = dj->lfn;
   1358          			while ((w = *lfn++) != 0) {			/* Get an LFN char */
   1359          #if !_LFN_UNICODE
   1360          				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
   1361          				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
   1362          				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC */
   1363          					tp[i++] = (XCHAR)(w >> 8);
   1364          #endif
   1365          				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overrun, no LFN */
   1366          				tp[i++] = (XCHAR)w;
   1367          			}
   1368          		}
   1369          		tp[i] = 0;	/* Terminator */
   1370          	}
   1371          #endif
   1372          }
   1373          #endif /* _FS_MINIMIZE <= 1 */
   1374          
   1375          
   1376          
   1377          
   1378          /*-----------------------------------------------------------------------*/
   1379          /* Follow a file path                                                    */
   1380          /*-----------------------------------------------------------------------*/
   1381          
   1382          static
   1383          FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
   1384          	DIR *dj,			/* Directory object to return last directory and found object */
   1385          	const XCHAR *path	/* Full-path string to find a file or directory */
   1386          )
   1387          {
   1388          	FRESULT res;
   1389          	BYTE *dir, last;
   1390          
   1391          
   1392          	while (!_USE_LFN && *path == ' ') path++;	/* Skip leading spaces */
   1393          #if _FS_RPATH
   1394          	if (*path == '/' || *path == '\\') { /* There is a heading separator */
   1395          		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
   1396          	} else {							/* No heading saparator */
   1397          		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
   1398          	}
   1399          #else
   1400          	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
   1401          		path++;
   1402          	dj->sclust = 0;						/* Start from the root dir */
   1403          #endif
   1404          
   1405          	if ((UINT)*path < ' ') {			/* Null path means the start directory itself */
   1406          		res = dir_seek(dj, 0);
   1407          		dj->dir = NULL;
   1408          
   1409          	} else {							/* Follow path */
   1410          		for (;;) {
   1411          			res = create_name(dj, &path);	/* Get a segment */
   1412          			if (res != FR_OK) break;
   1413          			res = dir_find(dj);				/* Find it */
   1414          			last = *(dj->fn+NS) & NS_LAST;
   1415          			if (res != FR_OK) {				/* Could not find the object */
   1416          				if (res == FR_NO_FILE && !last)
   1417          					res = FR_NO_PATH;
   1418          				break;
   1419          			}
   1420          			if (last) break;				/* Last segment match. Function completed. */
   1421          			dir = dj->dir;					/* There is next segment. Follow the sub directory */
   1422          			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
   1423          				res = FR_NO_PATH; break;
   1424          			}
   1425          			dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
   1426          		}
   1427          	}
   1428          
   1429          	return res;
   1430          }
   1431          
   1432          
   1433          
   1434          
   1435          /*-----------------------------------------------------------------------*/
   1436          /* Load boot record and check if it is an FAT boot record                */
   1437          /*-----------------------------------------------------------------------*/
   1438          
   1439          static
   1440          BYTE check_fs (	/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
   1441          	FATFS *fs,	/* File system object */
   1442          	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
   1443          )
   1444          {
   1445          	if (disk_read(fs->drive, fs->win, sect, 1) != RES_OK)	/* Load boot record */
   1446          		return 3;
   1447          	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
   1448          		return 2;
   1449          
   1450          	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
   1451          		return 0;
   1452          	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
   1453          		return 0;
   1454          
   1455          	return 1;
   1456          }
   1457          
   1458          
   1459          
   1460          
   1461          /*-----------------------------------------------------------------------*/
   1462          /* Make sure that the file system is valid                               */
   1463          /*-----------------------------------------------------------------------*/
   1464          
   1465          
   1466          FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occured */
   1467          	const XCHAR **path,	/* Pointer to pointer to the path name (drive number) */
   1468          	FATFS **rfs,		/* Pointer to pointer to the found file system object */
   1469          	BYTE chk_wp			/* !=0: Check media write protection for write access */
   1470          )
   1471          {
   1472          	BYTE fmt, *tbl;
   1473          	UINT vol;
   1474          	DSTATUS stat;
   1475          	DWORD bsect, fsize, tsect, mclst;
   1476          	const XCHAR *p = *path;
   1477          	FATFS *fs;
   1478          
   1479          	/* Get logical drive number from the path name */
   1480          	vol = p[0] - '0';				/* Is there a drive number? */
   1481          	if (vol <= 9 && p[1] == ':') {	/* Found a drive number, get and strip it */
   1482          		p += 2; *path = p;			/* Return pointer to the path name */
   1483          	} else {						/* No drive number is given */
   1484          #if _FS_RPATH
   1485          		vol = Drive;				/* Use current drive */
   1486          #else
   1487          		vol = 0;					/* Use drive 0 */
   1488          #endif
   1489          	}
   1490          
   1491          	/* Check if the logical drive is valid or not */
   1492          	if (vol >= _DRIVES) 			/* Is the drive number valid? */
   1493          		return FR_INVALID_DRIVE;
   1494          	*rfs = fs = FatFs[vol];			/* Returen pointer to the corresponding file system object */
   1495          	if (!fs) return FR_NOT_ENABLED;	/* Is the file system object available? */
   1496          
   1497          	ENTER_FF(fs);					/* Lock file system */
   1498          
   1499          	if (fs->fs_type) {				/* If the logical drive has been mounted */
   1500          		stat = disk_status(fs->drive);
   1501          		if (!(stat & STA_NOINIT)) {	/* and the physical drive is kept initialized (has not been changed), */
   1502          #if !_FS_READONLY
   1503          			if (chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
   1504          				return FR_WRITE_PROTECTED;
   1505          #endif
   1506          			return FR_OK;			/* The file system object is valid */
   1507          		}
   1508          	}
   1509          
   1510          	/* The logical drive must be mounted. Following code attempts to mount the volume */
   1511          
   1512          	fs->fs_type = 0;					/* Clear the file system object */
   1513          	fs->drive = (BYTE)LD2PD(vol);		/* Bind the logical drive and a physical drive */
   1514          	stat = disk_initialize(fs->drive);	/* Initialize low level disk I/O layer */
   1515          	if (stat & STA_NOINIT)				/* Check if the drive is ready */
   1516          		return FR_NOT_READY;
   1517          #if _MAX_SS != 512						/* Get disk sector size if needed */
   1518          	if (disk_ioctl(fs->drive, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
   1519          		return FR_NO_FILESYSTEM;
   1520          #endif
   1521          #if !_FS_READONLY
   1522          	if (chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
   1523          		return FR_WRITE_PROTECTED;
   1524          #endif
   1525          	/* Search FAT partition on the drive */
   1526          	fmt = check_fs(fs, bsect = 0);		/* Check sector 0 as an SFD format */
   1527          	if (fmt == 1) {						/* Not an FAT boot record, it may be patitioned */
   1528          		/* Check a partition listed in top of the partition table */
   1529          		tbl = &fs->win[MBR_Table + LD2PT(vol) * 16];	/* Partition table */
   1530          		if (tbl[4]) {									/* Is the partition existing? */
   1531          			bsect = LD_DWORD(&tbl[8]);					/* Partition offset in LBA */
   1532          			fmt = check_fs(fs, bsect);					/* Check the partition */
   1533          		}
   1534          	}
   1535          	if (fmt == 3) return FR_DISK_ERR;
   1536          	if (fmt || LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))	/* No valid FAT patition is found */
   1537          		return FR_NO_FILESYSTEM;
   1538          
   1539          	/* Initialize the file system object */
   1540          	fsize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
   1541          	if (!fsize) fsize = LD_DWORD(fs->win+BPB_FATSz32);
   1542          	fs->sects_fat = fsize;
   1543          	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
   1544          	fsize *= fs->n_fats;								/* (Number of sectors in FAT area) */
   1545          	fs->fatbase = bsect + LD_WORD(fs->win+BPB_RsvdSecCnt); /* FAT start sector (lba) */
   1546          	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
   1547          	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Nmuber of root directory entries */
   1548          	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
   1549          	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
   1550          	fs->max_clust = mclst = (tsect						/* Last cluster# + 1 (Number of clusters + 2) */
   1551          		- LD_WORD(fs->win+BPB_RsvdSecCnt) - fsize - fs->n_rootdir / (SS(fs)/32)
   1552          		) / fs->csize + 2;
   1553          
   1554          	fmt = FS_FAT12;										/* Determine the FAT sub type */
   1555          	if (mclst >= 0xFF7) fmt = FS_FAT16;					/* Number of clusters >= 0xFF5 */
   1556          	if (mclst >= 0xFFF7) fmt = FS_FAT32;				/* Number of clusters >= 0xFFF5 */
   1557          
   1558          	if (fmt == FS_FAT32)
   1559          		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
   1560          	else
   1561          		fs->dirbase = fs->fatbase + fsize;				/* Root directory start sector (lba) */
   1562          	fs->database = fs->fatbase + fsize + fs->n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
   1563          
   1564          #if !_FS_READONLY
   1565          	/* Initialize allocation information */
   1566          	fs->free_clust = 0xFFFFFFFF;
   1567          	fs->wflag = 0;
   1568          	/* Get fsinfo if needed */
   1569          	if (fmt == FS_FAT32) {
   1570          	 	fs->fsi_flag = 0;
   1571          		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
   1572          		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
   1573          			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
   1574          			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
   1575          			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
   1576          			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
   1577          			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
   1578          		}
   1579          	}
   1580          #endif
   1581          	fs->fs_type = fmt;		/* FAT sub-type */
   1582          	fs->winsect = 0;		/* Invalidate sector cache */
   1583          #if _FS_RPATH
   1584          	fs->cdir = 0;			/* Current directory (root dir) */
   1585          #endif
   1586          	fs->id = ++Fsid;		/* File system mount ID */
   1587          
   1588          	return FR_OK;
   1589          }
   1590          
   1591          
   1592          
   1593          
   1594          /*-----------------------------------------------------------------------*/
   1595          /* Check if the file/dir object is valid or not                          */
   1596          /*-----------------------------------------------------------------------*/
   1597          
   1598          static
   1599          FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
   1600          	FATFS *fs,		/* Pointer to the file system object */
   1601          	WORD id			/* Member id of the target object to be checked */
   1602          )
   1603          {
   1604          	if (!fs || !fs->fs_type || fs->id != id)
   1605          		return FR_INVALID_OBJECT;
   1606          
   1607          	ENTER_FF(fs);		/* Lock file system */
   1608          
   1609          	if (disk_status(fs->drive) & STA_NOINIT)
   1610          		return FR_NOT_READY;
   1611          
   1612          	return FR_OK;
   1613          }
   1614          
   1615          
   1616          
   1617          
   1618          /*--------------------------------------------------------------------------
   1619          
   1620             Public Functions
   1621          
   1622          --------------------------------------------------------------------------*/
   1623          
   1624          
   1625          
   1626          /*-----------------------------------------------------------------------*/
   1627          /* Mount/Unmount a Locical Drive                                         */
   1628          /*-----------------------------------------------------------------------*/
   1629          
   1630          FRESULT f_mount (
   1631          	BYTE vol,		/* Logical drive number to be mounted/unmounted */
   1632          	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
   1633          )
   1634          {
   1635          	FATFS *rfs;
   1636          
   1637          	if (vol >= _DRIVES)				/* Check if the drive number is valid */
   1638          		return FR_INVALID_DRIVE;
   1639          	rfs = FatFs[vol];				/* Get current fs object */
   1640          
   1641          	if (rfs) {
   1642          #if _FS_REENTRANT					/* Discard sync object of the current volume */
   1643          		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
   1644          #endif
   1645          		rfs->fs_type = 0;			/* Clear old fs object */
   1646          	}
   1647          
   1648          	if (fs) {
   1649          		fs->fs_type = 0;			/* Clear new fs object */
   1650          #if _FS_REENTRANT					/* Create sync object for the new volume */
   1651          		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
   1652          #endif
   1653          	}
   1654          	FatFs[vol] = fs;				/* Register new fs object */
   1655          	
   1656          
   1657          	return FR_OK;
   1658          }
   1659          
   1660          
   1661          
   1662          
   1663          /*-----------------------------------------------------------------------*/
   1664          /* Open or Create a File                                                 */
   1665          /*-----------------------------------------------------------------------*/
   1666          
   1667          FRESULT f_open (
   1668          	FIL *fp,			/* Pointer to the blank file object */
   1669          	const XCHAR *path,	/* Pointer to the file name */
   1670          	BYTE mode			/* Access mode and file open mode flags */
   1671          )
   1672          {
   1673          	FRESULT res;
   1674          	DIR dj;
   1675          	NAMEBUF(sfn, lfn);
   1676          	BYTE *dir;
   1677          
   1678          
   1679          	fp->fs = NULL;		/* Clear file object */
   1680          #if !_FS_READONLY
   1681          	mode &= (FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW);
   1682          	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & (FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)));
   1683          #else
   1684          	mode &= FA_READ;
   1685          	res = chk_mounted(&path, &dj.fs, 0);
   1686          #endif
   1687          	if (res != FR_OK) LEAVE_FF(dj.fs, res);
   1688          	INITBUF(dj, sfn, lfn);
   1689          	res = follow_path(&dj, path);	/* Follow the file path */
   1690          
   1691          #if !_FS_READONLY
   1692          	/* Create or Open a file */
   1693          	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
   1694          		DWORD ps, cl;
   1695          
   1696          		if (res != FR_OK) {			/* No file, create new */
   1697          			if (res == FR_NO_FILE)	/* There is no file to open, create a new entry */
   1698          				res = dir_register(&dj);
   1699          			if (res != FR_OK) LEAVE_FF(dj.fs, res);
   1700          			mode |= FA_CREATE_ALWAYS;
   1701          			dir = dj.dir;			/* Created entry (SFN entry) */
   1702          		}
   1703          		else {						/* Any object is already existing */
   1704          			if (mode & FA_CREATE_NEW)			/* Cannot create new */
   1705          				LEAVE_FF(dj.fs, FR_EXIST);
   1706          			dir = dj.dir;
   1707          			if (!dir || (dir[DIR_Attr] & (AM_RDO | AM_DIR)))	/* Cannot overwrite it (R/O or DIR) */
   1708          				LEAVE_FF(dj.fs, FR_DENIED);
   1709          			if (mode & FA_CREATE_ALWAYS) {		/* Resize it to zero on over write mode */
   1710          				cl = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);	/* Get start cluster */
   1711          				ST_WORD(dir+DIR_FstClusHI, 0);	/* cluster = 0 */
   1712          				ST_WORD(dir+DIR_FstClusLO, 0);
   1713          				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
   1714          				dj.fs->wflag = 1;
   1715          				ps = dj.fs->winsect;			/* Remove the cluster chain */
   1716          				if (cl) {
   1717          					res = remove_chain(dj.fs, cl);
   1718          					if (res) LEAVE_FF(dj.fs, res);
   1719          					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
   1720          				}
   1721          				res = move_window(dj.fs, ps);
   1722          				if (res != FR_OK) LEAVE_FF(dj.fs, res);
   1723          			}
   1724          		}
   1725          		if (mode & FA_CREATE_ALWAYS) {
   1726          			dir[DIR_Attr] = 0;					/* Reset attribute */
   1727          			ps = get_fattime();
   1728          			ST_DWORD(dir+DIR_CrtTime, ps);		/* Created time */
   1729          			dj.fs->wflag = 1;
   1730          			mode |= FA__WRITTEN;				/* Set file changed flag */
   1731          		}
   1732          	}
   1733          	/* Open an existing file */
   1734          	else {
   1735          #endif /* !_FS_READONLY */
   1736          		if (res != FR_OK) LEAVE_FF(dj.fs, res);	/* Follow failed */
   1737          		dir = dj.dir;
   1738          		if (!dir || (dir[DIR_Attr] & AM_DIR))	/* It is a directory */
   1739          			LEAVE_FF(dj.fs, FR_NO_FILE);
   1740          #if !_FS_READONLY
   1741          		if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
   1742          			LEAVE_FF(dj.fs, FR_DENIED);
   1743          	}
   1744          	fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
   1745          	fp->dir_ptr = dj.dir;
   1746          #endif
   1747          	fp->flag = mode;					/* File access mode */
   1748          	fp->org_clust =						/* File start cluster */
   1749          		((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
   1750          	fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
   1751          	fp->fptr = 0; fp->csect = 255;		/* File pointer */
   1752          	fp->dsect = 0;
   1753          	fp->fs = dj.fs; fp->id = dj.fs->id;	/* Owner file system object of the file */
   1754          
   1755          	LEAVE_FF(dj.fs, FR_OK);
   1756          }
   1757          
   1758          
   1759          
   1760          
   1761          /*-----------------------------------------------------------------------*/
   1762          /* Read File                                                             */
   1763          /*-----------------------------------------------------------------------*/
   1764          
   1765          FRESULT f_read (
   1766          	FIL *fp, 		/* Pointer to the file object */
   1767          	void *buff,		/* Pointer to data buffer */
   1768          	UINT btr,		/* Number of bytes to read */
   1769          	UINT *br		/* Pointer to number of bytes read */
   1770          )
   1771          {
   1772          	FRESULT res;
   1773          	DWORD clst, sect, remain;
   1774          	UINT rcnt, cc;
   1775          	BYTE *rbuff = buff;
   1776          
   1777          
   1778          	*br = 0;	/* Initialize bytes read */
   1779          
   1780          	res = validate(fp->fs, fp->id);					/* Check validity of the object */
   1781          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   1782          	if (fp->flag & FA__ERROR)						/* Check abort flag */
   1783          		LEAVE_FF(fp->fs, FR_INT_ERR);
   1784          	if (!(fp->flag & FA_READ)) 						/* Check access mode */
   1785          		LEAVE_FF(fp->fs, FR_DENIED);
   1786          	remain = fp->fsize - fp->fptr;
   1787          	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
   1788          
   1789          	for ( ;  btr;									/* Repeat until all data transferred */
   1790          		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
   1791          		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
   1792          			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
   1793          				clst = (fp->fptr == 0) ?			/* On the top of the file? */
   1794          					fp->org_clust : get_fat(fp->fs, fp->curr_clust);
   1795          				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
   1796          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   1797          				fp->curr_clust = clst;				/* Update current cluster */
   1798          				fp->csect = 0;						/* Reset sector offset in the cluster */
   1799          			}
   1800          			sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current sector */
   1801          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   1802          			sect += fp->csect;
   1803          			cc = btr / SS(fp->fs);					/* When remaining bytes >= sector size, */
   1804          			if (cc) {								/* Read maximum contiguous sectors directly */
   1805          				if (fp->csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   1806          					cc = fp->fs->csize - fp->csect;
   1807          				if (disk_read(fp->fs->drive, rbuff, sect, (BYTE)cc) != RES_OK)
   1808          					ABORT(fp->fs, FR_DISK_ERR);
   1809          #if !_FS_READONLY && _FS_MINIMIZE <= 2
   1810          #if _FS_TINY
   1811          				if (fp->fs->wflag && fp->fs->winsect - sect < cc)		/* Replace one of the read sectors with cached data if it contains a dirty sector */
   1812          					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
   1813          #else
   1814          				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)	/* Replace one of the read sectors with cached data if it contains a dirty sector */
   1815          					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
   1816          #endif
   1817          #endif
   1818          				fp->csect += (BYTE)cc;				/* Next sector address in the cluster */
   1819          				rcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
   1820          				continue;
   1821          			}
   1822          #if !_FS_TINY
   1823          #if !_FS_READONLY
   1824          			if (fp->flag & FA__DIRTY) {			/* Write sector I/O buffer if needed */
   1825          				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
   1826          					ABORT(fp->fs, FR_DISK_ERR);
   1827          				fp->flag &= ~FA__DIRTY;
   1828          			}
   1829          #endif
   1830          			if (fp->dsect != sect) {			/* Fill sector buffer with file data */
   1831          				if (disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
   1832          					ABORT(fp->fs, FR_DISK_ERR);
   1833          			}
   1834          #endif
   1835          			fp->dsect = sect;
   1836          			fp->csect++;							/* Next sector address in the cluster */
   1837          		}
   1838          		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
   1839          		if (rcnt > btr) rcnt = btr;
   1840          #if _FS_TINY
   1841          		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
   1842          			ABORT(fp->fs, FR_DISK_ERR);
   1843          		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   1844          #else
   1845          		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   1846          #endif
   1847          	}
   1848          
   1849          	LEAVE_FF(fp->fs, FR_OK);
   1850          }
   1851          
   1852          
   1853          
   1854          
   1855          #if !_FS_READONLY
   1856          /*-----------------------------------------------------------------------*/
   1857          /* Write File                                                            */
   1858          /*-----------------------------------------------------------------------*/
   1859          
   1860          FRESULT f_write (
   1861          	FIL *fp,			/* Pointer to the file object */
   1862          	const void *buff,	/* Pointer to the data to be written */
   1863          	UINT btw,			/* Number of bytes to write */
   1864          	UINT *bw			/* Pointer to number of bytes written */
   1865          )
   1866          {
   1867          	FRESULT res;
   1868          	DWORD clst, sect;
   1869          	UINT wcnt, cc;
   1870          	const BYTE *wbuff = buff;
   1871          
   1872          
   1873          	*bw = 0;	/* Initialize bytes written */
   1874          
   1875          	res = validate(fp->fs, fp->id);					/* Check validity of the object */
   1876          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   1877          	if (fp->flag & FA__ERROR)						/* Check abort flag */
   1878          		LEAVE_FF(fp->fs, FR_INT_ERR);
   1879          	if (!(fp->flag & FA_WRITE))						/* Check access mode */
   1880          		LEAVE_FF(fp->fs, FR_DENIED);
   1881          	if (fp->fsize + btw < fp->fsize) btw = 0;		/* File size cannot reach 4GB */
   1882          
   1883          	for ( ;  btw;									/* Repeat until all data transferred */
   1884          		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
   1885          		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
   1886          			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
   1887          				if (fp->fptr == 0) {				/* On the top of the file? */
   1888          					clst = fp->org_clust;			/* Follow from the origin */
   1889          					if (clst == 0)					/* When there is no cluster chain, */
   1890          						fp->org_clust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
   1891          				} else {							/* Middle or end of the file */
   1892          					clst = create_chain(fp->fs, fp->curr_clust);			/* Follow or streach cluster chain */
   1893          				}
   1894          				if (clst == 0) break;				/* Could not allocate a new cluster (disk full) */
   1895          				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   1896          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   1897          				fp->curr_clust = clst;				/* Update current cluster */
   1898          				fp->csect = 0;						/* Reset sector address in the cluster */
   1899          			}
   1900          #if _FS_TINY
   1901          			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write back data buffer prior to following direct transfer */
   1902          				ABORT(fp->fs, FR_DISK_ERR);
   1903          #else
   1904          			if (fp->flag & FA__DIRTY) {		/* Write back data buffer prior to following direct transfer */
   1905          				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
   1906          					ABORT(fp->fs, FR_DISK_ERR);
   1907          				fp->flag &= ~FA__DIRTY;
   1908          			}
   1909          #endif
   1910          			sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current sector */
   1911          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   1912          			sect += fp->csect;
   1913          			cc = btw / SS(fp->fs);					/* When remaining bytes >= sector size, */
   1914          			if (cc) {								/* Write maximum contiguous sectors directly */
   1915          				if (fp->csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   1916          					cc = fp->fs->csize - fp->csect;
   1917          				if (disk_write(fp->fs->drive, wbuff, sect, (BYTE)cc) != RES_OK)
   1918          					ABORT(fp->fs, FR_DISK_ERR);
   1919          #if _FS_TINY
   1920          				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets dirty by the direct write */
   1921          					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
   1922          					fp->fs->wflag = 0;
   1923          				}
   1924          #else
   1925          				if (fp->dsect - sect < cc) {		/* Refill sector cache if it gets dirty by the direct write */
   1926          					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
   1927          					fp->flag &= ~FA__DIRTY;
   1928          				}
   1929          #endif
   1930          				fp->csect += (BYTE)cc;				/* Next sector address in the cluster */
   1931          				wcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
   1932          				continue;
   1933          			}
   1934          #if _FS_TINY
   1935          			if (fp->fptr >= fp->fsize) {			/* Avoid silly buffer filling at growing edge */
   1936          				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
   1937          				fp->fs->winsect = sect;
   1938          			}
   1939          #else
   1940          			if (fp->dsect != sect) {				/* Fill sector buffer with file data */
   1941          				if (fp->fptr < fp->fsize &&
   1942          					disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
   1943          						ABORT(fp->fs, FR_DISK_ERR);
   1944          			}
   1945          #endif
   1946          			fp->dsect = sect;
   1947          			fp->csect++;							/* Next sector address in the cluster */
   1948          		}
   1949          		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Put partial sector into file I/O buffer */
   1950          		if (wcnt > btw) wcnt = btw;
   1951          #if _FS_TINY
   1952          		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
   1953          			ABORT(fp->fs, FR_DISK_ERR);
   1954          		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   1955          		fp->fs->wflag = 1;
   1956          #else
   1957          		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   1958          		fp->flag |= FA__DIRTY;
   1959          #endif
   1960          	}
   1961          
   1962          	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
   1963          	fp->flag |= FA__WRITTEN;						/* Set file changed flag */
   1964          
   1965          	LEAVE_FF(fp->fs, FR_OK);
   1966          }
   1967          
   1968          
   1969          
   1970          
   1971          /*-----------------------------------------------------------------------*/
   1972          /* Synchronize the File Object                                           */
   1973          /*-----------------------------------------------------------------------*/
   1974          
   1975          FRESULT f_sync (
   1976          	FIL *fp		/* Pointer to the file object */
   1977          )
   1978          {
   1979          	FRESULT res;
   1980          	DWORD tim;
   1981          	BYTE *dir;
   1982          
   1983          
   1984          	res = validate(fp->fs, fp->id);		/* Check validity of the object */
   1985          	if (res == FR_OK) {
   1986          		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
   1987          #if !_FS_TINY	/* Write-back dirty buffer */
   1988          			if (fp->flag & FA__DIRTY) {
   1989          				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
   1990          					LEAVE_FF(fp->fs, FR_DISK_ERR);
   1991          				fp->flag &= ~FA__DIRTY;
   1992          			}
   1993          #endif
   1994          			/* Update the directory entry */
   1995          			res = move_window(fp->fs, fp->dir_sect);
   1996          			if (res == FR_OK) {
   1997          				dir = fp->dir_ptr;
   1998          				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
   1999          				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
   2000          				ST_WORD(dir+DIR_FstClusLO, fp->org_clust);	/* Update start cluster */
   2001          				ST_WORD(dir+DIR_FstClusHI, fp->org_clust >> 16);
   2002          				tim = get_fattime();			/* Updated time */
   2003          				ST_DWORD(dir+DIR_WrtTime, tim);
   2004          				fp->flag &= ~FA__WRITTEN;
   2005          				fp->fs->wflag = 1;
   2006          				res = sync(fp->fs);
   2007          			}
   2008          		}
   2009          	}
   2010          
   2011          	LEAVE_FF(fp->fs, res);
   2012          }
   2013          
   2014          #endif /* !_FS_READONLY */
   2015          
   2016          
   2017          
   2018          
   2019          /*-----------------------------------------------------------------------*/
   2020          /* Close File                                                            */
   2021          /*-----------------------------------------------------------------------*/
   2022          
   2023          FRESULT f_close (
   2024          	FIL *fp		/* Pointer to the file object to be closed */
   2025          )
   2026          {
   2027          	FRESULT res;
   2028          
   2029          
   2030          #if _FS_READONLY
   2031          	res = validate(fp->fs, fp->id);
   2032          	if (res == FR_OK) fp->fs = NULL;
   2033          	LEAVE_FF(fp->fs, res);
   2034          #else
   2035          	res = f_sync(fp);
   2036          	if (res == FR_OK) fp->fs = NULL;
   2037          	return res;
   2038          #endif
   2039          }
   2040          
   2041          
   2042          
   2043          
   2044          /*-----------------------------------------------------------------------*/
   2045          /* Change Current Drive/Directory                                        */
   2046          /*-----------------------------------------------------------------------*/
   2047          
   2048          #if _FS_RPATH
   2049          
   2050          FRESULT f_chdrive (
   2051          	BYTE drv		/* Drive number */
   2052          )
   2053          {
   2054          	if (drv >= _DRIVES) return FR_INVALID_DRIVE;
   2055          
   2056          	Drive = drv;
   2057          
   2058          	return FR_OK;
   2059          }
   2060          
   2061          
   2062          
   2063          
   2064          FRESULT f_chdir (
   2065          	const XCHAR *path	/* Pointer to the directory path */
   2066          )
   2067          {
   2068          	FRESULT res;
   2069          	DIR dj;
   2070          	NAMEBUF(sfn, lfn);
   2071          	BYTE *dir;
   2072          
   2073          
   2074          	res = chk_mounted(&path, &dj.fs, 0);
   2075          	if (res == FR_OK) {
   2076          		INITBUF(dj, sfn, lfn);
   2077          		res = follow_path(&dj, path);		/* Follow the file path */
   2078          		if (res == FR_OK) {					/* Follow completed */
   2079          			dir = dj.dir;					/* Pointer to the entry */
   2080          			if (!dir) {
   2081          				dj.fs->cdir = 0;			/* No entry (root dir) */
   2082          			} else {
   2083          				if (dir[DIR_Attr] & AM_DIR)	/* Reached to the dir */
   2084          					dj.fs->cdir = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
   2085          				else
   2086          					res = FR_NO_PATH;		/* Could not reach the dir (it is a file) */
   2087          			}
   2088          		}
   2089          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   2090          	}
   2091          
   2092          	LEAVE_FF(dj.fs, res);
   2093          }
   2094          
   2095          #endif
   2096          
   2097          
   2098          
   2099          #if _FS_MINIMIZE <= 2
   2100          /*-----------------------------------------------------------------------*/
   2101          /* Seek File R/W Pointer                                                 */
   2102          /*-----------------------------------------------------------------------*/
   2103          
   2104          FRESULT f_lseek (
   2105          	FIL *fp,		/* Pointer to the file object */
   2106          	DWORD ofs		/* File pointer from top of file */
   2107          )
   2108          {
   2109          	FRESULT res;
   2110          	DWORD clst, bcs, nsect, ifptr;
   2111          
   2112          
   2113          	res = validate(fp->fs, fp->id);		/* Check validity of the object */
   2114          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   2115          	if (fp->flag & FA__ERROR)			/* Check abort flag */
   2116          		LEAVE_FF(fp->fs, FR_INT_ERR);
   2117          	if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
   2118          #if !_FS_READONLY
   2119          		 && !(fp->flag & FA_WRITE)
   2120          #endif
   2121          		) ofs = fp->fsize;
   2122          
   2123          	ifptr = fp->fptr;
   2124          	fp->fptr = nsect = 0; fp->csect = 255;
   2125          	if (ofs > 0) {
   2126          		bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
   2127          		if (ifptr > 0 &&
   2128          			(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
   2129          			fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
   2130          			ofs -= fp->fptr;
   2131          			clst = fp->curr_clust;
   2132          		} else {									/* When seek to back cluster, */
   2133          			clst = fp->org_clust;					/* start from the first cluster */
   2134          #if !_FS_READONLY
   2135          			if (clst == 0) {						/* If no cluster chain, create a new chain */
   2136          				clst = create_chain(fp->fs, 0);
   2137          				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   2138          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2139          				fp->org_clust = clst;
   2140          			}
   2141          #endif
   2142          			fp->curr_clust = clst;
   2143          		}
   2144          		if (clst != 0) {
   2145          			while (ofs > bcs) {						/* Cluster following loop */
   2146          #if !_FS_READONLY
   2147          				if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
   2148          					clst = create_chain(fp->fs, clst);	/* Force streached if in write mode */
   2149          					if (clst == 0) {				/* When disk gets full, clip file size */
   2150          						ofs = bcs; break;
   2151          					}
   2152          				} else
   2153          #endif
   2154          					clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
   2155          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2156          				if (clst <= 1 || clst >= fp->fs->max_clust) ABORT(fp->fs, FR_INT_ERR);
   2157          				fp->curr_clust = clst;
   2158          				fp->fptr += bcs;
   2159          				ofs -= bcs;
   2160          			}
   2161          			fp->fptr += ofs;
   2162          			fp->csect = (BYTE)(ofs / SS(fp->fs));	/* Sector offset in the cluster */
   2163          			if (ofs % SS(fp->fs)) {
   2164          				nsect = clust2sect(fp->fs, clst);	/* Current sector */
   2165          				if (!nsect) ABORT(fp->fs, FR_INT_ERR);
   2166          				nsect += fp->csect;
   2167          				fp->csect++;
   2168          			}
   2169          		}
   2170          	}
   2171          	if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {
   2172          #if !_FS_TINY
   2173          #if !_FS_READONLY
   2174          		if (fp->flag & FA__DIRTY) {			/* Write-back dirty buffer if needed */
   2175          			if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
   2176          				ABORT(fp->fs, FR_DISK_ERR);
   2177          			fp->flag &= ~FA__DIRTY;
   2178          		}
   2179          #endif
   2180          		if (disk_read(fp->fs->drive, fp->buf, nsect, 1) != RES_OK)
   2181          			ABORT(fp->fs, FR_DISK_ERR);
   2182          #endif
   2183          		fp->dsect = nsect;
   2184          	}
   2185          #if !_FS_READONLY
   2186          	if (fp->fptr > fp->fsize) {			/* Set changed flag if the file size is extended */
   2187          		fp->fsize = fp->fptr;
   2188          		fp->flag |= FA__WRITTEN;
   2189          	}
   2190          #endif
   2191          
   2192          	LEAVE_FF(fp->fs, res);
   2193          }
   2194          
   2195          
   2196          
   2197          
   2198          #if _FS_MINIMIZE <= 1
   2199          /*-----------------------------------------------------------------------*/
   2200          /* Create a Directroy Object                                             */
   2201          /*-----------------------------------------------------------------------*/
   2202          
   2203          FRESULT f_opendir (
   2204          	DIR *dj,			/* Pointer to directory object to create */
   2205          	const XCHAR *path	/* Pointer to the directory path */
   2206          )
   2207          {
   2208          	FRESULT res;
   2209          	NAMEBUF(sfn, lfn);
   2210          	BYTE *dir;
   2211          
   2212          
   2213          	res = chk_mounted(&path, &dj->fs, 0);
   2214          	if (res == FR_OK) {
   2215          		INITBUF((*dj), sfn, lfn);
   2216          		res = follow_path(dj, path);			/* Follow the path to the directory */
   2217          		if (res == FR_OK) {						/* Follow completed */
   2218          			dir = dj->dir;
   2219          			if (dir) {							/* It is not the root dir */
   2220          				if (dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
   2221          					dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
   2222          				} else {						/* The object is not a directory */
   2223          					res = FR_NO_PATH;
   2224          				}
   2225          			}
   2226          			if (res == FR_OK) {
   2227          				dj->id = dj->fs->id;
   2228          				res = dir_seek(dj, 0);			/* Rewind dir */
   2229          			}
   2230          		}
   2231          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   2232          	}
   2233          
   2234          	LEAVE_FF(dj->fs, res);
   2235          }
   2236          
   2237          
   2238          
   2239          
   2240          /*-----------------------------------------------------------------------*/
   2241          /* Read Directory Entry in Sequense                                      */
   2242          /*-----------------------------------------------------------------------*/
   2243          
   2244          FRESULT f_readdir (
   2245          	DIR *dj,			/* Pointer to the open directory object */
   2246          	FILINFO *fno		/* Pointer to file information to return */
   2247          )
   2248          {
   2249          	FRESULT res;
   2250          	NAMEBUF(sfn, lfn);
   2251          
   2252          
   2253          	res = validate(dj->fs, dj->id);			/* Check validity of the object */
   2254          	if (res == FR_OK) {
   2255          		INITBUF((*dj), sfn, lfn);
   2256          		if (!fno) {
   2257          			res = dir_seek(dj, 0);
   2258          		} else {
   2259          			res = dir_read(dj);
   2260          			if (res == FR_NO_FILE) {
   2261          				dj->sect = 0;
   2262          				res = FR_OK;
   2263          			}
   2264          			if (res == FR_OK) {				/* A valid entry is found */
   2265          				get_fileinfo(dj, fno);		/* Get the object information */
   2266          				res = dir_next(dj, FALSE);	/* Increment index for next */
   2267          				if (res == FR_NO_FILE) {
   2268          					dj->sect = 0;
   2269          					res = FR_OK;
   2270          				}
   2271          			}
   2272          		}
   2273          	}
   2274          
   2275          	LEAVE_FF(dj->fs, res);
   2276          }
   2277          
   2278          
   2279          
   2280          #if _FS_MINIMIZE == 0
   2281          /*-----------------------------------------------------------------------*/
   2282          /* Get File Status                                                       */
   2283          /*-----------------------------------------------------------------------*/
   2284          
   2285          FRESULT f_stat (
   2286          	const XCHAR *path,	/* Pointer to the file path */
   2287          	FILINFO *fno		/* Pointer to file information to return */
   2288          )
   2289          {
   2290          	FRESULT res;
   2291          	DIR dj;
   2292          	NAMEBUF(sfn, lfn);
   2293          
   2294          
   2295          	res = chk_mounted(&path, &dj.fs, 0);
   2296          	if (res == FR_OK) {
   2297          		INITBUF(dj, sfn, lfn);
   2298          		res = follow_path(&dj, path);	/* Follow the file path */
   2299          		if (res == FR_OK) {				/* Follwo completed */
   2300          			if (dj.dir)	/* Found an object */
   2301          				get_fileinfo(&dj, fno);
   2302          			else		/* It is root dir */
   2303          				res = FR_INVALID_NAME;
   2304          		}
   2305          	}
   2306          
   2307          	LEAVE_FF(dj.fs, res);
   2308          }
   2309          
   2310          
   2311          
   2312          #if !_FS_READONLY
   2313          /*-----------------------------------------------------------------------*/
   2314          /* Get Number of Free Clusters                                           */
   2315          /*-----------------------------------------------------------------------*/
   2316          
   2317          FRESULT f_getfree (
   2318          	const XCHAR *path,	/* Pointer to the logical drive number (root dir) */
   2319          	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
   2320          	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
   2321          )
   2322          {
   2323          	FRESULT res;
   2324          	DWORD n, clst, sect, stat;
   2325          	UINT i;
   2326          	BYTE fat, *p;
   2327          
   2328          
   2329          	/* Get drive number */
   2330          	res = chk_mounted(&path, fatfs, 0);
   2331          	if (res != FR_OK) LEAVE_FF(*fatfs, res);
   2332          
   2333          	/* If number of free cluster is valid, return it without cluster scan. */
   2334          	if ((*fatfs)->free_clust <= (*fatfs)->max_clust - 2) {
   2335          		*nclst = (*fatfs)->free_clust;
   2336          		LEAVE_FF(*fatfs, FR_OK);
   2337          	}
   2338          
   2339          	/* Get number of free clusters */
   2340          	fat = (*fatfs)->fs_type;
   2341          	n = 0;
   2342          	if (fat == FS_FAT12) {
   2343          		clst = 2;
   2344          		do {
   2345          			stat = get_fat(*fatfs, clst);
   2346          			if (stat == 0xFFFFFFFF) LEAVE_FF(*fatfs, FR_DISK_ERR);
   2347          			if (stat == 1) LEAVE_FF(*fatfs, FR_INT_ERR);
   2348          			if (stat == 0) n++;
   2349          		} while (++clst < (*fatfs)->max_clust);
   2350          	} else {
   2351          		clst = (*fatfs)->max_clust;
   2352          		sect = (*fatfs)->fatbase;
   2353          		i = 0; p = 0;
   2354          		do {
   2355          			if (!i) {
   2356          				res = move_window(*fatfs, sect++);
   2357          				if (res != FR_OK)
   2358          					LEAVE_FF(*fatfs, res);
   2359          				p = (*fatfs)->win;
   2360          				i = SS(*fatfs);
   2361          			}
   2362          			if (fat == FS_FAT16) {
   2363          				if (LD_WORD(p) == 0) n++;
   2364          				p += 2; i -= 2;
   2365          			} else {
   2366          				if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
   2367          				p += 4; i -= 4;
   2368          			}
   2369          		} while (--clst);
   2370          	}
   2371          	(*fatfs)->free_clust = n;
   2372          	if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
   2373          	*nclst = n;
   2374          
   2375          	LEAVE_FF(*fatfs, FR_OK);
   2376          }
   2377          
   2378          
   2379          
   2380          
   2381          /*-----------------------------------------------------------------------*/
   2382          /* Truncate File                                                         */
   2383          /*-----------------------------------------------------------------------*/
   2384          
   2385          FRESULT f_truncate (
   2386          	FIL *fp		/* Pointer to the file object */
   2387          )
   2388          {
   2389          	FRESULT res;
   2390          	DWORD ncl;
   2391          
   2392          
   2393          	res = validate(fp->fs, fp->id);		/* Check validity of the object */
   2394          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   2395          	if (fp->flag & FA__ERROR)			/* Check abort flag */
   2396          		LEAVE_FF(fp->fs, FR_INT_ERR);
   2397          	if (!(fp->flag & FA_WRITE))			/* Check access mode */
   2398          		LEAVE_FF(fp->fs, FR_DENIED);
   2399          
   2400          	if (fp->fsize > fp->fptr) {
   2401          		fp->fsize = fp->fptr;	/* Set file size to current R/W point */
   2402          		fp->flag |= FA__WRITTEN;
   2403          		if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
   2404          			res = remove_chain(fp->fs, fp->org_clust);
   2405          			fp->org_clust = 0;
   2406          		} else {				/* When truncate a part of the file, remove remaining clusters */
   2407          			ncl = get_fat(fp->fs, fp->curr_clust);
   2408          			res = FR_OK;
   2409          			if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
   2410          			if (ncl == 1) res = FR_INT_ERR;
   2411          			if (res == FR_OK && ncl < fp->fs->max_clust) {
   2412          				res = put_fat(fp->fs, fp->curr_clust, 0x0FFFFFFF);
   2413          				if (res == FR_OK) res = remove_chain(fp->fs, ncl);
   2414          			}
   2415          		}
   2416          	}
   2417          	if (res != FR_OK) fp->flag |= FA__ERROR;
   2418          
   2419          	LEAVE_FF(fp->fs, res);
   2420          }
   2421          
   2422          
   2423          
   2424          
   2425          /*-----------------------------------------------------------------------*/
   2426          /* Delete a File or Directory                                            */
   2427          /*-----------------------------------------------------------------------*/
   2428          
   2429          FRESULT f_unlink (
   2430          	const XCHAR *path		/* Pointer to the file or directory path */
   2431          )
   2432          {
   2433          	FRESULT res;
   2434          	DIR dj, sdj;
   2435          	NAMEBUF(sfn, lfn);
   2436          	BYTE *dir;
   2437          	DWORD dclst;
   2438          
   2439          
   2440          	res = chk_mounted(&path, &dj.fs, 1);
   2441          	if (res != FR_OK) LEAVE_FF(dj.fs, res);
   2442          
   2443          	INITBUF(dj, sfn, lfn);
   2444          	res = follow_path(&dj, path);			/* Follow the file path */
   2445          	if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   2446          		res = FR_INVALID_NAME;
   2447          	if (res != FR_OK) LEAVE_FF(dj.fs, res); /* Follow failed */
   2448          
   2449          	dir = dj.dir;
   2450          	if (!dir)								/* Is it the root directory? */
   2451          		LEAVE_FF(dj.fs, FR_INVALID_NAME);
   2452          	if (dir[DIR_Attr] & AM_RDO)				/* Is it a R/O object? */
   2453          		LEAVE_FF(dj.fs, FR_DENIED);
   2454          	dclst = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
   2455          
   2456          	if (dir[DIR_Attr] & AM_DIR) {			/* It is a sub-directory */
   2457          		if (dclst < 2) LEAVE_FF(dj.fs, FR_INT_ERR);
   2458          		mem_cpy(&sdj, &dj, sizeof(DIR));	/* Check if the sub-dir is empty or not */
   2459          		sdj.sclust = dclst;
   2460          		res = dir_seek(&sdj, 2);
   2461          		if (res != FR_OK) LEAVE_FF(dj.fs, res);
   2462          		res = dir_read(&sdj);
   2463          		if (res == FR_OK) res = FR_DENIED;	/* Not empty sub-dir */
   2464          		if (res != FR_NO_FILE) LEAVE_FF(dj.fs, res);
   2465          	}
   2466          
   2467          	res = dir_remove(&dj);					/* Remove directory entry */
   2468          	if (res == FR_OK) {
   2469          		if (dclst)
   2470          			res = remove_chain(dj.fs, dclst);	/* Remove the cluster chain */
   2471          		if (res == FR_OK) res = sync(dj.fs);
   2472          	}
   2473          
   2474          	LEAVE_FF(dj.fs, res);
   2475          }
   2476          
   2477          
   2478          
   2479          
   2480          /*-----------------------------------------------------------------------*/
   2481          /* Create a Directory                                                    */
   2482          /*-----------------------------------------------------------------------*/
   2483          
   2484          FRESULT f_mkdir (
   2485          	const XCHAR *path		/* Pointer to the directory path */
   2486          )
   2487          {
   2488          	FRESULT res;
   2489          	DIR dj;
   2490          	NAMEBUF(sfn, lfn);
   2491          	BYTE *dir, n;
   2492          	DWORD dsect, dclst, pclst, tim;
   2493          
   2494          
   2495          	res = chk_mounted(&path, &dj.fs, 1);
   2496          	if (res != FR_OK) LEAVE_FF(dj.fs, res);
   2497          
   2498          	INITBUF(dj, sfn, lfn);
   2499          	res = follow_path(&dj, path);			/* Follow the file path */
   2500          	if (res == FR_OK) res = FR_EXIST;		/* Any file or directory is already existing */
   2501          	if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
   2502          		res = FR_INVALID_NAME;
   2503          	if (res != FR_NO_FILE)					/* Any error occured */
   2504          		LEAVE_FF(dj.fs, res);
   2505          
   2506          	dclst = create_chain(dj.fs, 0);			/* Allocate a new cluster for new directory table */
   2507          	res = FR_OK;
   2508          	if (dclst == 0) res = FR_DENIED;
   2509          	if (dclst == 1) res = FR_INT_ERR;
   2510          	if (dclst == 0xFFFFFFFF) res = FR_DISK_ERR;
   2511          	if (res == FR_OK)
   2512          		res = move_window(dj.fs, 0);
   2513          	if (res != FR_OK) LEAVE_FF(dj.fs, res);
   2514          	dsect = clust2sect(dj.fs, dclst);
   2515          
   2516          	dir = dj.fs->win;						/* Initialize the new directory table */
   2517          	mem_set(dir, 0, SS(dj.fs));
   2518          	mem_set(dir+DIR_Name, ' ', 8+3);		/* Create "." entry */
   2519          	dir[DIR_Name] = '.';
   2520          	dir[DIR_Attr] = AM_DIR;
   2521          	tim = get_fattime();
   2522          	ST_DWORD(dir+DIR_WrtTime, tim);
   2523          	ST_WORD(dir+DIR_FstClusLO, dclst);
   2524          	ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
   2525          	mem_cpy(dir+32, dir, 32); 			/* Create ".." entry */
   2526          	dir[33] = '.';
   2527          	pclst = dj.sclust;
   2528          	if (dj.fs->fs_type == FS_FAT32 && pclst == dj.fs->dirbase)
   2529          		pclst = 0;
   2530          	ST_WORD(dir+32+DIR_FstClusLO, pclst);
   2531          	ST_WORD(dir+32+DIR_FstClusHI, pclst >> 16);
   2532          	for (n = 0; n < dj.fs->csize; n++) {	/* Write dot entries and clear left sectors */
   2533          		dj.fs->winsect = dsect++;
   2534          		dj.fs->wflag = 1;
   2535          		res = move_window(dj.fs, 0);
   2536          		if (res) LEAVE_FF(dj.fs, res);
   2537          		mem_set(dir, 0, SS(dj.fs));
   2538          	}
   2539          
   2540          	res = dir_register(&dj);
   2541          	if (res != FR_OK) {
   2542          		remove_chain(dj.fs, dclst);
   2543          	} else {
   2544          		dir = dj.dir;
   2545          		dir[DIR_Attr] = AM_DIR;					/* Attribute */
   2546          		ST_DWORD(dir+DIR_WrtTime, tim);			/* Crated time */
   2547          		ST_WORD(dir+DIR_FstClusLO, dclst);		/* Table start cluster */
   2548          		ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
   2549          		dj.fs->wflag = 1;
   2550          		res = sync(dj.fs);
   2551          	}
   2552          
   2553          	LEAVE_FF(dj.fs, res);
   2554          }
   2555          
   2556          
   2557          
   2558          
   2559          /*-----------------------------------------------------------------------*/
   2560          /* Change File Attribute                                                 */
   2561          /*-----------------------------------------------------------------------*/
   2562          
   2563          FRESULT f_chmod (
   2564          	const XCHAR *path,	/* Pointer to the file path */
   2565          	BYTE value,			/* Attribute bits */
   2566          	BYTE mask			/* Attribute mask to change */
   2567          )
   2568          {
   2569          	FRESULT res;
   2570          	DIR dj;
   2571          	NAMEBUF(sfn, lfn);
   2572          	BYTE *dir;
   2573          
   2574          
   2575          	res = chk_mounted(&path, &dj.fs, 1);
   2576          	if (res == FR_OK) {
   2577          		INITBUF(dj, sfn, lfn);
   2578          		res = follow_path(&dj, path);		/* Follow the file path */
   2579          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   2580          			res = FR_INVALID_NAME;
   2581          		if (res == FR_OK) {
   2582          			dir = dj.dir;
   2583          			if (!dir) {						/* Is it a root directory? */
   2584          				res = FR_INVALID_NAME;
   2585          			} else {						/* File or sub directory */
   2586          				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
   2587          				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
   2588          				dj.fs->wflag = 1;
   2589          				res = sync(dj.fs);
   2590          			}
   2591          		}
   2592          	}
   2593          
   2594          	LEAVE_FF(dj.fs, res);
   2595          }
   2596          
   2597          
   2598          
   2599          
   2600          /*-----------------------------------------------------------------------*/
   2601          /* Change Timestamp                                                      */
   2602          /*-----------------------------------------------------------------------*/
   2603          
   2604          FRESULT f_utime (
   2605          	const XCHAR *path,	/* Pointer to the file/directory name */
   2606          	const FILINFO *fno	/* Pointer to the timestamp to be set */
   2607          )
   2608          {
   2609          	FRESULT res;
   2610          	DIR dj;
   2611          	NAMEBUF(sfn, lfn);
   2612          	BYTE *dir;
   2613          
   2614          
   2615          	res = chk_mounted(&path, &dj.fs, 1);
   2616          	if (res == FR_OK) {
   2617          		INITBUF(dj, sfn, lfn);
   2618          		res = follow_path(&dj, path);	/* Follow the file path */
   2619          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   2620          			res = FR_INVALID_NAME;
   2621          		if (res == FR_OK) {
   2622          			dir = dj.dir;
   2623          			if (!dir) {				/* Root directory */
   2624          				res = FR_INVALID_NAME;
   2625          			} else {				/* File or sub-directory */
   2626          				ST_WORD(dir+DIR_WrtTime, fno->ftime);
   2627          				ST_WORD(dir+DIR_WrtDate, fno->fdate);
   2628          				dj.fs->wflag = 1;
   2629          				res = sync(dj.fs);
   2630          			}
   2631          		}
   2632          	}
   2633          
   2634          	LEAVE_FF(dj.fs, res);
   2635          }
   2636          
   2637          
   2638          
   2639          
   2640          /*-----------------------------------------------------------------------*/
   2641          /* Rename File/Directory                                                 */
   2642          /*-----------------------------------------------------------------------*/
   2643          
   2644          FRESULT f_rename (
   2645          	const XCHAR *path_old,	/* Pointer to the old name */
   2646          	const XCHAR *path_new	/* Pointer to the new name */
   2647          )
   2648          {
   2649          	FRESULT res;
   2650          	DIR dj_old, dj_new;
   2651          	NAMEBUF(sfn, lfn);
   2652          	BYTE buf[21], *dir;
   2653          	DWORD dw;
   2654          
   2655          
   2656          	INITBUF(dj_old, sfn, lfn);
   2657          	res = chk_mounted(&path_old, &dj_old.fs, 1);
   2658          	if (res == FR_OK) {
   2659          		dj_new.fs = dj_old.fs;
   2660          		res = follow_path(&dj_old, path_old);	/* Check old object */
   2661          		if (_FS_RPATH && res == FR_OK && (dj_old.fn[NS] & NS_DOT))
   2662          			res = FR_INVALID_NAME;
   2663          	}
   2664          	if (res != FR_OK) LEAVE_FF(dj_old.fs, res);	/* The old object is not found */
   2665          
   2666          	if (!dj_old.dir) LEAVE_FF(dj_old.fs, FR_NO_FILE);	/* Is root dir? */
   2667          	mem_cpy(buf, dj_old.dir+DIR_Attr, 21);		/* Save the object information */
   2668          
   2669          	mem_cpy(&dj_new, &dj_old, sizeof(DIR));
   2670          	res = follow_path(&dj_new, path_new);		/* Check new object */
   2671          	if (res == FR_OK) res = FR_EXIST;			/* The new object name is already existing */
   2672          	if (res == FR_NO_FILE) { 					/* Is it a valid path and no name collision? */
   2673          		res = dir_register(&dj_new);			/* Register the new object */
   2674          		if (res == FR_OK) {
   2675          			dir = dj_new.dir;					/* Copy object information into new entry */
   2676          			mem_cpy(dir+13, buf+2, 19);
   2677          			dir[DIR_Attr] = buf[0] | AM_ARC;
   2678          			dj_old.fs->wflag = 1;
   2679          			if (dir[DIR_Attr] & AM_DIR) {		/* Update .. entry in the directory if needed */
   2680          				dw = clust2sect(dj_new.fs, (DWORD)LD_WORD(dir+DIR_FstClusHI) | LD_WORD(dir+DIR_FstClusLO));
   2681          				if (!dw) {
   2682          					res = FR_INT_ERR;
   2683          				} else {
   2684          					res = move_window(dj_new.fs, dw);
   2685          					dir = dj_new.fs->win+32;
   2686          					if (res == FR_OK && dir[1] == '.') {
   2687          						dw = (dj_new.fs->fs_type == FS_FAT32 && dj_new.sclust == dj_new.fs->dirbase) ? 0 : dj_new.sclust;
   2688          						ST_WORD(dir+DIR_FstClusLO, dw);
   2689          						ST_WORD(dir+DIR_FstClusHI, dw >> 16);
   2690          						dj_new.fs->wflag = 1;
   2691          					}
   2692          				}
   2693          			}
   2694          			if (res == FR_OK) {
   2695          				res = dir_remove(&dj_old);			/* Remove old entry */
   2696          				if (res == FR_OK)
   2697          					res = sync(dj_old.fs);
   2698          			}
   2699          		}
   2700          	}
   2701          
   2702          	LEAVE_FF(dj_old.fs, res);
   2703          }
   2704          
   2705          #endif /* !_FS_READONLY */
   2706          #endif /* _FS_MINIMIZE == 0 */
   2707          #endif /* _FS_MINIMIZE <= 1 */
   2708          #endif /* _FS_MINIMIZE <= 2 */
   2709          
   2710          
   2711          
   2712          /*-----------------------------------------------------------------------*/
   2713          /* Forward data to the stream directly (Available on only _FS_TINY cfg)  */
   2714          /*-----------------------------------------------------------------------*/
   2715          #if _USE_FORWARD && _FS_TINY
   2716          
   2717          FRESULT f_forward (
   2718          	FIL *fp, 						/* Pointer to the file object */
   2719          	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
   2720          	UINT btr,						/* Number of bytes to forward */
   2721          	UINT *bf						/* Pointer to number of bytes forwarded */
   2722          )
   2723          {
   2724          	FRESULT res;
   2725          	DWORD remain, clst, sect;
   2726          	UINT rcnt;
   2727          
   2728          
   2729          	*bf = 0;
   2730          
   2731          	res = validate(fp->fs, fp->id);					/* Check validity of the object */
   2732          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   2733          	if (fp->flag & FA__ERROR)						/* Check error flag */
   2734          		LEAVE_FF(fp->fs, FR_INT_ERR);
   2735          	if (!(fp->flag & FA_READ))						/* Check access mode */
   2736          		LEAVE_FF(fp->fs, FR_DENIED);
   2737          
   2738          	remain = fp->fsize - fp->fptr;
   2739          	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
   2740          
   2741          	for ( ;  btr && (*func)(NULL, 0);				/* Repeat until all data transferred or stream becomes busy */
   2742          		fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
   2743          		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
   2744          			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
   2745          				clst = (fp->fptr == 0) ?			/* On the top of the file? */
   2746          					fp->org_clust : get_fat(fp->fs, fp->curr_clust);
   2747          				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
   2748          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2749          				fp->curr_clust = clst;				/* Update current cluster */
   2750          				fp->csect = 0;						/* Reset sector address in the cluster */
   2751          			}
   2752          			fp->csect++;							/* Next sector address in the cluster */
   2753          		}
   2754          		sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current data sector */
   2755          		if (!sect) ABORT(fp->fs, FR_INT_ERR);
   2756          		sect += fp->csect - 1;
   2757          		if (move_window(fp->fs, sect))				/* Move sector window */
   2758          			ABORT(fp->fs, FR_DISK_ERR);
   2759          		fp->dsect = sect;
   2760          		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
   2761          		if (rcnt > btr) rcnt = btr;
   2762          		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
   2763          		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
   2764          	}
   2765          
   2766          	LEAVE_FF(fp->fs, FR_OK);
   2767          }
   2768          #endif /* _USE_FORWARD */
   2769          
   2770          
   2771          
   2772          #if _USE_MKFS && !_FS_READONLY
   2773          /*-----------------------------------------------------------------------*/
   2774          /* Create File System on the Drive                                       */
   2775          /*-----------------------------------------------------------------------*/
   2776          #define N_ROOTDIR	512			/* Multiple of 32 and <= 2048 */
   2777          #define N_FATS		1			/* 1 or 2 */
   2778          #define MAX_SECTOR	131072000UL	/* Maximum partition size */
   2779          #define MIN_SECTOR	2000UL		/* Minimum partition size */
   2780          
   2781          
   2782          FRESULT f_mkfs (
   2783          	BYTE drv,			/* Logical drive number */
   2784          	BYTE partition,		/* Partitioning rule 0:FDISK, 1:SFD */
   2785          	WORD allocsize		/* Allocation unit size [bytes] */
   2786          )
   2787          {
   2788          	static const DWORD sstbl[] = { 2048000, 1024000, 512000, 256000, 128000, 64000, 32000, 16000, 8000, 4000,   0 };
   2789          	static const WORD cstbl[] =  {   32768,   16384,   8192,   4096,   2048, 16384,  8192,  4096, 2048, 1024, 512 };
   2790          	BYTE fmt, m, *tbl;
   2791          	DWORD b_part, b_fat, b_dir, b_data;		/* Area offset (LBA) */
   2792          	DWORD n_part, n_rsv, n_fat, n_dir;		/* Area size */
   2793          	DWORD n_clst, d, n;
   2794          	WORD as;
   2795          	FATFS *fs;
   2796          	DSTATUS stat;
   2797          
   2798          
   2799          	/* Check validity of the parameters */
   2800          	if (drv >= _DRIVES) return FR_INVALID_DRIVE;
   2801          	if (partition >= 2) return FR_MKFS_ABORTED;
   2802          
   2803          	/* Check mounted drive and clear work area */
   2804          	fs = FatFs[drv];
   2805          	if (!fs) return FR_NOT_ENABLED;
   2806          	fs->fs_type = 0;
   2807          	drv = LD2PD(drv);
   2808          
   2809          	/* Get disk statics */
   2810          	stat = disk_initialize(drv);
   2811          	if (stat & STA_NOINIT) return FR_NOT_READY;
   2812          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   2813          #if _MAX_SS != 512						/* Get disk sector size */
   2814          	if (disk_ioctl(drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
   2815          		|| SS(fs) > _MAX_SS)
   2816          		return FR_MKFS_ABORTED;
   2817          #endif
   2818          	if (disk_ioctl(drv, GET_SECTOR_COUNT, &n_part) != RES_OK || n_part < MIN_SECTOR)
   2819          		return FR_MKFS_ABORTED;
   2820          	if (n_part > MAX_SECTOR) n_part = MAX_SECTOR;
   2821          	b_part = (!partition) ? 63 : 0;		/* Boot sector */
   2822          	n_part -= b_part;
   2823          	for (d = 512; d <= 32768U && d != allocsize; d <<= 1) ;	/* Check validity of the allocation unit size */
   2824          	if (d != allocsize) allocsize = 0;
   2825          	if (!allocsize) {					/* Auto selection of cluster size */
   2826          		d = n_part;
   2827          		for (as = SS(fs); as > 512U; as >>= 1) d >>= 1;
   2828          		for (n = 0; d < sstbl[n]; n++) ;
   2829          		allocsize = cstbl[n];
   2830          	}
   2831          	if (allocsize < SS(fs)) allocsize = SS(fs);
   2832          
   2833          	allocsize /= SS(fs);		/* Number of sectors per cluster */
   2834          
   2835          	/* Pre-compute number of clusters and FAT type */
   2836          	n_clst = n_part / allocsize;
   2837          	fmt = FS_FAT12;
   2838          	if (n_clst >= 0xFF5) fmt = FS_FAT16;
   2839          	if (n_clst >= 0xFFF5) fmt = FS_FAT32;
   2840          
   2841          	/* Determine offset and size of FAT structure */
   2842          	switch (fmt) {
   2843          	case FS_FAT12:
   2844          		n_fat = ((n_clst * 3 + 1) / 2 + 3 + SS(fs) - 1) / SS(fs);
   2845          		n_rsv = 1 + partition;
   2846          		n_dir = N_ROOTDIR * 32 / SS(fs);
   2847          		break;
   2848          	case FS_FAT16:
   2849          		n_fat = ((n_clst * 2) + 4 + SS(fs) - 1) / SS(fs);
   2850          		n_rsv = 1 + partition;
   2851          		n_dir = N_ROOTDIR * 32 / SS(fs);
   2852          		break;
   2853          	default:
   2854          		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
   2855          		n_rsv = 33 - partition;
   2856          		n_dir = 0;
   2857          	}
   2858          	b_fat = b_part + n_rsv;			/* FATs start sector */
   2859          	b_dir = b_fat + n_fat * N_FATS;	/* Directory start sector */
   2860          	b_data = b_dir + n_dir;			/* Data start sector */
   2861          
   2862          	/* Align data start sector to erase block boundary (for flash memory media) */
   2863          	if (disk_ioctl(drv, GET_BLOCK_SIZE, &n) != RES_OK) return FR_MKFS_ABORTED;
   2864          	n = (b_data + n - 1) & ~(n - 1);
   2865          	n_fat += (n - b_data) / N_FATS;
   2866          	/* b_dir and b_data are no longer used below */
   2867          
   2868          	/* Determine number of cluster and final check of validity of the FAT type */
   2869          	n_clst = (n_part - n_rsv - n_fat * N_FATS - n_dir) / allocsize;
   2870          	if (   (fmt == FS_FAT16 && n_clst < 0xFF5)
   2871          		|| (fmt == FS_FAT32 && n_clst < 0xFFF5))
   2872          		return FR_MKFS_ABORTED;
   2873          
   2874          	/* Create partition table if needed */
   2875          	if (!partition) {
   2876          		DWORD n_disk = b_part + n_part;
   2877          
   2878          		mem_set(fs->win, 0, SS(fs));
   2879          		tbl = fs->win+MBR_Table;
   2880          		ST_DWORD(tbl, 0x00010180);		/* Partition start in CHS */
   2881          		if (n_disk < 63UL * 255 * 1024) {	/* Partition end in CHS */
   2882          			n_disk = n_disk / 63 / 255;
   2883          			tbl[7] = (BYTE)n_disk;
   2884          			tbl[6] = (BYTE)((n_disk >> 2) | 63);
   2885          		} else {
   2886          			ST_WORD(&tbl[6], 0xFFFF);
   2887          		}
   2888          		tbl[5] = 254;
   2889          		if (fmt != FS_FAT32)			/* System ID */
   2890          			tbl[4] = (n_part < 0x10000) ? 0x04 : 0x06;
   2891          		else
   2892          			tbl[4] = 0x0c;
   2893          		ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
   2894          		ST_DWORD(tbl+12, n_part);		/* Partition size in LBA */
   2895          		ST_WORD(tbl+64, 0xAA55);		/* Signature */
   2896          		if (disk_write(drv, fs->win, 0, 1) != RES_OK)
   2897          			return FR_DISK_ERR;
   2898          		partition = 0xF8;
   2899          	} else {
   2900          		partition = 0xF0;
   2901          	}
   2902          
   2903          	/* Create boot record */
   2904          	tbl = fs->win;								/* Clear buffer */
   2905          	mem_set(tbl, 0, SS(fs));
   2906          	ST_DWORD(tbl+BS_jmpBoot, 0x90FEEB);			/* Boot code (jmp $, nop) */
   2907          	ST_WORD(tbl+BPB_BytsPerSec, SS(fs));		/* Sector size */
   2908          	tbl[BPB_SecPerClus] = (BYTE)allocsize;		/* Sectors per cluster */
   2909          	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);			/* Reserved sectors */
   2910          	tbl[BPB_NumFATs] = N_FATS;					/* Number of FATs */
   2911          	ST_WORD(tbl+BPB_RootEntCnt, SS(fs) / 32 * n_dir); /* Number of rootdir entries */
   2912          	if (n_part < 0x10000) {						/* Number of total sectors */
   2913          		ST_WORD(tbl+BPB_TotSec16, n_part);
   2914          	} else {
   2915          		ST_DWORD(tbl+BPB_TotSec32, n_part);
   2916          	}
   2917          	tbl[BPB_Media] = partition;					/* Media descripter */
   2918          	ST_WORD(tbl+BPB_SecPerTrk, 63);				/* Number of sectors per track */
   2919          	ST_WORD(tbl+BPB_NumHeads, 255);				/* Number of heads */
   2920          	ST_DWORD(tbl+BPB_HiddSec, b_part);			/* Hidden sectors */
   2921          	n = get_fattime();							/* Use current time as a VSN */
   2922          	if (fmt != FS_FAT32) {
   2923          		ST_DWORD(tbl+BS_VolID, n);				/* Volume serial number */
   2924          		ST_WORD(tbl+BPB_FATSz16, n_fat);		/* Number of secters per FAT */
   2925          		tbl[BS_DrvNum] = 0x80;					/* Drive number */
   2926          		tbl[BS_BootSig] = 0x29;					/* Extended boot signature */
   2927          		mem_cpy(tbl+BS_VolLab, "NO NAME    FAT     ", 19);	/* Volume lavel, FAT signature */
   2928          	} else {
   2929          		ST_DWORD(tbl+BS_VolID32, n);			/* Volume serial number */
   2930          		ST_DWORD(tbl+BPB_FATSz32, n_fat);		/* Number of secters per FAT */
   2931          		ST_DWORD(tbl+BPB_RootClus, 2);			/* Root directory cluster (2) */
   2932          		ST_WORD(tbl+BPB_FSInfo, 1);				/* FSInfo record offset (bs+1) */
   2933          		ST_WORD(tbl+BPB_BkBootSec, 6);			/* Backup boot record offset (bs+6) */
   2934          		tbl[BS_DrvNum32] = 0x80;				/* Drive number */
   2935          		tbl[BS_BootSig32] = 0x29;				/* Extended boot signature */
   2936          		mem_cpy(tbl+BS_VolLab32, "NO NAME    FAT32   ", 19);	/* Volume lavel, FAT signature */
   2937          	}
   2938          	ST_WORD(tbl+BS_55AA, 0xAA55);				/* Signature */
   2939          	if (SS(fs) > 512U) {
   2940          		ST_WORD(tbl+SS(fs)-2, 0xAA55);
   2941          	}
   2942          	if (disk_write(drv, tbl, b_part+0, 1) != RES_OK)
   2943          		return FR_DISK_ERR;
   2944          	if (fmt == FS_FAT32)
   2945          		disk_write(drv, tbl, b_part+6, 1);
   2946          
   2947          	/* Initialize FAT area */
   2948          	for (m = 0; m < N_FATS; m++) {
   2949          		mem_set(tbl, 0, SS(fs));		/* 1st sector of the FAT  */
   2950          		if (fmt != FS_FAT32) {
   2951          			n = (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
   2952          			n |= partition;
   2953          			ST_DWORD(tbl, n);				/* Reserve cluster #0-1 (FAT12/16) */
   2954          		} else {
   2955          			ST_DWORD(tbl+0, 0xFFFFFFF8);	/* Reserve cluster #0-1 (FAT32) */
   2956          			ST_DWORD(tbl+4, 0xFFFFFFFF);
   2957          			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
   2958          		}
   2959          		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
   2960          			return FR_DISK_ERR;
   2961          		mem_set(tbl, 0, SS(fs));		/* Following FAT entries are filled by zero */
   2962          		for (n = 1; n < n_fat; n++) {
   2963          			if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
   2964          				return FR_DISK_ERR;
   2965          		}
   2966          	}
   2967          
   2968          	/* Initialize Root directory */
   2969          	m = (BYTE)((fmt == FS_FAT32) ? allocsize : n_dir);
   2970          	do {
   2971          		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
   2972          			return FR_DISK_ERR;
   2973          	} while (--m);
   2974          
   2975          	/* Create FSInfo record if needed */
   2976          	if (fmt == FS_FAT32) {
   2977          		ST_WORD(tbl+BS_55AA, 0xAA55);
   2978          		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
   2979          		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
   2980          		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);
   2981          		ST_DWORD(tbl+FSI_Nxt_Free, 0xFFFFFFFF);
   2982          		disk_write(drv, tbl, b_part+1, 1);
   2983          		disk_write(drv, tbl, b_part+7, 1);
   2984          	}
   2985          
   2986          	return (disk_ioctl(drv, CTRL_SYNC, (void*)NULL) == RES_OK) ? FR_OK : FR_DISK_ERR;
   2987          }
   2988          
   2989          #endif /* _USE_MKFS && !_FS_READONLY */
   2990          
   2991          
   2992          
   2993          
   2994          #if _USE_STRFUNC
   2995          /*-----------------------------------------------------------------------*/
   2996          /* Get a string from the file                                            */
   2997          /*-----------------------------------------------------------------------*/
   2998          char* f_gets (
   2999          	char* buff,	/* Pointer to the string buffer to read */
   3000          	int len,	/* Size of string buffer */
   3001          	FIL* fil	/* Pointer to the file object */
   3002          )
   3003          {
   3004          	int i = 0;
   3005          	char *p = buff;
   3006          	UINT rc;
   3007          
   3008          
   3009          	while (i < len - 1) {			/* Read bytes until buffer gets filled */
   3010          		f_read(fil, p, 1, &rc);
   3011          		if (rc != 1) break;			/* Break when no data to read */
   3012          #if _USE_STRFUNC >= 2
   3013          		if (*p == '\r') continue;	/* Strip '\r' */
   3014          #endif
   3015          		i++;
   3016          		if (*p++ == '\n') break;	/* Break when reached end of line */
   3017          	}
   3018          	*p = 0;
   3019          	return i ? buff : NULL;			/* When no data read (eof or error), return with error. */
   3020          }
   3021          
   3022          
   3023          
   3024          #if !_FS_READONLY
   3025          #include <stdarg.h>
   3026          /*-----------------------------------------------------------------------*/
   3027          /* Put a character to the file                                           */
   3028          /*-----------------------------------------------------------------------*/
   3029          int f_putc (
   3030          	int chr,	/* A character to be output */
   3031          	FIL* fil	/* Ponter to the file object */
   3032          )
   3033          {
   3034          	UINT bw;
   3035          	char c;
   3036          
   3037          
   3038          #if _USE_STRFUNC >= 2
   3039          	if (chr == '\n') f_putc ('\r', fil);	/* LF -> CRLF conversion */
   3040          #endif
   3041          	if (!fil) {	/* Special value may be used to switch the destination to any other device */
   3042          	/*	put_console(chr);	*/
   3043          		return chr;
   3044          	}
   3045          	c = (char)chr;
   3046          	f_write(fil, &c, 1, &bw);	/* Write a byte to the file */
   3047          	return bw ? chr : EOF;		/* Return the result */
   3048          }
   3049          
   3050          
   3051          
   3052          
   3053          /*-----------------------------------------------------------------------*/
   3054          /* Put a string to the file                                              */
   3055          /*-----------------------------------------------------------------------*/
   3056          int f_puts (
   3057          	const char* str,	/* Pointer to the string to be output */
   3058          	FIL* fil			/* Pointer to the file object */
   3059          )
   3060          {
   3061          	int n;
   3062          
   3063          
   3064          	for (n = 0; *str; str++, n++) {
   3065          		if (f_putc(*str, fil) == EOF) return EOF;
   3066          	}
   3067          	return n;
   3068          }
   3069          
   3070          
   3071          
   3072          
   3073          /*-----------------------------------------------------------------------*/
   3074          /* Put a formatted string to the file                                    */
   3075          /*-----------------------------------------------------------------------*/
   3076          int f_printf (
   3077          	FIL* fil,			/* Pointer to the file object */
   3078          	const char* str,	/* Pointer to the format string */
   3079          	...					/* Optional arguments... */
   3080          )
   3081          {
   3082          	va_list arp;
   3083          	UCHAR c, f, r;
   3084          	ULONG val;
   3085          	char s[16];
   3086          	int i, w, res, cc;
   3087          
   3088          
   3089          	va_start(arp, str);
   3090          
   3091          	for (cc = res = 0; cc != EOF; res += cc) {
   3092          		c = *str++;
   3093          		if (c == 0) break;			/* End of string */
   3094          		if (c != '%') {				/* Non escape cahracter */
   3095          			cc = f_putc(c, fil);
   3096          			if (cc != EOF) cc = 1;
   3097          			continue;
   3098          		}
   3099          		w = f = 0;
   3100          		c = *str++;
   3101          		if (c == '0') {				/* Flag: '0' padding */
   3102          			f = 1; c = *str++;
   3103          		}
   3104          		while (c >= '0' && c <= '9') {	/* Precision */
   3105          			w = w * 10 + (c - '0');
   3106          			c = *str++;
   3107          		}
   3108          		if (c == 'l') {				/* Prefix: Size is long int */
   3109          			f |= 2; c = *str++;
   3110          		}
   3111          		if (c == 's') {				/* Type is string */
   3112          			cc = f_puts(va_arg(arp, char*), fil);
   3113          			continue;
   3114          		}
   3115          		if (c == 'c') {				/* Type is character */
   3116          			cc = f_putc(va_arg(arp, int), fil);
   3117          			if (cc != EOF) cc = 1;
   3118          			continue;
   3119          		}
   3120          		r = 0;
   3121          		if (c == 'd') r = 10;		/* Type is signed decimal */
   3122          		if (c == 'u') r = 10;		/* Type is unsigned decimal */
   3123          		if (c == 'X') r = 16;		/* Type is unsigned hexdecimal */
   3124          		if (r == 0) break;			/* Unknown type */
   3125          		if (f & 2) {				/* Get the value */
   3126          			val = (ULONG)va_arg(arp, long);
   3127          		} else {
   3128          			val = (c == 'd') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int);
   3129          		}
   3130          		/* Put numeral string */
   3131          		if (c == 'd') {
   3132          			if (val & 0x80000000) {
   3133          				val = 0 - val;
   3134          				f |= 4;
   3135          			}
   3136          		}
   3137          		i = sizeof(s) - 1; s[i] = 0;
   3138          		do {
   3139          			c = (UCHAR)(val % r + '0');
   3140          			if (c > '9') c += 7;
   3141          			s[--i] = c;
   3142          			val /= r;
   3143          		} while (i && val);
   3144          		if (i && (f & 4)) s[--i] = '-';
   3145          		w = sizeof(s) - 1 - w;
   3146          		while (i && i > w) s[--i] = (f & 1) ? '0' : ' ';
   3147          		cc = f_puts(&s[i], fil);
   3148          	}
   3149          
   3150          	va_end(arp);
   3151          	return (cc == EOF) ? cc : res;
   3152          }
   3153          
   3154          #endif /* !_FS_READONLY */
   3155          #endif /* _USE_STRFUNC */

   Maximum stack usage in bytes:

     Function     .cstack
     --------     -------
     check_fs          8
     chk_chr           0
     chk_mounted      16
     clust2sect        0
     create_chain     24
     create_name      40
     dir_find         16
     dir_next         24
     dir_read          8
     dir_register     16
     dir_remove        8
     dir_seek         16
     f_chmod          56
     f_close           8
     f_getfree        32
     f_gets           32
     f_lseek          24
     f_mkdir          72
     f_mkfs           64
     f_mount           0
     f_open           72
     f_opendir        24
     f_printf         48
     f_putc           16
     f_puts           16
     f_read           32
     f_readdir        24
     f_rename        112
     f_stat           56
     f_sync           16
     f_truncate       16
     f_unlink         80
     f_utime          56
     f_write          32
     follow_path      16
     get_fat          24
     get_fileinfo      8
     mem_cmp           8
     mem_cpy           0
     mem_set           0
     move_window      24
     put_fat          24
     remove_chain     24
     sync             16
     validate          8


   Section sizes:

     Function/Label                    Bytes
     --------------                    -----
     FatFs                                8
     Fsid                                 2
     mem_cpy                             20
     mem_set                             16
     mem_cmp                             32
     chk_chr                             20
     move_window                        116
     sync                               214
     get_fat                            254
     put_fat                            292
     remove_chain                       112
     create_chain                       180
     clust2sect                          24
     dir_seek                           176
     dir_next                           310
     dir_find                            98
     dir_read                            92
     dir_register                       136
     dir_remove                          48
     create_name                        384
     get_fileinfo                       138
     follow_path                        168
     check_fs                           120
     chk_mounted                        732
     validate                            44
     f_mount                             52
     f_open                             432
     f_read                             490
     f_write                            546
     f_sync                             188
     f_close                             24
     f_lseek                            478
     f_opendir                          118
     f_readdir                           94
     f_stat                              70
     f_getfree                          270
     f_truncate                         172
     f_unlink                           204
     f_mkdir                            484
     f_chmod                             88
     f_utime                             92
     f_rename                           318
     f_mkfs                            1720
     sstbl                               44
     cstbl                               24
     f_gets                              78
     f_putc                              42
     f_puts                              46
     f_printf                           442
     ?<Constant " \"*+,[=]|\177">        12
     ?<Constant "NO NAME    FAT     ">   20
     ?<Constant "NO NAME    FAT32   ">   20

 
     10 bytes in section .bss
    120 bytes in section .rodata
 10 174 bytes in section .text
 
 10 174 bytes of CODE  memory
    120 bytes of CONST memory
     10 bytes of DATA  memory

Errors: none
Warnings: none
