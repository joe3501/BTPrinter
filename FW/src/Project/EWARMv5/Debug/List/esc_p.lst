###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     08/Dec/2015  18:37:55 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\BT Printer\FW\src\App\esc_p.c                         #
#    Command line =  "E:\BT Printer\FW\src\App\esc_p.c" -D DEBUG_VER -lcN     #
#                    "E:\BT Printer\FW\src\Project\EWARMv5\Debug\List\" -o    #
#                    "E:\BT Printer\FW\src\Project\EWARMv5\Debug\Obj\"        #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 5.4\arm\INC\DLib_Config_Full.h" -I "E:\BT      #
#                    Printer\FW\src\Project\EWARMv5\..\" -I "E:\BT            #
#                    Printer\FW\src\Project\EWARMv5\..\..\App\" -I "E:\BT     #
#                    Printer\FW\src\Project\EWARMv5\..\..\Drivers\" -I        #
#                    "E:\BT Printer\FW\src\Project\EWARMv5\..\..\FatFs\" -I   #
#                    "E:\BT Printer\FW\src\Project\EWARMv5\..\..\Lib\inc\"    #
#                    -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS\uC-C #
#                    PU\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS #
#                    \uC-LIB\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\.. #
#                    \uCOS\uCOS-II\Ports\" -I "E:\BT                          #
#                    Printer\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Source #
#                    \" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS\u #
#                    C-Probe\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\.. #
#                    \usb_lib\" -I "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 5.4\arm\INC\" -Ol                              #
#    List file    =  E:\BT Printer\FW\src\Project\EWARMv5\Debug\List\esc_p.ls #
#                    t                                                        #
#    Object file  =  E:\BT Printer\FW\src\Project\EWARMv5\Debug\Obj\esc_p.o   #
#                                                                             #
#                                                                             #
###############################################################################

E:\BT Printer\FW\src\App\esc_p.c
      1          #include "hw_platform.h"
      2          #include "ringbuffer.h"
      3          #include <string.h>
      4          #include "basic_fun.h"
      5          #include "Terminal_Para.h"
      6          #include "DotFill.h"
      7          #include <assert.h>
      8          #include "Font.h"
      9          #include "uart.h"
     10          #include "TP.h"
     11          //======================================================================================================
     12          //======================================================================================================
     13          //======================================================================================================
     14          //#define NULL	(0x00)
     15          #define SOH		(0x01)
     16          #define STX		(0x02)
     17          #define ETX		(0x03)
     18          #define EOT		(0x04)
     19          #define ENQ		(0x05)
     20          #define ACK		(0x06)
     21          #define BEL		(0x07)
     22          #define BS		(0x08)
     23          #define HT		(0x09)
     24          #define LF		(0x0a)
     25          #define VT		(0x0b)
     26          #define FF		(0x0c)
     27          #define CR		(0x0d)
     28          #define SO		(0x0e)
     29          #define SI		(0x0f)
     30          #define DLE		(0x10)
     31          #define DC1		(0x11)
     32          #define DC2		(0x12)
     33          #define DC3		(0x13)
     34          #define DC4		(0x14)
     35          #define NAK		(0x15)
     36          #define SYN		(0x16)
     37          #define ETB		(0x17)
     38          #define ESC_CAN		(0x18)
     39          #define EM		(0x19)
     40          #define SUB		(0x1a)
     41          #define ESC		(0x1b)
     42          #define FS		(0x1c)
     43          #define GS		(0x1d)
     44          #define RS		(0x1e)
     45          #define US		(0x1f)
     46          #define SP		(0x20)
     47          
     48          ESC_P_STS_T  esc_sts[MAX_PRINT_CHANNEL];
     49          signed char	 current_channel;		//当前正在处理的通道
     50          #ifdef DEBUG_VER
     51          extern unsigned short debug_buffer[];
     52          extern unsigned int debug_cnt;
     53          #endif
     54          //倍宽转换
     55          static uint8_t double_byte(uint8_t* out,uint8_t c)
     56          {
     57          	int i,tmp;
     58          	out[0] = 0;
     59          	out[1] = 0;
     60          	for (i = 0,tmp=0x80; i < 4; i++)
     61          	{
     62          		out[0] |= (c&tmp)>>i;
     63          		out[0] |= (c&tmp)>>(i+1);
     64                          tmp >>= 1;
     65          	}
     66                  
     67                  c <<= 4; 
     68                  for (i = 0,tmp=0x80; i < 4; i++)
     69          	{
     70          		out[1] |= (c&tmp)>>i;
     71          		out[1] |= (c&tmp)>>(i+1);
     72                          tmp >>= 1;
     73          	}
     74                  
     75          	return 2;
     76          }
     77          
     78          extern void esc_p_init(unsigned int n)
     79          {
     80          	uint8_t i;
     81          	//----chang
     82          
     83          	esc_sts[n].international_character_set = 0;    // english
     84          	esc_sts[n].character_code_page = g_param.character_code_page;
     85          	esc_sts[n].h_motionunit = 0;
     86          	esc_sts[n].v_motionunit = 0;
     87          	esc_sts[n].prt_on = 0;
     88          	esc_sts[n].larger = 0;
     89          #ifdef ASCII9X24
     90          	esc_sts[n].font_en = FONT_B_WIDTH;	// 字体
     91          #else
     92          	esc_sts[n].font_en = FONT_A_WIDTH;	// 字体
     93          #endif
     94          	esc_sts[n].font_cn = FONT_CN_A_WIDTH;	// 字体
     95          	esc_sts[n].bold = 0;		// 粗体
     96          	esc_sts[n].italic = 0;		// 斜体
     97          	esc_sts[n].double_strike=0;//重叠打印
     98          	esc_sts[n].underline = 0;	// 下划线
     99          	esc_sts[n].revert = 0;		// 反白显示
    100          	esc_sts[n].rotate = 0;
    101          	esc_sts[n].start_dot = 0;
    102          	esc_sts[n].smoothing_mode = 0;	// 平滑模式
    103          	esc_sts[n].dot_minrow = ARRAY_SIZE(esc_sts[n].dot[0]);
    104          	memset(esc_sts[n].dot, 0 ,sizeof(esc_sts[n].dot));
    105          	for(i=0; i<8; i++)
    106          	{
    107          		esc_sts[n].tab[i] = 9+8*i;
    108          	}
    109          	esc_sts[n].linespace = 30;
    110          	esc_sts[n].charspace = 0;
    111          	esc_sts[n].align = 0;
    112          	esc_sts[n].leftspace = 0;
    113          	esc_sts[n].print_width=LineDot;
    114          	esc_sts[n].upside_down=0;//倒置
    115          	esc_sts[n].barcode_height = 50;
    116          	esc_sts[n].barcode_width = 2;
    117          	esc_sts[n].barcode_leftspace = 0;
    118          	esc_sts[n].barcode_char_pos = 0;//不显示
    119          	esc_sts[n].barcode_font = 0;
    120          	esc_sts[n].userdefine_char = 0;
    121          	esc_sts[n].asb_mode=0;
    122          
    123          	esc_sts[n].chinese_mode = 1;
    124          	esc_sts[n].bitmap_flag = 0;
    125          
    126          	if(esc_sts[n].status4 == 0)
    127          	{
    128          		esc_sts[n].status4=0x12;
    129          	}
    130          }
    131          extern esc_init(void)
    132          {
    133          	int i;
    134          	for (i = 0; i < MAX_PRINT_CHANNEL; i++)
    135          	{
    136          		esc_p_init(i);
    137          	}
    138          	current_channel = -1;
    139          }
    140          
    141          extern void esc_p(void)
    142          {
    143          	uint8_t cmd;
    144          	uint16_t  i,j,cnt,off;
    145          	uint8_t chs[25],n;
    146                  unsigned char tmp[LineDot/8];
    147          
    148          	switch(cmd=Getchar())
    149          	{
    150          	case LF:	// line feed
    151          		PrintCurrentBuffer(0);
    152          		break;
    153          	case CR:      // carry return
    154          		//PrintCurrentBuffer(0);
    155          		break;
    156          #if 1
    157          	case ESC:		// ESC
    158          		chs[0] = Getchar();
    159          		switch (chs[0])
    160          		{
    161          		case SP:
    162          			chs[1] = Getchar();
    163          			//ESC SP n 设置字符右间距    //note  暂时还不理解右间距与字符间距有什么区别，先与字符间距同样处理
    164          			esc_sts[current_channel].charspace = chs[1];
    165          			break;
    166          		case '!':
    167          			chs[1] = Getchar();
    168          			//ESC ! n  设置打印机模式
    169          			//根据n 的值设置字符打印模式
    170          			//Bit	Off/On	Hex	功   能
    171          			//0	-	-	暂无定义
    172          			//1	off	0x00	解除反白模式
    173          			//	on	0x02	设置反白模式
    174          			//2	off	0x00	解除斜体模式
    175          			//	on	0x04	设置斜体模式
    176          			//3	-	-	暂无定义
    177          			//4	off	0x00	解除倍高模式
    178          			//	on	0x10	设置倍高模式
    179          			//5	off	0x00	解除倍宽模式
    180          			//	on	0x20	设置倍宽模式
    181          			//6	-	-	暂无定义
    182          			//7	off	0x00	解除下划线模式
    183          			//	on	0x80	设置下划线模式
    184          			esc_sts[current_channel].revert = ((chs[1]&(1<<1))?1:0);
    185          			esc_sts[current_channel].italic = ((chs[1]&(1<<2))?1:0);
    186          			esc_sts[current_channel].larger |= ((chs[1]&(1<<4))?1:0);
    187          			esc_sts[current_channel].larger |= ((chs[1]&(1<<5))?1:0)<<4;
    188          			esc_sts[current_channel].underline |= (((chs[1]&(1<<7))?1:0)|0x80);
    189          			break;
    190          		case '$':
    191          			//ESC $ nl nh  设置绝对打印位置
    192          			chs[1] = Getchar();
    193          			chs[2] = Getchar();
    194          			if (((chs[2]<<8)|chs[1]) < LineDot)
    195          			{
    196          				esc_sts[current_channel].start_dot = ((chs[2]<<8)|chs[1]);
    197          			}
    198          			break;
    199          		case 0x2D:
    200          			//ESC - n	选择/取消下划线模式  低半字节的低2位表示下划线宽度  0： 不改变  1：一点行   2:2点行
    201          			//								 高半字节的低2位表示是否需要下划线  0： 取消  else: 选择
    202          			chs[1] = Getchar();
    203          			if ((chs[1] == 0)|| (chs[1] == 1) || (chs[1] == 2) || (chs[1] == 48)|| (chs[1] == 49) || (chs[1] == 50))
    204          			{
    205          				if(chs[1]&0x03)
    206          				{
    207          					esc_sts[current_channel].underline &= ~0x03;
    208          					esc_sts[current_channel].underline |= (chs[1]&0x03);
    209          				}
    210          
    211          				if (chs[1]&0x30)
    212          				{
    213          					esc_sts[current_channel].underline |= 0x80;
    214          				}
    215          				else
    216          				{
    217          					esc_sts[current_channel].underline &= ~0x80;
    218          				}
    219          			}
    220          			break;
    221          		case '2':
    222          			//ESC 2   设置默认行间距
    223          			esc_sts[current_channel].linespace = 30;	//此数据是否是默认的3.75mm间距还有待测试！！！
    224          			break;
    225          		case '3':
    226          			//ESC 3 n  设置默认行间距
    227          			chs[1] = Getchar();
    228          			esc_sts[current_channel].linespace = chs[1];
    229          			break;
    230          		case '@':
    231          			//ESC @  初始化打印机
    232          			esc_p_init(current_channel);
    233          			//PrintBufToZero();		//这条命令挺奇葩的，小度掌柜经常卡住就是这个原因，不需要清除打印缓冲区
    234          			break;
    235          		case 'D':
    236          			//ESC D n1....nk NULL 设置横向跳格位置
    237          			memset(esc_sts[current_channel].tab,0,8);
    238          			for (i = 0;i < 8;i++)
    239          			{
    240          				chs[1+i] = Getchar();
    241          				if (chs[1+i] == 0)
    242          				{
    243          					break;
    244          				}
    245          				else
    246          				{
    247          					if (i == 0)
    248          					{
    249          						esc_sts[current_channel].tab[i] = chs[1+i];
    250          					}
    251          					else
    252          					{
    253          						if (chs[1+i] > chs[i])
    254          						{
    255          							esc_sts[current_channel].tab[i] = chs[1+i];
    256          						}
    257          					}	
    258          				}
    259          			}
    260          
    261          			if (i == 8)
    262          			{
    263          				chs[1+i] = Getchar();	//0
    264          			}
    265          
    266          			break;
    267          		case 'J':
    268          			//ESC J n 打印并走纸
    269          			chs[1] = Getchar();
    270          			PrintCurrentBuffer_0(0);
    271          			TPFeedLine(chs[1]*esc_sts[current_channel].v_motionunit);
    272          			esc_sts[current_channel].start_dot = 0;
    273          			break;
    274          		case 'a':
    275          			//ESC a n  选择对齐方式
    276          			/*n的取值与对齐方式对应关系如下：
    277          			n		对齐方式
    278          			0，48	左对齐
    279          			1，49	中间对齐
    280          			2，50	右对齐*/
    281          			chs[1] = Getchar();
    282          			if ((chs[1] == 0)|| (chs[1] == 1) || (chs[1] == 2) || (chs[1] == 48) || (chs[1] == 49) || (chs[1] == 50))
    283          			{
    284          				esc_sts[current_channel].align = chs[1]&0x03;
    285          			}
    286          			break;
    287          		case 'c':
    288          			chs[1] = Getchar();
    289          			if (chs[1] == '5')
    290          			{
    291          				//ESC c 5 n 允许/禁止按键
    292          				chs[2] = Getchar();
    293          				//@todo.... 设置按键禁止标志位
    294          
    295          			}
    296          			else if (chs[1] =='3')
    297          			{
    298          				//ESC c 3 n Select paper sensor(s) to output paper-end signal
    299          				chs[2] = Getchar();
    300          				//@todo...
    301          			}
    302          			break;
    303          		case 'd':
    304          			//ESC d n 打印并向前走纸n 行
    305          			chs[1] = Getchar();
    306          			esc_sts[current_channel].start_dot = 0;
    307          			PrintCurrentBuffer_0(0);
    308          			TPFeedLine(chs[1]);
    309          			break;
    310          		case 'e':
    311          			//ESC e n Print and reverse feed n lines
    312          			chs[1] = Getchar();
    313          			esc_sts[current_channel].start_dot = 0;
    314          			PrintCurrentBuffer_0(0);
    315          			//TPFeedLine(chs[1]);
    316          			//@todo...反向走纸
    317          			break;
    318          		case 'r':
    319          			//ESC r n		Select printing color
    320          			chs[1] = Getchar();
    321          			//@not support
    322          			break;
    323          		case 't':
    324          			//ESC t n		Select character code table
    325          			chs[1] = Getchar();
    326          			//@not support
    327          			break;
    328          		case 'p':
    329          			//ESC p m t1 t2 产生钱箱控制脉冲
    330          			/*输出由t1 和t2 设定的钱箱开启脉冲到由m 指定的引脚：
    331          			m	
    332          			0,48		钱箱插座的引脚2
    333          			1,49		钱箱插座的引脚5
    334          			钱箱开启脉冲高电平时间为[t1*2ms],低电平时间为[t2*2ms]
    335          			如果t2<t1,低电平时间为[t1*2ms]*/
    336          			chs[1] = Getchar();
    337          			if ((chs[1] == 0)||(chs[1] == 1)||(chs[1] == 48)||(chs[1] == 49))
    338          			{
    339          				chs[2] = Getchar();
    340          				chs[3] = Getchar();
    341          				//@todo...., 产生控制钱箱的脉冲
    342          
    343          			}
    344          			break;
    345          		case 0x27:
    346          			//ESC ’ml mh l1 h1 l2 h2 l3 h3 … li hi…  打印曲线
    347          			//ml+mh*256表示这一行需要打印的点数，后面跟的（li+hi*256）是此行内需要打印的点的位置
    348          			//实际上通过此指令可以打印位图
    349          			chs[1] = Getchar();
    350          			chs[2] = Getchar();
    351          			cnt = chs[2]<<8;
    352          			cnt |= chs[1];
    353          			memset(tmp,0,sizeof(tmp));
    354          			if (cnt<=LineDot)
    355          			{
    356          				for (i = 0; i < cnt;i++)
    357          				{
    358          					chs[1] = Getchar();
    359          					chs[2] = Getchar();
    360          					off = chs[2]<<8;
    361          					off |= chs[1];
    362          					tmp[off/8] |= (1<<(off%8)); 
    363          				}
    364          				TPPrintLine(tmp);
    365          			}
    366          			break;
    367          		case '{':
    368          			//ESC { n 打开/关闭颠倒打印模式
    369          			chs[1] = Getchar();
    370          			if (chs[1]&0x01)
    371          			{
    372          				esc_sts[current_channel].rotate = CIR_TWO_NINETY_DEGREE;
    373          			}
    374          			else
    375          			{
    376          				esc_sts[current_channel].rotate = ANTITYPE;
    377          			}
    378          			break;
    379          		case 'E':
    380          			chs[1] = Getchar();
    381          			//ESC E n
    382          			//@todo....
    383          			break;
    384          		case 'G':
    385          			chs[1] = Getchar();
    386          			//ESC G n
    387          			//@todo....
    388          			break;
    389          		case 'M':
    390          			chs[1] = Getchar();
    391          			//ESC M n
    392          			//if ((chs[1] == 0)|| (chs[1] == 1) || (chs[1] == 2) || (chs[1] == 48) || (chs[1] == 49) || (chs[1] == 50))
    393          			if ((chs[1] == 0)|| (chs[1] == 1)|| (chs[1] == 48) || (chs[1] == 49))
    394          			{
    395          				if (chs[1]&0x01)
    396          				{
    397          					esc_sts[current_channel].font_en = FONT_B_WIDTH;
    398          					esc_sts[current_channel].font_cn = FONT_CN_B_WIDTH;
    399          				}
    400          				else
    401          				{
    402          					esc_sts[current_channel].font_en = FONT_A_WIDTH;
    403          					esc_sts[current_channel].font_cn = FONT_CN_A_WIDTH;
    404          				}
    405          			}
    406          			break;
    407          		default:
    408          			break;
    409          		}
    410          		break;
    411          	case DC2:
    412          		//uint8_t chs[5];
    413          		chs[0] = cmd;
    414          		chs[1] = Getchar();
    415          		if (chs[1] == '~')
    416          		{
    417          			chs[2] = Getchar();
    418          			//DC2 ~ n设定打印浓度...
    419          			//@todo.....
    420          		}
    421          		else if (chs[1] == 'm')
    422          		{
    423          			chs[2] = Getchar();
    424          			chs[3] = Getchar();
    425          			chs[4] = Getchar();
    426          			//DC2 m s x y黑标位置检测
    427          			//@todo......
    428          		}
    429          		break;
    430          	case DC3:
    431          		//uint8_t chs[25];
    432          		chs[0] = Getchar();
    433          		switch(chs[0])
    434          		{
    435          		case 'A':
    436          			chs[1] = Getchar();
    437          			if (chs[1] == 'Q')
    438          			{
    439          				//DC3 A Q n d1 ... dn			设置蓝牙名称
    440          				chs[2] = Getchar();
    441          				if (chs[2] < 16)
    442          				{
    443          					for (i = 0; i < chs[2]; i++)
    444          					{
    445          						chs[6+i] = Getchar();
    446          					}
    447          					chs[6+i] = 0;
    448          
    449          					if (BT816_set_name(current_channel,&chs[6]) == 0)
    450          					{
    451          						memcpy(chs,"+NAME=",6);
    452          						chs[6+i] = ',';
    453          						chs[7+i] = 'O';
    454          						chs[8+i] = 'K';
    455          						chs[9+i] = 0;
    456          
    457          						PrintCurrentBuffer(0);	//先将缓冲区的内容打印出来，再打印设置字符串
    458          
    459          						memset(tmp,0,LineDot/8);
    460          						strcpy(tmp,chs);
    461          						TPPrintAsciiLine(tmp,LineDot/8);
    462          						TPFeedLine(4);
    463          					}
    464          				}
    465          			}
    466          			else if (chs[1] == 'W')
    467          			{
    468          				//DC3 A W n d1 ... dn			设置蓝牙PIN
    469          				chs[2] = Getchar();
    470          				if (chs[2] < 8)
    471          				{
    472          					for (i = 0; i < chs[2]; i++)
    473          					{
    474          						chs[5+i] = Getchar();
    475          					}
    476          					chs[5+i] = 0;
    477          
    478          					if (BT816_set_pin(current_channel,&chs[5]) == 0)
    479          					{
    480          						memcpy(chs,"+PIN=",5);
    481          						chs[5+i] = ',';
    482          						chs[6+i] = 'O';
    483          						chs[7+i] = 'K';
    484          						chs[8+i] = 0;
    485          
    486          						PrintCurrentBuffer(0);	//先将缓冲区的内容打印出来，再打印设置字符串
    487          
    488          						memset(tmp,0,LineDot/8);
    489          						strcpy(tmp,chs);
    490          						TPPrintAsciiLine(tmp,LineDot/8);
    491          						TPFeedLine(4);
    492          					}
    493          				}
    494          			}
    495          			else if (chs[1] == 'a')
    496          			{
    497          				chs[2] = Getchar();
    498          				//DC3 A a n设置蓝牙传输速率
    499          				//@todo....
    500          
    501          			}
    502          			break;
    503          		case 'B':
    504          			chs[1] = Getchar();
    505          			if (chs[1] == 'R')
    506          			{
    507          				chs[2] = Getchar();
    508          				//DC3 B R n  设定串口波特率
    509          				//@todo......
    510          			}
    511          			break;
    512          		case 'r':
    513          			//DC3  r  返回8个字节的产品ID
    514          			BT816_send_data(current_channel,"HJ_BTPr1",8);
    515          			break;
    516          		case 's':
    517          			//DC3 s  查询打印机状态
    518          			//返回1个字节
    519          			//	n=0打印机有值    n=4打印机缺纸  n=8准备打印      
    520          			//	n='L' 电压过低(5.0Volt 以下)       n='O' 电压过高(9.5Volt 以上)
    521          			//@todo...
    522          			//BT816_send_data(current_channel,&esc_sts[current_channel].status4,1);
    523          			break;
    524          		case 'L':
    525          			chs[1] = Getchar();
    526          			chs[2] = Getchar();
    527          			//DC3 L x y  设置字符间距和行间距，默认0
    528          			if (chs[1]<128)
    529          			{
    530          				esc_sts[current_channel].charspace = chs[1];
    531          			}
    532          			if (chs[2]<128)
    533          			{
    534          				esc_sts[current_channel].linespace = chs[2];
    535          			}
    536          			break;
    537          		}
    538          		break;
    539          	case FS:		// FS
    540          		chs[0] = Getchar();
    541          		if (chs[0] == 'p')
    542          		{
    543          			//FS  p  n  m 打印下载到FLASH 中的位图
    544          			//@todo....
    545          		}
    546          		else if (chs[0] == 'q')
    547          		{
    548          			//FS q n [xL xH yL yH d1...dk]1...[xL xH yL yH d1...dk]n 定义Flash 位图
    549          			//@todo....
    550          		}
    551          		break;
    552          	case GS:		// GS
    553          		chs[0] = Getchar();
    554          		switch(chs[0])
    555          		{
    556          		case 0x0c:
    557          			//GS FF  走纸到黑标
    558          			//@todo....
    559          
    560          			break;
    561          		case '!':
    562          			//GS ! n 选择字符大小
    563          			chs[1]=Getchar();
    564          			esc_sts[current_channel].larger |= ((chs[1]&(1<<4))?1:0);
    565          			esc_sts[current_channel].larger |= ((chs[1]&(1<<5))?1:0)<<4;
    566          			if (chs[1]&0x0f)
    567          			{
    568          				esc_sts[current_channel].larger |= 0x01;		//暂时只支持2倍高
    569          			}
    570          			else
    571          			{
    572          				esc_sts[current_channel].larger &= ~0x01;		
    573          			}
    574          			if (chs[1]&0xf0)
    575          			{
    576          				esc_sts[current_channel].larger |= (0x01<<4);	//暂时支持2倍宽
    577          			}
    578          			else
    579          			{
    580          				esc_sts[current_channel].larger &= ~(0x01<<4);	
    581          			}
    582          			break;
    583          		case '*':
    584          			//GS * x y d1...d(x × y × 8) 定义下载位图,此位图下载到RAM区域
    585          			//@todo....
    586          			break;
    587          		case 0x2f:
    588          			//GS  /  m 打印下载到RAM中的位图
    589          			//@todo....
    590          			break;
    591          		case 'B':
    592          			//GS  B  n 选择/ 取消黑白反显打印模式
    593          			chs[1] = Getchar();
    594          			esc_sts[current_channel].revert = (chs[1]&0x01);
    595          			break;
    596          		case 'H':
    597          			//GS  H  n 选择HRI 字符的打印位置
    598          			chs[1] = Getchar();
    599          			//@todo.....  设置HRI字符的打印位置
    600          			break;
    601          		case 'L':
    602          			//GS  L  nL  nH 设置左边距
    603          			chs[1] = Getchar();
    604          			chs[2] = Getchar();
    605          			esc_sts[current_channel].leftspace = chs[2];
    606          			esc_sts[current_channel].leftspace <<= 8;
    607          			esc_sts[current_channel].leftspace |= chs[1];
    608          			break;
    609          		case 'h':
    610          			//GS  h  n 选择条码高度
    611          			chs[1] = Getchar();
    612          			//@todo...   设置条码打印的高度
    613          			break;
    614          		case 'k':
    615          			//①GS k m d1...dk NUL②GS k m n d1...dn 打印条码
    616          			//@todo....   打印条码
    617          			chs[1] = Getchar();
    618          			if (chs[1] <= 6)
    619          			{
    620          				//第①种命令
    621          				if ((chs[1] == 0)||(chs[1] == 1))
    622          				{
    623          					for (i = 0; i < 12;i++)
    624          					{
    625          						//todo.... 接收到的数据待处理！！！
    626          						Getchar();
    627          					}
    628          				}
    629          				else if (chs[1] == 2)
    630          				{
    631          					for (i = 0; i < 13;i++)
    632          					{
    633          						//todo.... 接收到的数据待处理！！！
    634          						Getchar();
    635          					}
    636          				}
    637          				else if (chs[1] == 3)
    638          				{
    639          					for (i = 0; i < 8;i++)
    640          					{
    641          						//todo.... 接收到的数据待处理！！！
    642          						Getchar();
    643          					}
    644          				}
    645          				else
    646          				{
    647          					//todo....
    648          					do 
    649          					{
    650          						if (Getchar() == 0)
    651          						{
    652          							break;
    653          						}
    654          					} while (1);
    655          				}
    656          			}
    657          			else if ((chs[1]>=65)&&(chs[1]<=73))
    658          			{
    659          				//第②种命令
    660          				n = Getchar();
    661          				if ((chs[1] == 65)||(chs[1] == 66))
    662          				{
    663          					n = 12;
    664          				}
    665          				else if (chs[1] == 67)
    666          				{
    667          					n = 13;
    668          				}
    669          				else if (chs[1] == 68)
    670          				{
    671          					n = 8;
    672          				}
    673          
    674          				for (i = 0; i < n; i++)
    675          				{
    676          					//@todo....
    677          					Getchar();
    678          				}
    679          			}
    680          			break;
    681          		case 'v':
    682          			//GS v 0 m xL xH yL yH d1...dk 打印光栅位图
    683          			//
    684          			//@todo....
    685          			chs[1] = Getchar();
    686          			if (chs[1] == '0')
    687          			{
    688          				chs[2] = Getchar();
    689          				chs[2] = 1;
    690          				if ((chs[2]<=3)||((chs[2]>=48)&&(chs[2]<=51)))
    691          				{
    692          					chs[3] = Getchar();
    693          					chs[4] = Getchar();
    694          					chs[5] = Getchar();
    695          					chs[6] = Getchar();
    696          
    697          					//for (i = 0; i<((chs[4]*256+chs[3])*(chs[6]*256+chs[5]));i++)
    698          					//{
    699          					//	//@todo....保存光栅位图并打印
    700          					//	Getchar();
    701          					//}
    702          					for (i = 0; i < (chs[6]*256+chs[5]);i++)
    703          					{
    704          						memset(tmp,0,sizeof(tmp));
    705          						off = 0;
    706          						for (j = 0; j < (chs[4]*256+chs[3]);j++)
    707          						{
    708          							if (off<LineDot/8)
    709          							{
    710          								if (chs[2]&0x01)
    711          								{
    712          									double_byte(&tmp[off],Getchar());
    713                                                                                  debug_buffer[debug_cnt++] = tmp[off];
    714                                                                                  debug_buffer[debug_cnt++] = tmp[off+1];
    715                                                                                  off+=2;
    716                                                                                  
    717          								}
    718          								else
    719          								{
    720          									tmp[off] = Getchar();
    721          									debug_buffer[debug_cnt++] = tmp[off];
    722                                                                                  off++;
    723          								}
    724          							}
    725          							else
    726          							{
    727          								Getchar();
    728          							}
    729          						}
    730          						
    731          						TPPrintLine(tmp);
    732          						if (chs[2]&0x02)
    733          						{
    734          							TPPrintLine(tmp);
    735          						}
    736          					}
    737          				}
    738          			}
    739          			break;
    740          		case 'w':
    741          			//GS w n 设置条码宽度
    742          			chs[1] = Getchar();
    743          			//@todo....
    744          			break;
    745          		case 'N':
    746          			//GS N m e nH nL d1...dn 打印QR二维码
    747          			//@todo....
    748          			chs[1] = Getchar();
    749          			chs[2] = Getchar();
    750          			chs[3] = Getchar();
    751          			chs[4] = Getchar();
    752          			for (i = 0;i<(chs[4]*256+chs[3]);i++)
    753          			{
    754          				//@todo....
    755          				Getchar();
    756          			}
    757          			break;
    758          		case 'j':
    759          			//GS j m 即时打印条码位置
    760          			chs[1] = Getchar();
    761          			//@todo....
    762          			break;
    763          		case 'V':
    764          			//GS V m (n)  Select cut mode and cut paper
    765          			chs[1] = Getchar();
    766          			if ((chs[1] == 0) || (chs[1] == 1) || (chs[1] == 48) || (chs[1] == 49))
    767          			{
    768          				//not support
    769          			}
    770          			else if ((chs[1] == 65)||(chs[1] == 66))
    771          			{
    772          				chs[2] = Getchar();
    773          				//not support
    774          			}
    775          			break;
    776          		}
    777          		break;
    778          #endif
    779          	case ESC_CAN:
    780          		break;
    781          	default:
    782          		{
    783          			//----chang
    784          #if !defined(CHINESE_FONT)||defined (CODEPAGE)
    785          			if((cmd >= 0x20) && (cmd <= 0xff))
    786          			{
    787          				GetEnglishFont(cmd);
    788          			}
    789          #else
    790          			if((cmd >= 0x20) && (cmd <= 0x7f))
    791          			{
    792          				GetEnglishFont(cmd);
    793          			}
    794          #if defined(GBK) || defined(GB18030)
    795          			else if ((cmd >= 0x81) && (cmd <= 0xfe))
    796          			{
    797          				uint8_t chs[4];
    798          				chs[0] = cmd;
    799          				chs[1] = Getchar();
    800          #if defined(GB18030)
    801          				if ((chs[1] >= 0x30) && (chs[1] <= 0x39))
    802          #else
    803          				if (0)
    804          #endif
    805          				{
    806          					chs[2] = Getchar();
    807          					chs[3] = Getchar();
    808          					// GB18030定义的4字节扩展
    809          					if (((chs[2] >= 0x81) && (chs[2] <= 0xfe)) && ((chs[3] >= 0x30) && (chs[3] <= 0x39)))
    810          					{
    811          						GetChineseFont(chs, CHINESE_FONT_GB18030);
    812          					}
    813          					else
    814          					{
    815          						GetEnglishFont('?');
    816          						GetEnglishFont('?');
    817          						GetEnglishFont('?');
    818          						GetEnglishFont('?');
    819          					}
    820          				}
    821          				// GB13000定义的2字节扩展
    822          				else if ((chs[1] >= 0x40) && (chs[1] <= 0xfe) && (chs[1] != 0x7f))
    823          				{
    824          					GetChineseFont(chs, CHINESE_FONT_GB13000);
    825          				}
    826          				else
    827          				{
    828          					GetEnglishFont('?');
    829          					GetEnglishFont('?');
    830          				}
    831          			}
    832          #endif
    833          #endif
    834          		}
    835          
    836          	}
    837          }
    838          //======================================================================================================
    839          

   Maximum stack usage in bytes:

     Function    .cstack
     --------    -------
     double_byte     16
     esc_init         8
     esc_p          104
     esc_p_init       8
     memcpy           8
     memset           8


   Section sizes:

     Function/Label         Bytes
     --------------         -----
     memcpy                    14
     memset                    20
     esc_sts                17540
     current_channel            1
     double_byte              106
     esc_p_init               576
     esc_init                  28
     esc_p                   3968
     ??DataTable35              4
     ??DataTable36              4
     ?<Constant "+NAME=">       8
     ?<Constant "+PIN=">        8
     ?<Constant "HJ_BTPr1">    12

 
 17 541 bytes in section .bss
     28 bytes in section .rodata
  4 720 bytes in section .text
 
  4 686 bytes of CODE  memory (+ 34 bytes shared)
     28 bytes of CONST memory
 17 541 bytes of DATA  memory

Errors: none
Warnings: 7
