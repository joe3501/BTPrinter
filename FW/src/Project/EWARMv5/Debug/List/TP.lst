###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     10/Dec/2015  18:37:18 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\BT Printer\FW\src\App\TP.c                            #
#    Command line =  "E:\BT Printer\FW\src\App\TP.c" -D DEBUG_VER -lcN        #
#                    "E:\BT Printer\FW\src\Project\EWARMv5\Debug\List\" -o    #
#                    "E:\BT Printer\FW\src\Project\EWARMv5\Debug\Obj\"        #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None -I "E:\BT  #
#                    Printer\FW\src\Project\EWARMv5\..\" -I "E:\BT            #
#                    Printer\FW\src\Project\EWARMv5\..\..\App\" -I "E:\BT     #
#                    Printer\FW\src\Project\EWARMv5\..\..\Drivers\" -I        #
#                    "E:\BT Printer\FW\src\Project\EWARMv5\..\..\FatFs\" -I   #
#                    "E:\BT Printer\FW\src\Project\EWARMv5\..\..\Lib\inc\"    #
#                    -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS\uC-C #
#                    PU\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS #
#                    \uC-LIB\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\.. #
#                    \uCOS\uCOS-II\Ports\" -I "E:\BT                          #
#                    Printer\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Source #
#                    \" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS\u #
#                    C-Probe\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\.. #
#                    \usb_lib\" -I "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 5.4\arm\INC\" -Ol                              #
#    List file    =  E:\BT Printer\FW\src\Project\EWARMv5\Debug\List\TP.lst   #
#    Object file  =  E:\BT Printer\FW\src\Project\EWARMv5\Debug\Obj\TP.o      #
#                                                                             #
#                                                                             #
###############################################################################

E:\BT Printer\FW\src\App\TP.c
      1          #include "Type.h"
      2          #include "stm32f10x_lib.h" 
      3          #include "TP.h"
      4          #include "basic_fun.h"
      5          #include "print_head.h"
      6          #include "Esc_p.h"
      7          #include "uart.h"
      8          #include "Terminal_Para.h"
      9          #include "DotFill.h"
     10          #include "PaperDetect.h"
     11          #include "Event.h"
     12          #include "ThermalDetect.h"
     13          #include <string.h>
     14          #include <stdio.h>
     15          
     16          #ifdef DEBUG_VER
     17          extern unsigned char debug_buffer[];
     18          extern unsigned int debug_cnt;
     19          #endif
     20          
     21          extern   void NVIC_DisableIRQ(unsigned char	irq_channel);
     22          extern   void NVIC_EnableIRQ(unsigned char	irq_channel);
     23          #define Half_Step
     24          enum
     25          {
     26          	TP_CMD_PRINT_DOTLINE,
     27          	TP_CMD_FEED_TO_MARK,
     28          	TP_CMD_FEED,
     29          	TP_CMD_MAX
     30          };
     31          
     32          //==================================================================
     33          #define TIMER1_MS_TO_CNT(ms)	((uint16_t)(1000*(ms)-1))
     34          #define TIMER1_CNT_TO_MS(cnt)	(cnt+1)
     35          #define TP_MINWAIT_TIME	(TIMER1_MS_TO_CNT(0.1000))//100
     36          #define TIMER1_SPEED_TO_CNT(mm)	(((uint16_t)((SYSPCLK/ PR_Val)/ (mm*16))) - TP_MINWAIT_TIME)
     37          //==================================================================
     38          
     39          // 首先确定每个点行需要分几次加热(TP_MAX_HEAT_STROBE)，然后确定每次加热需要走纸的步数(TP_MAX_STROBE_STEP)
     40          // 最终必须保证(TP_MAX_HEAT_STROBE*TP_MAX_STROBE_STEP) = 一个点行的总步进数
     41          #ifdef Half_Step
     42          #define TP_MAX_HEAT_STROBE	(1) // 分几次加热，必须保证(LineDot/8/TP_MAX_HEAT_STROBE)是整数
     43          #define TP_MAX_STROBE_STEP	(4) // 每个加热Strobe上的步进
     44          #else
     45          #define TP_MAX_HEAT_STROBE	(1)
     46          #define TP_MAX_STROBE_STEP	(2) // 每个加热Strobe上的步进
     47          #endif
     48          
     49          
     50          #define TP_MAX_HEAT_DOT		(64)		// 每次最多能够加热的点数，必须大等于8
     51          //#define TP_MAX_HEAT_DOT		(48)		// 每次最多能够加热的点数，必须大等于8
     52          
     53          #define TpMinWaitTime	(TIMER1_MS_TO_CNT(0.100))
     54          
     55          
     56          #define T1_PCLK_DIV     3
     57          
     58          
     59          #define DISABLE_TIMER_INTERRUPT()	do{	\
     60          	NVIC_DisableIRQ(TIM3_IRQChannel); \
     61          	}while(0)
     62          
     63          #define ENABLE_TIMER_INTERRUPT()	do{	\
     64          	NVIC_EnableIRQ(TIM3_IRQChannel); \
     65          	}while(0)
     66          
     67          //GPIO_SetBits(GPIOB,GPIO_Pin_0);
     68          #define LATCH_HIGH()	do{	\
     69          	GPIOB->BSRR = GPIO_Pin_0;	\
     70          	}while(0)
     71          
     72          #define LATCH_LOW()	do{	\
     73          	GPIOB->BRR = GPIO_Pin_0;	\
     74          	}while(0)
     75          
     76          
     77          //====================================================================
     78          //PB.2
     79          #define MOTOR_PWR_ON()    do{ \
     80          	GPIOB->BSRR = GPIO_Pin_2; \
     81          	}while(0)
     82          
     83          #define MOTOR_PWR_OFF()   do{ \
     84          	GPIOB->BRR = GPIO_Pin_2; \
     85          	}while(0)
     86          
     87          //PE.7
     88          #define MOTOR_PHASE_1A_HIGH()  do{ \
     89          	GPIOE->BSRR = GPIO_Pin_7; \
     90          	}while(0)
     91          
     92          #define MOTOR_PHASE_1A_LOW()   do{ \
     93          	GPIOE->BRR = GPIO_Pin_7; \
     94          	}while(0)
     95          
     96          //PE.8
     97          #define MOTOR_PHASE_1B_HIGH()  do{ \
     98          	GPIOE->BSRR = GPIO_Pin_8; \
     99          	}while(0)
    100          
    101          #define MOTOR_PHASE_1B_LOW()   do{ \
    102          	GPIOE->BRR = GPIO_Pin_8;  \
    103          	}while(0)
    104          
    105          //PE.10
    106          #define MOTOR_PHASE_2A_HIGH()  do{ \
    107          	GPIOE->BSRR = GPIO_Pin_10; \
    108          	}while(0)
    109          
    110          #define MOTOR_PHASE_2A_LOW()   do{ \
    111          	GPIOE->BRR = GPIO_Pin_10; \
    112          	}while(0)
    113          
    114          //PE.9
    115          #define MOTOR_PHASE_2B_HIGH()  do{ \
    116          	GPIOE->BSRR = GPIO_Pin_9; \
    117          	}while(0)
    118          
    119          #define MOTOR_PHASE_2B_LOW()   do{  \
    120          	GPIOE->BRR = GPIO_Pin_9; \
    121          	}while(0)
    122          
    123          //PC.4
    124          #define STROBE_0_ON()     do{ \
    125          	GPIOC->BSRR = GPIO_Pin_4; \
    126          	}while(0)
    127          
    128          #define STROBE_0_OFF()    do{ \
    129          	GPIOC->BRR = GPIO_Pin_4; \
    130          	}while(0)
    131          
    132          //PC.5
    133          #define STROBE_1_ON()     do{ \
    134          	GPIOC->BSRR = GPIO_Pin_5; \
    135          	}while(0)
    136          
    137          #define STROBE_1_OFF()    do{ \
    138          	GPIOC->BRR = GPIO_Pin_5; \
    139          	}while(0)
    140          //======================================================================
    141          
    142          //PB.1
    143          #define PRN_POWER_CHARGE() \
    144          	do{ \
    145          	GPIOB->BSRR = GPIO_Pin_1; \
    146          	}while(0)
    147          
    148          #define PRN_POWER_DISCHARGE() \
    149          	do{ \
    150          	GPIOB->BRR = GPIO_Pin_1;\
    151          	}while(0)
    152          
    153          //======================================================================
    154          
    155          typedef enum
    156          {
    157          	TPSTATE_IDLE = 0,
    158          	TPSTATE_PRE_IDLE,
    159          	TPSTATE_START,
    160          	TPSTATE_HEAT_WITH_FEED,       // 开始加热，走纸，时间最长为马达步进时间(下一状态为TPSTATE_HEAT1_FEED_B)，最短为加热时间(下一状态为TPSTATE_HEAT1_STOP_A)
    161          	TPSTATE_HEAT_WITHOUT_FEED,
    162          	TPSTATE_FEED,
    163          	TPSTATE_FEED_TO_MARK,
    164          	TPSTATE_FEED_FIND_MARK,
    165          	TPSTATE_FEED_AFTERMARK,
    166          	TPSTATE_CUT_PRE_FEED,		// 进刀到Home位置
    167          	TPSTATE_CUT_FEED,			// 进刀到希望的位置(Partial/Full)
    168          	TPSTATE_CUT_REVERSE,		// 先退刀到Home位置
    169          	TPSTATE_CUT_REVERSE1,		// 再退一段距离
    170          	TPSTATE_WAIT_TIME,          //唤醒等待时间
    171          	TPSTATE_MAX
    172          } TPSTATE_T;
    173          
    174          typedef struct
    175          {
    176          	TPSTATE_T state;
    177          	uint8_t phase;
    178          	uint8_t cutphase;
    179          	uint8_t cutmode;        //切刀模式:0:全切 1:半切
    180          	uint16_t repeat;
    181          
    182          	uint32_t heat;
    183          	uint32_t heat_setting;
    184          	uint32_t heat_remain;
    185          	uint32_t feed_time[TP_MAX_STROBE_STEP];
    186          
    187          	uint8_t feed_step;		// 单个Strobe加热时马达步进计数器
    188          	uint8_t strobe_step;	// 单个点行加热时需要分的Strobe数的计数器
    189          	uint8_t accel;
    190          	uint16_t head;
    191          	volatile uint16_t tail;
    192          	uint16_t feedmax;
    193          	uint8_t pause;
    194          	uint8_t heat_max_cnt;
    195          	uint8_t heat_cnt;
    196          	uint8_t heat_buf[((LineDot/TP_MAX_HEAT_STROBE)+(TP_MAX_HEAT_DOT-7)-1)/(TP_MAX_HEAT_DOT-7)][LineDot/8];
    197          	int32_t markbefore;
    198          } TP_T;
    199          
    200          static TP_T tp;
    201          static uint8_t TP_dot[16][LineDot/8+1];		// 增加一个控制位
    202          
    203          uint8_t const Byte2DotNumTbl[] =
    204          {
    205          	0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,
    206          	1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,
    207          	1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,
    208          	2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
    209          	1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,
    210          	2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
    211          	2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
    212          	3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,
    213          	1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,
    214          	2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
    215          	2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
    216          	3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,
    217          	2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
    218          	3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,
    219          	3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,
    220          	4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8
    221          };
    222          
    223          extern uint8_t clr_all_dot=0;
    224          
    225          /**
    226          * @brief	打印头控制IO及定时器的初始化
    227          * @note                  
    228          */
    229          void TPInit(void)
    230          {
    231          	GPIO_InitTypeDef							GPIO_InitStructure;
    232          	TIM_TimeBaseInitTypeDef						TIM_TimeBaseStructure;
    233          	NVIC_InitTypeDef							NVIC_InitStructure;
    234          
    235          	//PRN_STROBE0 -- PC.4   PRN_STROBE1 -- PC.5
    236          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOE, ENABLE);
    237          
    238          	GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_4 | GPIO_Pin_5;
    239          	GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_Out_PP;
    240          	GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_50MHz;
    241          	GPIO_Init(GPIOC, &GPIO_InitStructure);
    242          
    243          	//MOT_PHASE1A -- PE.7   MOT_PHASE1B -- PE.8   MOT_PHASE2B -- PE.9	MOT_PHASE2A -- PE.10  
    244          	GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10;
    245          	GPIO_Init(GPIOE, &GPIO_InitStructure);
    246          
    247          	//PRN_LATCH	-- PB.0	 PRN_POWER -- PB.1  MOT_POWER -- PB.2
    248          	GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2;
    249          	GPIO_Init(GPIOB, &GPIO_InitStructure);
    250          
    251          	//MOT_STATUS -- PE.11
    252          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);
    253          	GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_11;
    254          	GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IPU;
    255          	GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_10MHz;
    256          	GPIO_Init(GPIOE, &GPIO_InitStructure);
    257          
    258          	/*开启相应时钟 */
    259          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);  
    260          
    261          	//((1+TIM_Prescaler )/72M)*(1+TIM_Period ) = 1ms定时
    262          	/* Time Base configuration */
    263          	TIM_TimeBaseStructure.TIM_Prescaler			= 71;      //1us的计数频率
    264          	TIM_TimeBaseStructure.TIM_CounterMode		= TIM_CounterMode_Up; //向上计数
    265          	TIM_TimeBaseStructure.TIM_Period			= (1000-1);      
    266          	TIM_TimeBaseStructure.TIM_ClockDivision		= 0x0;
    267          
    268          	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
    269          
    270          	/* set the TIM3 Interrupt */
    271          	NVIC_InitStructure.NVIC_IRQChannel			= TIM3_IRQChannel;
    272          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;		//中断优先级最高
    273          	NVIC_InitStructure.NVIC_IRQChannelSubPriority	= 0;
    274          	NVIC_InitStructure.NVIC_IRQChannelCmd		= DISABLE;
    275          	NVIC_Init(&NVIC_InitStructure);
    276          
    277          	TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);
    278          	TIM_ARRPreloadConfig(TIM3,ENABLE);
    279          	TIM_Cmd(TIM3,ENABLE);
    280          
    281          
    282          	//初始化控制时序
    283          	MOTOR_PWR_OFF();
    284          	STROBE_0_OFF();
    285          	STROBE_1_OFF();
    286          
    287          	MOTOR_PHASE_1A_LOW();
    288          	MOTOR_PHASE_1B_LOW();
    289          	MOTOR_PHASE_2A_LOW();
    290          	MOTOR_PHASE_2B_LOW();
    291          	//===========================
    292          
    293          	tp.head = 0;
    294          	tp.tail = 0;
    295          	tp.state = TPSTATE_IDLE;
    296          	tp.pause = 0;
    297          
    298          }
    299          
    300          
    301          extern void WakeUpTP_MODE1(void)
    302          {
    303          	volatile uint16_t len;
    304          
    305          	PrintBufToZero();
    306          	esc_sts[current_channel].bitmap_flag = 0;
    307          	MEMSET(esc_sts[current_channel].dot, 0, sizeof(esc_sts[current_channel].dot));
    308          	esc_sts[current_channel].start_dot = 0;
    309          	max_start_col =0;
    310          	esc_sts[current_channel].dot_minrow = ARRAY_SIZE(esc_sts[current_channel].dot[0]);
    311          
    312          	len =  LineDot/8;
    313          	while (len--)
    314          	{
    315          		print_head_spi_send_byte(0);
    316          	}
    317          	LATCH_LOW();
    318          	len = 100;
    319          	while (len--);
    320          	LATCH_HIGH();
    321          	tp.tail=tp.head;
    322          	TPIntSetIdle();
    323          	clr_all_dot=1;
    324          
    325          }
    326          
    327          
    328          static void TPForwardStep(int direction)
    329          {
    330          	//trip4();
    331          	PRN_POWER_DISCHARGE();
    332          #if defined(PT486) || defined(PT487)||defined(PT48D)||defined(PT1043)|| defined(PT48G)
    333          #ifdef Half_Step
    334          	switch (tp.phase & 0x07)
    335          	{
    336          
    337          	case 0:
    338          		MOTOR_PHASE_1A_HIGH();
    339          		MOTOR_PHASE_1B_LOW();
    340          		MOTOR_PHASE_2A_HIGH();
    341          		MOTOR_PHASE_2B_LOW();
    342          		break;
    343          	case 1:
    344          		MOTOR_PHASE_1A_HIGH();
    345          		MOTOR_PHASE_1B_LOW();
    346          		MOTOR_PHASE_2A_LOW();
    347          		MOTOR_PHASE_2B_LOW();
    348          		break;
    349          	case 2:
    350          		MOTOR_PHASE_1A_HIGH();
    351          		MOTOR_PHASE_1B_LOW();
    352          		MOTOR_PHASE_2A_LOW();
    353          		MOTOR_PHASE_2B_HIGH();
    354          		break;
    355          	case 3:
    356          		MOTOR_PHASE_1A_LOW();
    357          		MOTOR_PHASE_1B_LOW();
    358          		MOTOR_PHASE_2A_LOW();
    359          		MOTOR_PHASE_2B_HIGH();
    360          		break;
    361          	case 4:
    362          		MOTOR_PHASE_1A_LOW();
    363          		MOTOR_PHASE_1B_HIGH();
    364          		MOTOR_PHASE_2A_LOW();
    365          		MOTOR_PHASE_2B_HIGH();
    366          		break;
    367          	case 5:
    368          		MOTOR_PHASE_1A_LOW();
    369          		MOTOR_PHASE_1B_HIGH();
    370          		MOTOR_PHASE_2A_LOW();
    371          		MOTOR_PHASE_2B_LOW();
    372          		break;
    373          	case 6:
    374          		MOTOR_PHASE_1A_LOW();
    375          		MOTOR_PHASE_1B_HIGH();
    376          		MOTOR_PHASE_2A_HIGH();
    377          		MOTOR_PHASE_2B_LOW();
    378          		break;
    379          	case 7:
    380          		MOTOR_PHASE_1A_LOW();
    381          		MOTOR_PHASE_1B_LOW();
    382          		MOTOR_PHASE_2A_HIGH();
    383          		MOTOR_PHASE_2B_LOW();
    384          		break;
    385          
    386          	}
    387          
    388          #else
    389          	switch (tp.phase & 0x03)
    390          	{
    391          
    392          	case 0:
    393          		MOTOR_PHASE_1A_HIGH();
    394          		MOTOR_PHASE_1B_LOW();
    395          		MOTOR_PHASE_2A_HIGH();
    396          		MOTOR_PHASE_2B_LOW();
    397          		break;
    398          	case 1:
    399          		MOTOR_PHASE_1A_HIGH();
    400          		MOTOR_PHASE_1B_LOW();
    401          		MOTOR_PHASE_2A_LOW();
    402          		MOTOR_PHASE_2B_HIGH();
    403          		break;
    404          	case 2:
    405          		MOTOR_PHASE_1A_LOW();
    406          		MOTOR_PHASE_1B_HIGH();
    407          		MOTOR_PHASE_2A_LOW();
    408          		MOTOR_PHASE_2B_HIGH();
    409          		break;
    410          	case 3:
    411          		MOTOR_PHASE_1A_LOW();
    412          		MOTOR_PHASE_1B_HIGH();
    413          		MOTOR_PHASE_2A_HIGH();
    414          		MOTOR_PHASE_2B_LOW();
    415          		break;
    416          
    417          	}
    418          #endif
    419          
    420          #else
    421          #ifdef Half_Step
    422          	switch (tp.phase & 0x07)
    423          	{
    424          	case 7:
    425          		MOTOR_PHASE_1A_HIGH();
    426          		MOTOR_PHASE_1B_LOW();
    427          		MOTOR_PHASE_2A_HIGH();
    428          		MOTOR_PHASE_2B_LOW();
    429          		break;
    430          	case 6:
    431          		MOTOR_PHASE_1A_HIGH();
    432          		MOTOR_PHASE_1B_LOW();
    433          		MOTOR_PHASE_2A_LOW();
    434          		MOTOR_PHASE_2B_LOW();
    435          		break;
    436          	case 5:
    437          		MOTOR_PHASE_1A_HIGH();
    438          		MOTOR_PHASE_1B_LOW();
    439          		MOTOR_PHASE_2A_LOW();
    440          		MOTOR_PHASE_2B_HIGH();
    441          		break;
    442          	case 4:
    443          		MOTOR_PHASE_1A_LOW();
    444          		MOTOR_PHASE_1B_LOW();
    445          		MOTOR_PHASE_2A_LOW();
    446          		MOTOR_PHASE_2B_HIGH();
    447          		break;
    448          	case 3:
    449          		MOTOR_PHASE_1A_LOW();
    450          		MOTOR_PHASE_1B_HIGH();
    451          		MOTOR_PHASE_2A_LOW();
    452          		MOTOR_PHASE_2B_HIGH();
    453          		break;
    454          	case 2:
    455          		MOTOR_PHASE_1A_LOW();
    456          		MOTOR_PHASE_1B_HIGH();
    457          		MOTOR_PHASE_2A_LOW();
    458          		MOTOR_PHASE_2B_LOW();
    459          		break;
    460          	case 1:
    461          		MOTOR_PHASE_1A_LOW();
    462          		MOTOR_PHASE_1B_HIGH();
    463          		MOTOR_PHASE_2A_HIGH();
    464          		MOTOR_PHASE_2B_LOW();
    465          		break;
    466          	case 0:
    467          		MOTOR_PHASE_1A_LOW();
    468          		MOTOR_PHASE_1B_LOW();
    469          		MOTOR_PHASE_2A_HIGH();
    470          		MOTOR_PHASE_2B_LOW();
    471          		break;
    472          	}
    473          
    474          #else
    475          	switch (tp.phase & 0x03)
    476          	{
    477          	case 3:
    478          		MOTOR_PHASE_1A_HIGH();
    479          		MOTOR_PHASE_1B_LOW();
    480          		MOTOR_PHASE_2A_HIGH();
    481          		MOTOR_PHASE_2B_LOW();
    482          		break;
    483          	case 2:
    484          		MOTOR_PHASE_1A_HIGH();
    485          		MOTOR_PHASE_1B_LOW();
    486          		MOTOR_PHASE_2A_LOW();
    487          		MOTOR_PHASE_2B_HIGH();
    488          		break;
    489          	case 1:
    490          		MOTOR_PHASE_1A_LOW();
    491          		MOTOR_PHASE_1B_HIGH();
    492          		MOTOR_PHASE_2A_LOW();
    493          		MOTOR_PHASE_2B_HIGH();
    494          		break;
    495          	case 0:
    496          		MOTOR_PHASE_1A_LOW();
    497          		MOTOR_PHASE_1B_HIGH();
    498          		MOTOR_PHASE_2A_HIGH();
    499          		MOTOR_PHASE_2B_LOW();
    500          		break;
    501          	}
    502          #endif
    503          #endif
    504          	if(TPPrinterMark() == FALSE)        // find mark
    505          	{
    506          		tp.markbefore = 0;
    507          	}
    508          	else if(tp.markbefore >= 0)
    509          	{
    510          		tp.markbefore++;
    511          	}
    512          	PRN_POWER_CHARGE();
    513          	tp.phase += direction;
    514          }
    515          
    516          static uint16_t const TpAccelerationSteps[] =
    517          {
    518          	TIMER1_MS_TO_CNT(5.579),
    519          	TIMER1_MS_TO_CNT(4.308),
    520          	TIMER1_MS_TO_CNT(2.614),
    521          	TIMER1_MS_TO_CNT(2.500),
    522          	TIMER1_MS_TO_CNT(2.426),
    523          	TIMER1_MS_TO_CNT(2.272),
    524          	TIMER1_MS_TO_CNT(2.144),
    525          	TIMER1_MS_TO_CNT(2.035),
    526          	TIMER1_MS_TO_CNT(1.941),
    527          	TIMER1_MS_TO_CNT(1.859),
    528          	TIMER1_MS_TO_CNT(1.786),
    529          	TIMER1_MS_TO_CNT(1.721),
    530          	TIMER1_MS_TO_CNT(1.663),
    531          	TIMER1_MS_TO_CNT(1.610),
    532          	TIMER1_MS_TO_CNT(1.561),
    533          	TIMER1_MS_TO_CNT(1.517),
    534          	TIMER1_MS_TO_CNT(1.477),
    535          	TIMER1_MS_TO_CNT(1.439),
    536          	TIMER1_MS_TO_CNT(1.404),
    537          	TIMER1_MS_TO_CNT(1.372),
    538          	TIMER1_MS_TO_CNT(1.342),
    539          	TIMER1_MS_TO_CNT(1.313),
    540          	TIMER1_MS_TO_CNT(1.287),
    541          	TIMER1_MS_TO_CNT(1.261),
    542          	TIMER1_MS_TO_CNT(1.238),
    543          	TIMER1_MS_TO_CNT(1.215),
    544          	TIMER1_MS_TO_CNT(1.194),
    545          	TIMER1_MS_TO_CNT(1.174),
    546          	TIMER1_MS_TO_CNT(1.155),
    547          	TIMER1_MS_TO_CNT(1.136),
    548          	TIMER1_MS_TO_CNT(1.119),
    549          	TIMER1_MS_TO_CNT(1.102),
    550          	TIMER1_MS_TO_CNT(1.086),
    551          	TIMER1_MS_TO_CNT(1.071),
    552          	TIMER1_MS_TO_CNT(1.056),
    553          	TIMER1_MS_TO_CNT(1.042),
    554          	TIMER1_MS_TO_CNT(1.029),
    555          	TIMER1_MS_TO_CNT(1.016),
    556          	TIMER1_MS_TO_CNT(1.003),
    557          	TIMER1_MS_TO_CNT(0.991),
    558          	TIMER1_MS_TO_CNT(0.979),
    559          	TIMER1_MS_TO_CNT(0.968),
    560          	TIMER1_MS_TO_CNT(0.957),
    561          	TIMER1_MS_TO_CNT(0.947),
    562          	TIMER1_MS_TO_CNT(0.936),
    563          	TIMER1_MS_TO_CNT(0.927),
    564          	TIMER1_MS_TO_CNT(0.917),
    565          	TIMER1_MS_TO_CNT(0.908),
    566          	TIMER1_MS_TO_CNT(0.899),
    567          	TIMER1_MS_TO_CNT(0.890),
    568          	TIMER1_MS_TO_CNT(0.882),
    569          	TIMER1_MS_TO_CNT(0.873),
    570          	TIMER1_MS_TO_CNT(0.865),
    571          	TIMER1_MS_TO_CNT(0.857),
    572          	TIMER1_MS_TO_CNT(0.850),
    573          	TIMER1_MS_TO_CNT(0.842),
    574          	TIMER1_MS_TO_CNT(0.835),
    575          	TIMER1_MS_TO_CNT(0.828),
    576          	TIMER1_MS_TO_CNT(0.821),
    577          	TIMER1_MS_TO_CNT(0.815),
    578          	TIMER1_MS_TO_CNT(0.808),
    579          	TIMER1_MS_TO_CNT(0.802),
    580          	TIMER1_MS_TO_CNT(0.796),
    581          	TIMER1_MS_TO_CNT(0.789),
    582          	TIMER1_MS_TO_CNT(0.784),
    583          	TIMER1_MS_TO_CNT(0.778),
    584          	TIMER1_MS_TO_CNT(0.772),
    585          	TIMER1_MS_TO_CNT(0.766),
    586          	TIMER1_MS_TO_CNT(0.761),
    587          	TIMER1_MS_TO_CNT(0.756),
    588          	TIMER1_MS_TO_CNT(0.750),
    589          	TIMER1_MS_TO_CNT(0.745),
    590          	TIMER1_MS_TO_CNT(0.740),
    591          	TIMER1_MS_TO_CNT(0.735),
    592          	TIMER1_MS_TO_CNT(0.731),
    593          	TIMER1_MS_TO_CNT(0.726),
    594          	TIMER1_MS_TO_CNT(0.721),
    595          	TIMER1_MS_TO_CNT(0.717),
    596          	TIMER1_MS_TO_CNT(0.712),
    597          	TIMER1_MS_TO_CNT(0.708),
    598          	TIMER1_MS_TO_CNT(0.704),
    599          	TIMER1_MS_TO_CNT(0.699),
    600          	TIMER1_MS_TO_CNT(0.695),
    601          	TIMER1_MS_TO_CNT(0.691),
    602          	TIMER1_MS_TO_CNT(0.687),
    603          	TIMER1_MS_TO_CNT(0.683),
    604          	TIMER1_MS_TO_CNT(0.679),
    605          	TIMER1_MS_TO_CNT(0.675),
    606          	TIMER1_MS_TO_CNT(0.672),
    607          	TIMER1_MS_TO_CNT(0.668),
    608          	TIMER1_MS_TO_CNT(0.664),
    609          	TIMER1_MS_TO_CNT(0.661),
    610          	TIMER1_MS_TO_CNT(0.657),
    611          	TIMER1_MS_TO_CNT(0.654),
    612          	TIMER1_MS_TO_CNT(0.651),
    613          	TIMER1_MS_TO_CNT(0.647),
    614          	TIMER1_MS_TO_CNT(0.644),
    615          	TIMER1_MS_TO_CNT(0.641),
    616          	TIMER1_MS_TO_CNT(0.637),
    617          	TIMER1_MS_TO_CNT(0.634),
    618          	TIMER1_MS_TO_CNT(0.631),
    619          	TIMER1_MS_TO_CNT(0.628),
    620          	TIMER1_MS_TO_CNT(0.625),
    621          	TIMER1_MS_TO_CNT(0.622),
    622          	TIMER1_MS_TO_CNT(0.619),
    623          	TIMER1_MS_TO_CNT(0.616),
    624          	TIMER1_MS_TO_CNT(0.614),
    625          	TIMER1_MS_TO_CNT(0.611),
    626          	TIMER1_MS_TO_CNT(0.608),
    627          	TIMER1_MS_TO_CNT(0.605),
    628          	TIMER1_MS_TO_CNT(0.603),
    629          	TIMER1_MS_TO_CNT(0.600),
    630          #if !defined(LOW_5V_PRINT)
    631          	TIMER1_MS_TO_CNT(0.597),
    632          	TIMER1_MS_TO_CNT(0.595),
    633          	TIMER1_MS_TO_CNT(0.592),
    634          	TIMER1_MS_TO_CNT(0.590),
    635          	TIMER1_MS_TO_CNT(0.587),
    636          	TIMER1_MS_TO_CNT(0.585),
    637          	TIMER1_MS_TO_CNT(0.582),
    638          	TIMER1_MS_TO_CNT(0.580),
    639          	TIMER1_MS_TO_CNT(0.577),
    640          	TIMER1_MS_TO_CNT(0.575),
    641          	TIMER1_MS_TO_CNT(0.573),
    642          	TIMER1_MS_TO_CNT(0.570),
    643          	TIMER1_MS_TO_CNT(0.568),
    644          	//=========================
    645          	TIMER1_MS_TO_CNT(0.558),
    646          	TIMER1_MS_TO_CNT(0.548),
    647          	TIMER1_MS_TO_CNT(0.538),
    648          	TIMER1_MS_TO_CNT(0.529),
    649          	TIMER1_MS_TO_CNT(0.520),
    650          	TIMER1_MS_TO_CNT(0.512),
    651          	TIMER1_MS_TO_CNT(0.504),
    652          	TIMER1_MS_TO_CNT(0.497),
    653          	TIMER1_MS_TO_CNT(0.489),
    654          	TIMER1_MS_TO_CNT(0.482),
    655          	TIMER1_MS_TO_CNT(0.476),
    656          	TIMER1_MS_TO_CNT(0.469),
    657          	TIMER1_MS_TO_CNT(0.463),
    658          	TIMER1_MS_TO_CNT(0.457),
    659          	TIMER1_MS_TO_CNT(0.452),
    660          	TIMER1_MS_TO_CNT(0.446),
    661          	TIMER1_MS_TO_CNT(0.441),
    662          	TIMER1_MS_TO_CNT(0.436),
    663          	TIMER1_MS_TO_CNT(0.431),
    664          	TIMER1_MS_TO_CNT(0.426),
    665          	TIMER1_MS_TO_CNT(0.422),
    666          	TIMER1_MS_TO_CNT(0.417),
    667          	TIMER1_MS_TO_CNT(0.413),
    668          	TIMER1_MS_TO_CNT(0.409),
    669          	TIMER1_MS_TO_CNT(0.405),
    670          	TIMER1_MS_TO_CNT(0.401),
    671          #if defined(HIGH_8V_PRINT)
    672          	TIMER1_MS_TO_CNT(0.397),
    673          	TIMER1_MS_TO_CNT(0.393),
    674          	TIMER1_MS_TO_CNT(0.390),
    675          	TIMER1_MS_TO_CNT(0.386),
    676          	TIMER1_MS_TO_CNT(0.383),
    677          	TIMER1_MS_TO_CNT(0.379),
    678          	TIMER1_MS_TO_CNT(0.376),
    679          	TIMER1_MS_TO_CNT(0.373),
    680          	TIMER1_MS_TO_CNT(0.370),
    681          	TIMER1_MS_TO_CNT(0.367),
    682          	TIMER1_MS_TO_CNT(0.364),
    683          	TIMER1_MS_TO_CNT(0.361),
    684          	TIMER1_MS_TO_CNT(0.358),
    685          	TIMER1_MS_TO_CNT(0.355),
    686          	TIMER1_MS_TO_CNT(0.353),
    687          	TIMER1_MS_TO_CNT(0.350),
    688          #endif
    689          #endif
    690          };
    691          
    692          // 加热时间根据电压调整
    693          static uint32_t TPHeatVoltageAdj(uint32_t tm)
    694          {
    695          
    696          #if defined(TP_VOLTAGE_SNS)
    697          
    698          #endif
    699          	return tm;
    700          
    701          
    702          }
    703          #if defined(TEMP_SNS_ENABLE)
    704          // 加热时间根据热敏头的温度进行调整
    705          static uint32_t TPHeatThermalAdj(uint32_t tm,int16_t temp)
    706          {
    707          	static uint8_t const Temperater_Ratio[]=
    708          	{
    709          		// 比例        温度
    710          		250,248,242,238,230,228,224,220,216,210,//-20~-11
    711          		202,194,186,178,172,168,164,160,156,152,//-10~-1
    712          		148,144,140,136,132,128,124,122,120,118,//0-9
    713          		116,114,116,112,111,110,109,108,107,106,//10-19
    714          		105,104,103,102,101,100, 99, 98, 97, 96,//20-29
    715          		95, 94, 93, 92, 91, 90, 89, 88, 87, 86,//30-39
    716          		85, 84, 83, 82, 81, 80, 79, 78, 77, 76,//40-49
    717          		75, 74, 73, 72, 71, 70, 69, 68, 67, 66,//50-59
    718          		65, 64, 63, 62, 61, 60, 59, 58, 57, 56,//60-69
    719          		55, 54, 53, 52, 51, 50, 50, 50, 50, 50,//70-79
    720          		50, 50, 50, 50, 50, 50,                //80-85
    721          	};
    722          	if
    723          		((temp >= -20)&&(temp <= 85))
    724          	{
    725          		tm = tm *Temperater_Ratio[temp+20]/100;
    726          	}
    727          	else if (temp < -20)
    728          	{
    729          		tm = tm *Temperater_Ratio[0]/100;
    730          	}
    731          	else if (temp>85)
    732          	{
    733          		tm = tm /2;
    734          	}
    735          
    736          	return tm;
    737          }
    738          #endif
    739          
    740          // 加热前几行的加热时间调整
    741          static uint32_t TPHeatPreLineAdj(uint32_t tm)
    742          {
    743          	//	TODO:
    744          	//	tm += ((uint32_t)TpAccelerationSteps[tp.accel]) * 10 / 100;
    745          	return tm;
    746          }
    747          
    748          static uint32_t TPHeatDotsAdj(uint32_t tm,uint16_t dots)
    749          {
    750          
    751          	//TP_MAX_HEAT_DOT变化的话需做相应调整
    752          #if (TP_MAX_HEAT_DOT == 64)
    753          	const uint8_t dot_ratio_tbl[TP_MAX_HEAT_DOT/4]=
    754          	{
    755          		70, 74, 78, 82, 86, 88,//0-24
    756          		90, 92, 93, 94, 95, 96,//24-48
    757          		97, 98,100,100,        //48-64
    758          	};
    759          #elif (TP_MAX_HEAT_DOT == 48)
    760          	const uint8_t dot_ratio_tbl[TP_MAX_HEAT_DOT/4]=
    761          	{
    762          		70, 78, 86, 88,//0-24
    763          		90, 93, 95, 96,//24-48
    764          		97, 98,100,100,        //48-64
    765          	};
    766          #else
    767          #error("No define dot_ratio_tbl");
    768          #endif
    769          
    770          	if(dots<TP_MAX_HEAT_DOT)
    771          	{
    772          		tm = tm * dot_ratio_tbl[dots/4]/100;
    773          	}
    774          	else
    775          	{
    776          		tm = tm * dot_ratio_tbl[TP_MAX_HEAT_DOT/4-1]/100;
    777          	}
    778          
    779          	return tm;
    780          }
    781          static void TPAdjustStepTime(uint8_t heat_cnt,uint16_t max_heat_dots)
    782          {
    783          	uint16_t heat;
    784          	uint16_t time, time_sum;
    785          	uint8_t i;
    786          
    787          	heat = TPHeatVoltageAdj(tp.heat_setting);
    788          	heat = TPHeatDotsAdj(heat,max_heat_dots);
    789          #if defined(TEMP_SNS_ENABLE)
    790          	heat = TPHeatThermalAdj(heat,TPHTemperature());
    791          #endif
    792          	heat = TPHeatPreLineAdj(heat);
    793          	tp.heat = heat;
    794          
    795          	heat *= heat_cnt;
    796          
    797          	heat += TpMinWaitTime;
    798          
    799          	while(1)
    800          	{
    801          		time_sum = 0;
    802          		for(i=0; i<TP_MAX_STROBE_STEP; i++)
    803          		{
    804          			if((tp.accel+i) < ARRAY_SIZE(TpAccelerationSteps))
    805          			{
    806          				time = TpAccelerationSteps[tp.accel+i];
    807          			}
    808          			else
    809          			{
    810          				time = TpAccelerationSteps[ARRAY_SIZE(TpAccelerationSteps)-1];
    811          			}
    812          			tp.feed_time[i] = time;
    813          			time_sum += time;
    814          		}
    815          		if(time_sum < heat)
    816          		{
    817          			if(tp.accel)
    818          			{
    819          				tp.accel--;
    820          			}
    821          			else
    822          			{
    823          				for(i=0; i<TP_MAX_STROBE_STEP; i++)
    824          				{
    825          					tp.feed_time[i] = heat/TP_MAX_STROBE_STEP;
    826          				}
    827          				break;
    828          			}
    829          		}
    830          		else
    831          		{
    832          			if((tp.accel+TP_MAX_STROBE_STEP) < (ARRAY_SIZE(TpAccelerationSteps)-1))
    833          			{
    834          				tp.accel += TP_MAX_STROBE_STEP;
    835          			}
    836          			else
    837          			{
    838          				tp.accel = (ARRAY_SIZE(TpAccelerationSteps)-1);
    839          			}
    840          			break;
    841          		}
    842          	}
    843          }
    844          static uint16_t TPGetStepTime(void)
    845          {
    846          	uint16_t time;
    847          
    848          	time = TpAccelerationSteps[tp.accel];
    849          	if(tp.accel < (ARRAY_SIZE(TpAccelerationSteps)-1))
    850          	{
    851          		tp.accel++;
    852          	}
    853          	return time;
    854          }
    855          
    856          static void TPSetTimeCnt(uint16_t tm)
    857          {
    858          	TIM3->ARR = tm;
    859          	TIM3->EGR = TIM_EventSource_Update;		//这个很重要，软件产生一次更新事件，才能将当前设置的溢出值更新到它的影子寄存器！！！（此问题折磨了2天之久）
    860          	//printf("current tm=%d(us)\r\n",TIMER1_CNT_TO_MS(tm));		//for debug
    861          }
    862          
    863          static uint8_t TPFeedStep(void)
    864          {
    865          	TPSetTimeCnt(TPGetStepTime());	// set timer
    866          	if(TPPrinterReady() != TRUE )
    867          	{
    868          		return 0;
    869          	}
    870          	if(tp.feedmax)
    871          	{
    872          		TPForwardStep(1);
    873          		tp.feedmax--;
    874          	}
    875          	if(tp.feedmax)
    876          	{
    877          		return 1;
    878          	}
    879          	else
    880          	{
    881          		return 0;
    882          	}
    883          }
    884          
    885          
    886          static void TPIntSetPreIdle(void)
    887          {
    888          	//trip4();
    889          	STROBE_0_OFF(); 	// stop heat
    890          	STROBE_1_OFF(); 	// stop heat
    891          	tp.feedmax = 60*1;		// 每1ms中断一次
    892          	tp.state = TPSTATE_PRE_IDLE;
    893          }
    894          
    895          static void TPIntSetIdle(void)
    896          {
    897          	//trip3();
    898          	STROBE_0_OFF(); 	// stop heat
    899          	STROBE_1_OFF(); 	// stop heat
    900          	DISABLE_TIMER_INTERRUPT();				// disable interrupt
    901          	MOTOR_PWR_OFF();
    902          	tp.state = TPSTATE_IDLE;
    903          }
    904          
    905          uint16_t MaxHeatDotsAdj(uint16_t dots)
    906          {
    907          	uint16_t max_heat_dot;//新的最大值
    908          
    909          	max_heat_dot = dots/(dots/(TP_MAX_HEAT_DOT+1)+1);//总加热点数加热次数
    910          	if ((max_heat_dot+1) <= TP_MAX_HEAT_DOT)         //8个点的误差，引起多一次的加热
    911          		max_heat_dot += 1;
    912          	else
    913          		max_heat_dot = TP_MAX_HEAT_DOT;
    914          	return max_heat_dot;
    915          }
    916          
    917          static void TPDataShiftCntProc(uint8_t strobe_cnt)
    918          {
    919          	uint8_t c;			// 当前字节
    920          	uint8_t dot;		// 当前字节的点数
    921          	uint8_t heat_cnt;	// 分开几次加热
    922          	uint16_t max_dot;	// 加热点累加和
    923          	uint16_t i,j,pt;		// 行缓冲区指针
    924          	uint16_t max_heat_dots=0;
    925          
    926          	for(i=0, pt=((LineDot/8/TP_MAX_HEAT_STROBE)*strobe_cnt); i<LineDot/8/TP_MAX_HEAT_STROBE; i++, pt++)
    927          	{
    928          		c = TP_dot[tp.tail][pt];
    929          		dot = Byte2DotNumTbl[c];
    930          		max_heat_dots += dot;
    931          	}
    932          	max_heat_dots = MaxHeatDotsAdj(max_heat_dots);
    933          
    934          	MEMSET(tp.heat_buf[0], 0, sizeof(tp.heat_buf[0]));
    935          	for(i=0, pt=((LineDot/8/TP_MAX_HEAT_STROBE)*strobe_cnt), heat_cnt=0, max_dot=0; i<LineDot/8/TP_MAX_HEAT_STROBE; i++, pt++)
    936          	{
    937          		c = TP_dot[tp.tail][pt];
    938          		dot = Byte2DotNumTbl[c];
    939          		if((max_dot+dot)<=max_heat_dots)
    940          		{
    941          			max_dot += dot;
    942          			tp.heat_buf[heat_cnt][pt] = c;
    943          		}
    944          		else
    945          		{
    946          			for (j=0; j<8; j++)
    947          			{
    948          				c = TP_dot[tp.tail][pt] & (1<<(7-(j&0x07)));
    949          				if(c)
    950          				{
    951          					if((max_dot+1) <= max_heat_dots)
    952          					{
    953          						max_dot++;
    954          					}
    955          					else
    956          					{
    957          						heat_cnt++;
    958          						max_dot = 1;
    959          						MEMSET((void *)tp.heat_buf[heat_cnt], 0, sizeof(tp.heat_buf[0]));
    960          					}
    961          					tp.heat_buf[heat_cnt][pt+j/8] |= c;
    962          				}
    963          			}
    964          		}
    965          
    966          	}
    967          	if(max_dot)
    968          	{
    969          		heat_cnt++;
    970          	}
    971          
    972          	tp.heat_max_cnt = heat_cnt;//每行最多加热的次数
    973          	tp.heat_cnt = 0;
    974          	// 计算具体的加速表来满足时间要求
    975          	TPAdjustStepTime(heat_cnt,max_heat_dots);
    976          }
    977          
    978          static void TPDataShiftOut(uint8_t *p, uint16_t len)
    979          {
    980          
    981          
    982          	while (len--)
    983          	{
    984          		//Send byte through the SPI1 peripheral
    985          		print_head_spi_send_byte(*p++);
    986          		// Loop while DR register in not emplty
    987          
    988          	}
    989          
    990          	return;
    991          
    992          }
    993          
    994          static void TPDataDMAShiftToPrn(void)
    995          {
    996          	TPDataShiftOut(tp.heat_buf[tp.heat_cnt],ARRAY_SIZE(tp.heat_buf[0]));
    997          }
    998          
    999          static uint8_t TPCheckBuf(void)
   1000          {
   1001          	uint8_t ret;
   1002          	uint16_t feedmax;
   1003          
   1004          	//if(TPPrinterReady_ext() !=  TRUE )
   1005          	if(TPPrinterReady() !=  TRUE )
   1006          	{
   1007          		TPIntSetIdle();
   1008          		ret = 0;
   1009          		return ret;
   1010          	}
   1011          	if (tp.head != tp.tail)
   1012          	{
   1013          		switch (TP_dot[tp.tail][LineDot/8])
   1014          		{
   1015          		case TP_CMD_PRINT_DOTLINE:
   1016          			TPDataShiftCntProc(0);		// 计算第一个加热行
   1017          #ifdef DEBUG_VER
   1018          			//debug_buffer[debug_cnt] = tp.heat;
   1019          			//debug_cnt++;
   1020          			//debug_buffer[debug_cnt] = tp.heat_max_cnt;
   1021          			//debug_cnt++;
   1022          			//debug_buffer[debug_cnt] = tp.feed_time[0];
   1023          			//debug_cnt++;
   1024          			//debug_buffer[debug_cnt] = tp.feed_time[1];
   1025          			//debug_cnt++;
   1026          			//debug_buffer[debug_cnt] = tp.feed_time[2];
   1027          			//debug_cnt++;
   1028          			//debug_buffer[debug_cnt] = tp.feed_time[3];
   1029          			//debug_cnt++;
   1030          #endif
   1031          			if(tp.heat_cnt < tp.heat_max_cnt)//本行还有数据需要加热
   1032          			{
   1033          				TPDataDMAShiftToPrn();		// 开始送数据到打印机
   1034          			}
   1035          			tp.heat_remain = 0;
   1036          			tp.feed_step = 0;
   1037          			tp.strobe_step = 0;
   1038          			tp.state = TPSTATE_HEAT_WITH_FEED;
   1039          			ret = 1;
   1040          			break;
   1041          		case TP_CMD_FEED:
   1042          			//tp.feedmax = TP_dot[tp.tail][0] | (TP_dot[tp.tail][1] << 8);
   1043          			tp.feedmax = TP_dot[tp.tail][1];
   1044          			tp.feedmax <<= 8;
   1045          			tp.feedmax |= TP_dot[tp.tail][0];
   1046          			tp.tail = (tp.tail+1) & (ARRAY_SIZE(TP_dot)-1);
   1047          			tp.state = TPSTATE_FEED;
   1048          			ret = 2;
   1049          			break;
   1050          		case TP_CMD_FEED_TO_MARK:
   1051          			STROBE_0_OFF();
   1052          			STROBE_1_OFF();
   1053          			//feedmax = TP_dot[tp.tail][0] | (TP_dot[tp.tail][1] << 8);
   1054          			feedmax = TP_dot[tp.tail][1];
   1055          			feedmax <<= 8;
   1056          			feedmax |= TP_dot[tp.tail][0];
   1057          			tp.tail = (tp.tail+1) & (ARRAY_SIZE(TP_dot)-1);
   1058          			if(tp.markbefore > 0)	// 这次走纸有发现黑标
   1059          			{
   1060          				if(tp.markbefore >= g_param.line_after_mark)	// 之前发现的黑标位置超过要求
   1061          				{
   1062          					tp.feedmax = feedmax;
   1063          					tp.state = TPSTATE_FEED_TO_MARK;
   1064          				}
   1065          				else	// 之前已经找到黑标并且没有超过允许范围
   1066          				{
   1067          					tp.feedmax = g_param.line_after_mark - tp.markbefore;
   1068          					tp.state = TPSTATE_FEED_AFTERMARK;
   1069          				}
   1070          			}
   1071          			else if(tp.markbefore == 0)		// 现在还停留在黑标位置
   1072          			{
   1073          				tp.feedmax = feedmax;
   1074          				tp.state = TPSTATE_FEED_FIND_MARK;
   1075          			}
   1076          			else	// 之前没有发现黑标，则开始找黑标
   1077          			{
   1078          				tp.feedmax = feedmax;
   1079          				tp.state = TPSTATE_FEED_TO_MARK;
   1080          			}
   1081          			ret = 2;
   1082          			break;
   1083          		default:	// 未知类型，属于严重错误
   1084          			tp.tail = (tp.tail+1) & (ARRAY_SIZE(TP_dot)-1);
   1085          			TPIntSetIdle();
   1086          			ret = 0;
   1087          			break;
   1088          		}
   1089          	}
   1090          	else
   1091          	{
   1092          		TPIntSetPreIdle();
   1093          		ret = 0;
   1094          	}
   1095          	return ret;
   1096          }
   1097          
   1098          extern void TPISRProc(void)
   1099          {
   1100          	switch (tp.state)
   1101          	{
   1102          	case TPSTATE_START: 	// start
   1103          		switch (TPCheckBuf())
   1104          		{
   1105          		case 1:		// 打印
   1106          			MOTOR_PWR_ON();
   1107          			TPSetTimeCnt(TPGetStepTime());	// set timer
   1108          			break;
   1109          		case 2:		// 走纸
   1110          			MOTOR_PWR_ON();
   1111          			TPSetTimeCnt(TPGetStepTime());	// set timer
   1112          			break;
   1113          		}
   1114          		break;
   1115          	case TPSTATE_HEAT_WITH_FEED:       // 开始马达步进
   1116          		TPForwardStep(1);
   1117          		// break;
   1118          	case TPSTATE_HEAT_WITHOUT_FEED:
   1119          		if(tp.heat_remain)			// 还要继续加热，每行刚开始加热或者一个步进内加热时间足够时此条件不成立
   1120          		{
   1121          			if(tp.feed_time[tp.feed_step] > tp.heat_remain)	// 当前步进的时间足够加热
   1122          			{
   1123          				TPSetTimeCnt(tp.heat_remain);	// 加热
   1124          				tp.feed_time[tp.feed_step] -= tp.heat_remain;
   1125          				tp.heat_remain = 0;
   1126          				tp.state = TPSTATE_HEAT_WITHOUT_FEED;
   1127          			}
   1128          			else			// 时间不够或者刚好，先加热剩余时间//如果时间不够则走一步后继续跳入上一个if,刚好则跳入else
   1129          			{
   1130          				TPSetTimeCnt(tp.feed_time[tp.feed_step]); // 加热剩余时间
   1131          				tp.heat_remain -= tp.feed_time[tp.feed_step];
   1132          				tp.state = TPSTATE_HEAT_WITH_FEED;
   1133          				tp.feed_step++;
   1134          			}
   1135          		}
   1136          		else
   1137          		{
   1138          			if(tp.heat_cnt < tp.heat_max_cnt)	// 已经有数据被送给打印机
   1139          			{
   1140          				tp.heat_cnt++;
   1141          				LATCH_LOW();
   1142          				LATCH_HIGH();
   1143          				STROBE_0_ON();
   1144          				STROBE_1_ON();
   1145          				if(tp.heat_cnt < tp.heat_max_cnt)	// 还有数据需要送到打印机
   1146          				{
   1147          					TPDataDMAShiftToPrn();		// shift next heat data to printer
   1148          				}
   1149          				if(tp.feed_time[tp.feed_step] > tp.heat)	// 当前步进的时间足够加热
   1150          				{
   1151          					TPSetTimeCnt(tp.heat);	// 加热
   1152          					tp.feed_time[tp.feed_step] -= tp.heat;
   1153          					tp.state = TPSTATE_HEAT_WITHOUT_FEED;
   1154          				}
   1155          				else			// 时间不够或者刚好，先加热剩余时间
   1156          				{
   1157          					TPSetTimeCnt(tp.feed_time[tp.feed_step]);	// 加热剩余时间
   1158          					tp.heat_remain = tp.heat - tp.feed_time[tp.feed_step];
   1159          					tp.state = TPSTATE_HEAT_WITH_FEED;
   1160          					tp.feed_step++;
   1161          				}
   1162          			}
   1163          			else	// no any data need to print//本行加热次数完成
   1164          			{
   1165          				//trip2();
   1166          				//strobe_off:
   1167          				STROBE_0_OFF(); 	// stop heat
   1168          				STROBE_1_OFF(); 	// stop heat
   1169          				TPSetTimeCnt(tp.feed_time[tp.feed_step]);   // 停止加热时间//最后一次加热会出现这种情况，加热次数完成还有剩余步进时间
   1170          #if TP_MAX_STROBE_STEP>1
   1171          				if(tp.feed_step < (TP_MAX_STROBE_STEP-1))		// 每个加热Strobe中包含的步进数
   1172          				{
   1173          					tp.feed_step++;
   1174          					tp.state = TPSTATE_HEAT_WITH_FEED;
   1175          				}
   1176          				else	// 完成一个加热Strobe的控制
   1177          #endif
   1178          				{
   1179          					tp.feed_step = 0;
   1180          #if TP_MAX_HEAT_STROBE>1
   1181          					if(tp.strobe_step < (TP_MAX_HEAT_STROBE-1))
   1182          					{
   1183          						tp.strobe_step++;
   1184          						TPDataShiftCntProc(tp.strobe_step);		// 计算下一个加热行
   1185          						if(tp.heat_cnt < tp.heat_max_cnt)
   1186          						{
   1187          							TPDataDMAShiftToPrn();		// 开始送数据到打印机
   1188          						}
   1189          						tp.state = TPSTATE_HEAT_WITH_FEED;
   1190          					}
   1191          					else	// 当前点行打印完成
   1192          #endif
   1193          					{
   1194          						tp.tail = (tp.tail+1) & (ARRAY_SIZE(TP_dot)-1);
   1195          						switch(TPCheckBuf())
   1196          						{
   1197          						case 0: 	// no data
   1198          							//TPIntSetPreIdle();
   1199          							break;
   1200          						case 1:
   1201          						case 2:
   1202          						case 3:
   1203          							break;
   1204          						default:	// bug
   1205          							TPIntSetIdle();
   1206          							break;
   1207          						}
   1208          					}
   1209          				}
   1210          			}
   1211          		}
   1212          		break;
   1213          	case TPSTATE_FEED:
   1214          		if (TPFeedStep() == 0)
   1215          		{
   1216          			switch(TPCheckBuf())
   1217          			{
   1218          			case 0:		// no data
   1219          				//TPIntSetPreIdle();
   1220          				break;
   1221          			case 1:
   1222          			case 2:
   1223          			case 3:
   1224          				break;
   1225          			default:	// bug
   1226          				TPIntSetIdle();
   1227          				break;
   1228          			}
   1229          		}
   1230          		break;
   1231          	case TPSTATE_FEED_TO_MARK:
   1232          		TPSetTimeCnt(TPGetStepTime());  // set timer
   1233          		if(TPFeedStep())
   1234          		{
   1235          			if(TPPrinterMark() == FALSE)        // find mark
   1236          			{
   1237          				tp.state = TPSTATE_FEED_FIND_MARK;
   1238          			}
   1239          		}
   1240          		else
   1241          		{
   1242          			TPCheckBuf();
   1243          		}
   1244          		break;
   1245          	case TPSTATE_FEED_FIND_MARK:
   1246          		TPSetTimeCnt(TPGetStepTime());  // set timer
   1247          		if(TPFeedStep())
   1248          		{
   1249          			if(TPPrinterMark() == TRUE)     // space
   1250          			{
   1251          				//tp.feedmax = esc_sts.line_after_mark;
   1252          				tp.feedmax = g_param.line_after_mark;
   1253          				tp.state = TPSTATE_FEED_AFTERMARK;
   1254          			}
   1255          		}
   1256          		else
   1257          		{
   1258          			TPCheckBuf();
   1259          		}
   1260          		break;
   1261          	case TPSTATE_FEED_AFTERMARK:
   1262          		TPSetTimeCnt(TPGetStepTime());  // set timer
   1263          		if(TPFeedStep() == 0)
   1264          		{
   1265          			TPCheckBuf();
   1266          		}
   1267          		break;
   1268          	case TPSTATE_WAIT_TIME:
   1269          		if(--tp.repeat == 0 )
   1270          		{
   1271          			TPCheckBuf();
   1272          		}
   1273          		break;
   1274          	case TPSTATE_PRE_IDLE:
   1275          		TPSetTimeCnt(TIMER1_MS_TO_CNT(1.0));
   1276          		if(tp.feedmax)
   1277          		{
   1278          			tp.feedmax--;
   1279          			if(tp.feedmax & 0x01)
   1280          			{
   1281          				PRN_POWER_CHARGE();
   1282          			}
   1283          			else
   1284          			{
   1285          				PRN_POWER_DISCHARGE();
   1286          			}
   1287          		}
   1288          		else
   1289          		{
   1290          			tp.accel = 0;				// 下次需要退纸，重新开始缓启动
   1291          			switch(TPCheckBuf())
   1292          			{
   1293          			case 0:		// no data
   1294          			default:	// bug
   1295          				TPIntSetIdle();
   1296          				break;
   1297          			case 1:
   1298          			case 2:
   1299          			case 3:
   1300          				break;
   1301          			}
   1302          		}
   1303          		break;
   1304          	default:
   1305          		tp.state = TPSTATE_IDLE;
   1306          		//break;
   1307          	case TPSTATE_IDLE:
   1308          		TPIntSetIdle();
   1309          		break;
   1310          	}
   1311          }
   1312          
   1313          
   1314          void TIM3_IRQ_Handle(void)
   1315          {
   1316          	//trip1();
   1317          	//TIM3->CR1 &= ~0x0001;
   1318          	PRN_POWER_DISCHARGE();
   1319          	PRN_POWER_CHARGE();
   1320          	TPISRProc();
   1321          	//TIM3->CR1 |= 0x0001;
   1322          }
   1323          
   1324          extern void TPSetSpeed(uint8_t speed)
   1325          {
   1326          	uint16_t const TPHeatTbl[] =
   1327          	{
   1328          		TIMER1_MS_TO_CNT(0.50), // 0
   1329          		TIMER1_MS_TO_CNT(0.60), // 1
   1330          		TIMER1_MS_TO_CNT(0.70), // 2
   1331          		TIMER1_MS_TO_CNT(0.80), // 3
   1332          		TIMER1_MS_TO_CNT(0.90),	// 4
   1333          		TIMER1_MS_TO_CNT(1.00), // 5
   1334          		TIMER1_MS_TO_CNT(1.20), // 6
   1335          		TIMER1_MS_TO_CNT(1.40), // 7
   1336          		TIMER1_MS_TO_CNT(1.50), // 8
   1337          		TIMER1_MS_TO_CNT(1.60), // 9                
   1338          		TIMER1_MS_TO_CNT(1.80), // 10
   1339          		TIMER1_MS_TO_CNT(2.00), // 11
   1340          		TIMER1_MS_TO_CNT(2.50), // 12
   1341          		TIMER1_MS_TO_CNT(3.00), // 13
   1342          		TIMER1_MS_TO_CNT(3.50), // 14
   1343          		TIMER1_MS_TO_CNT(4.00), // 15
   1344          		TIMER1_MS_TO_CNT(4.50), // 16
   1345          		TIMER1_MS_TO_CNT(5.00), // 17
   1346          
   1347          	};
   1348          	if (speed < ARRAY_SIZE(TPHeatTbl))
   1349          	{
   1350          		tp.heat_setting = TPHeatTbl[speed];
   1351          	}
   1352          }
   1353          
   1354          
   1355          
   1356          extern void SetDesity(void)
   1357          {
   1358          #if defined(LOW_5V_PRINT)
   1359          	TPSetSpeed(17);
   1360          #else
   1361          #if defined(HIGH_8V_PRINT)
   1362          	TPSetSpeed(4);
   1363          #else
   1364          	TPSetSpeed(10);//10
   1365          #endif
   1366          #endif
   1367          }
   1368          //======================================================================================================
   1369          extern void Wake_up(void)
   1370          {
   1371          	tp.state = TPSTATE_WAIT_TIME;
   1372          	tp.accel = 0;
   1373          	tp.repeat =200;
   1374          
   1375          	MOTOR_PWR_ON();
   1376          	//TIM_SetAutoreload(TIM3,TIMER1_MS_TO_CNT(5.00));
   1377          	TIM3->ARR = TIMER1_MS_TO_CNT(5.00);
   1378          	//TIM_SetCounter(TIM3,0);
   1379          	TIM3->CNT = 0;
   1380          	ENABLE_TIMER_INTERRUPT();
   1381          }
   1382          static void TPStart(void)
   1383          {
   1384          	uint8_t i;
   1385          	uint32_t delay;
   1386          
   1387          	tp.state = TPSTATE_START;
   1388          	tp.accel = 0;
   1389          
   1390          	for(i=0; i<6; i++)
   1391          	{
   1392          		PRN_POWER_CHARGE();
   1393          		delay = 30000;
   1394          		while(delay--);
   1395          		PRN_POWER_DISCHARGE();
   1396          		delay = 10000;
   1397          		while(delay--);
   1398          	}
   1399          	//TIM_SetAutoreload(TIM3,TpAccelerationSteps[0])
   1400          	TIM3->ARR = TpAccelerationSteps[0];
   1401          	PRN_POWER_CHARGE();
   1402          	//TIM_SetCounter(TIM3,0);
   1403          	TIM3->CNT = 0;
   1404          	ENABLE_TIMER_INTERRUPT();
   1405          }
   1406          
   1407          extern void TPReStart(void)
   1408          {
   1409          	uint8_t i;
   1410          	uint32_t delay;
   1411          
   1412          	if(tp.pause)
   1413          	{
   1414          		if (tp.head != tp.tail)
   1415          		{
   1416          			for(i=0; i<6; i++)
   1417          			{
   1418          				PRN_POWER_CHARGE();
   1419          				delay = 30000;
   1420          				while(delay--);
   1421          				PRN_POWER_DISCHARGE();
   1422          				delay = 10000;
   1423          				while(delay--);
   1424          
   1425          			}
   1426          			PRN_POWER_CHARGE();
   1427          
   1428          			tp.state = TPSTATE_START;
   1429          			tp.accel = 0;
   1430          			//TIM_SetAutoreload(TIM3,TpAccelerationSteps[0])
   1431          			TIM3->ARR = TpAccelerationSteps[0];
   1432          			PRN_POWER_CHARGE();
   1433          			//TIM_SetCounter(TIM3,0);
   1434          			TIM3->CNT = 0;
   1435          			ENABLE_TIMER_INTERRUPT();
   1436          		}
   1437          	}
   1438          }
   1439          
   1440          //======================================================================================================
   1441          static void TPPrintCmdToBuf(uint8_t cmd, uint8_t *dot, uint8_t len)
   1442          {
   1443          	uint32_t head;
   1444          	head = (tp.head+1) & (ARRAY_SIZE(TP_dot)-1);
   1445          	while (head == tp.tail)
   1446          	{
   1447          		// 因为打印中断处理程序有可能在异常的情况下进入Idle状态，所以需要不断检查这个状态
   1448          		event_proc();
   1449          	}
   1450          
   1451          	if (clr_all_dot == 1)
   1452          	{
   1453          		clr_all_dot = 0;
   1454          		return;
   1455          	}
   1456          
   1457          	MEMCPY(TP_dot[tp.head & (ARRAY_SIZE(TP_dot)-1)], dot, len);
   1458          	TP_dot[tp.head][LineDot/8] = cmd;
   1459          	tp.head = head;
   1460          	if ((TPPrinterReady() && (tp.state == TPSTATE_IDLE)))//启动只有从IDE状态起来
   1461          	{
   1462          		TPStart();
   1463          	}
   1464          }
   1465          //======================================================================================================
   1466          extern void TPPrintLine(uint8_t *dot)
   1467          {
   1468          	TPPrintCmdToBuf(TP_CMD_PRINT_DOTLINE, dot, LineDot/8);
   1469          }
   1470          //======================================================================================================
   1471          extern void TPFeedLine(uint16_t line)
   1472          {
   1473          #ifdef Half_Step
   1474          	line <<= 2;		// 一个点行等于4步
   1475          #else
   1476          	line <<= 1;		// 一个点行等于2步
   1477          #endif
   1478          	TPPrintCmdToBuf(TP_CMD_FEED, (uint8_t *)(&line), sizeof(line));
   1479          }
   1480          //======================================================================================================
   1481          extern void TPFeedToMark(uint16_t line)
   1482          {
   1483          	line <<= 1;		// 一个点行等于两步
   1484          	TPPrintCmdToBuf(TP_CMD_FEED_TO_MARK, (uint8_t *)(&line), sizeof(line));
   1485          }
   1486          
   1487          extern uint32_t TPCheckBusy(void)
   1488          {
   1489          	if (tp.state == TPSTATE_IDLE)
   1490          	{
   1491          		return FALSE;
   1492          	}
   1493          	return TRUE;
   1494          }
   1495          //======================================================================================================
   1496          extern void TPFeedStart(void)
   1497          {
   1498          	if (tp.state == TPSTATE_IDLE)
   1499          	{
   1500          		TPFeedLine(500*8);		// 500mm
   1501          	}
   1502          }
   1503          //======================================================================================================
   1504          extern void TPFeedToMarkStart(void)
   1505          {
   1506          	if (tp.state == TPSTATE_IDLE)
   1507          	{
   1508          		TPFeedToMark(250*8);		// 250mm
   1509          	}
   1510          }
   1511          //======================================================================================================
   1512          extern void TPFeedStop(void)
   1513          {
   1514          	tp.feedmax = 0;		// interrupt will stop feed automaticcly
   1515          }
   1516          //======================================================================================================
   1517          extern uint8_t IsPrintBufEmpty(void)
   1518          {
   1519          	if(tp.head != tp.tail)	// have data
   1520          	{
   1521          		return 0;
   1522          	}
   1523          	else
   1524          	{
   1525          		return 1;
   1526          	}
   1527          }
   1528          void TPPrintAsciiLine(char *buf, uint32_t len)
   1529          {
   1530          	PrintBufPushLine((uint8_t *)buf, len);
   1531          }
   1532          extern uint8_t IsPrinterIdle(void)
   1533          {
   1534          	if(tp.state == TPSTATE_IDLE)
   1535          	{
   1536          		return 1;
   1537          	}
   1538          	else
   1539          	{
   1540          		return 0;
   1541          	}
   1542          }
   1543          
   1544          extern void TPPrintTestPage(void)
   1545          {
   1546          
   1547          	uint32_t len,i;
   1548          	char buf[64];
   1549          
   1550          	//debug_cnt = 0;
   1551          	current_channel = 0;
   1552          	PrintBufToZero();
   1553          	len = snprintf(buf, sizeof(buf),  "\n");
   1554          	TPPrintAsciiLine(buf,len);
   1555          #if 1
   1556          #if defined(PT486)
   1557          	len = snprintf(buf, sizeof(buf), "System: HJ_PT486_KT100\n");
   1558          #elif defined(PT488)
   1559          	len = snprintf(buf, sizeof(buf), "System: PT488_1MB1\n");
   1560          #elif defined(PT48D)
   1561          	len = snprintf(buf, sizeof(buf), "System: PT48D\n");
   1562          #elif defined(PT48F)
   1563          	len = snprintf(buf, sizeof(buf), "System: PT48F\n");
   1564          #elif defined(PT48G)
   1565          	len = snprintf(buf, sizeof(buf), "System: PT48G\n");
   1566          #endif
   1567          	TPPrintAsciiLine(buf,len);
   1568          
   1569          
   1570          	len = snprintf(buf, sizeof(buf), "Firmware:%d.%02d.%02d \n", VERSION_MAJOR, VERSION_MINOR,VERSION_TEST);
   1571          	TPPrintAsciiLine(buf,len);
   1572          
   1573          	len = snprintf(buf, sizeof(buf), "Build date: %s\n", __DATE__);
   1574          	TPPrintAsciiLine(buf,len);
   1575          
   1576          	len = snprintf(buf, sizeof(buf), "Build time: %s\n", __TIME__);
   1577          	TPPrintAsciiLine(buf,len);
   1578          
   1579          	len = snprintf(buf, sizeof(buf),  "\n");
   1580          	TPPrintAsciiLine(buf,len);
   1581          
   1582          	//len = snprintf(buf, sizeof(buf),  "[Uart Configure]\n");
   1583          	//TPPrintAsciiLine(buf,len);
   1584          
   1585          	//len = snprintf(buf, sizeof(buf),  "baudrate : %ld\n", 115200);
   1586          	//TPPrintAsciiLine(buf,len);
   1587          
   1588          	//len = snprintf(buf, sizeof(buf),  "flow ctrl : HW Flow Control\n");
   1589          	//TPPrintAsciiLine(buf,len);
   1590          
   1591          	len = snprintf(buf, sizeof(buf),  "[BT Module config]\n");
   1592          	TPPrintAsciiLine(buf,len);
   1593          
   1594          	len = snprintf(buf, sizeof(buf),  "%d BT Module Support\n",MAX_BT_CHANNEL);
   1595          	TPPrintAsciiLine(buf,len);
   1596          
   1597          	len = snprintf(buf, sizeof(buf),  "    Seq      |    Name    | Pin\n");
   1598          	TPPrintAsciiLine(buf,len);
   1599          
   1600          	for (i = 0;i<MAX_BT_CHANNEL;i++)
   1601          	{
   1602          		len = snprintf(buf, sizeof(buf),  "BT Module(%d):|HJ Printer%d | 0000\n",i+1,i+1);
   1603          		TPPrintAsciiLine(buf,len);
   1604          	}
   1605          
   1606          	len = snprintf(buf, sizeof(buf),  "\n");
   1607          	TPPrintAsciiLine(buf,len);
   1608          
   1609          	len = snprintf(buf, sizeof(buf),  "[Install Fonts]\n");
   1610          	TPPrintAsciiLine(buf,len);
   1611          
   1612          	len = snprintf(buf, sizeof(buf),  "ID  Font Name\n");
   1613          	TPPrintAsciiLine(buf,len);
   1614          
   1615          
   1616          	//if(esc_sts[current_channel].font_en == FONT_A_WIDTH)
   1617          	{
   1618          		len = snprintf(buf, sizeof(buf),  " 0  SYSTEM 12x24\n");
   1619          		TPPrintAsciiLine(buf,len);
   1620          	}
   1621          	//else
   1622          	{
   1623          #if defined(FONTB_ASCII9X24)
   1624          		len = snprintf(buf, sizeof(buf),  " 1  SYSTEM 9x24\n");
   1625          #else
   1626          		len = snprintf(buf, sizeof(buf),  " 1  SYSTEM 8x16\n");
   1627          #endif
   1628          		TPPrintAsciiLine(buf,len);
   1629          	}
   1630          	len = snprintf(buf, sizeof(buf),  " 2  GBK 24x24\n");
   1631          	TPPrintAsciiLine(buf,len);
   1632          
   1633          	len = snprintf(buf, sizeof(buf),  " 3  GBK 16x16\n");
   1634          	TPPrintAsciiLine(buf,len);
   1635          
   1636          	len = snprintf(buf, sizeof(buf),  "\n");
   1637          	TPPrintAsciiLine(buf,len);
   1638          
   1639          	len = snprintf(buf, sizeof(buf),  "[ASCII Samples]\n");
   1640          	TPPrintAsciiLine(buf,len);
   1641          
   1642          	for(i=0x20; i<0x80; i++)
   1643          	{
   1644          		PrintBufPushBytes(i);
   1645          	}
   1646          	len = snprintf(buf, sizeof(buf),  "\n\n");
   1647          	TPPrintAsciiLine(buf,len);
   1648          
   1649          	len = snprintf(buf, sizeof(buf),  "[GBK Samples]\n");
   1650          	TPPrintAsciiLine(buf,len);
   1651          
   1652          	len = snprintf(buf, sizeof(buf),  "中文字库测试：简体字 繁w字\n");
   1653          	TPPrintAsciiLine(buf,len);
   1654          	len = snprintf(buf, sizeof(buf),  "\n");
   1655          	TPPrintAsciiLine(buf,len);
   1656          
   1657          	len = snprintf(buf, sizeof(buf),  "Selftest Finished.\n");
   1658          	TPPrintAsciiLine(buf,len);
   1659          #endif
   1660          
   1661          	len = snprintf(buf, sizeof(buf),  "\n\n\n\n\n");
   1662          	TPPrintAsciiLine(buf,len);
   1663          
   1664          
   1665          }
   1666          
   1667          
   1668          extern void TPSelfTest2(void)
   1669          {//打印斜线
   1670          	uint8_t dot[LineDot/8];
   1671          	uint32_t i,j;
   1672          	MEMSET(dot, 0, sizeof(dot));
   1673          	for (i=0;i<100;i++)// 400
   1674          	{
   1675          		for (j=0;j<8;j++)
   1676          		{
   1677          			MEMSET(dot,0x01<<j,sizeof(dot));
   1678          			TPPrintLine(dot);
   1679          		}
   1680          	}
   1681          }
   1682          
   1683          
   1684          
   1685          void test_motor(void)
   1686          {
   1687          	int i,delay,cnt = 50000;
   1688          	MOTOR_PWR_ON();
   1689          	for(i=0; i<6; i++)
   1690          	{
   1691          		PRN_POWER_CHARGE();
   1692          		delay = 30000;
   1693          		while(delay--);
   1694          		PRN_POWER_DISCHARGE();
   1695          		delay = 10000;
   1696          		while(delay--);
   1697          	}
   1698          
   1699          	while (cnt)
   1700          	{
   1701          		TPForwardStep(1);
   1702          		delay_ms(1);
   1703          		cnt--;
   1704          	}
   1705          	MOTOR_PWR_OFF();
   1706          }

   Maximum stack usage in bytes:

     Function            .cstack
     --------            -------
     IsPrintBufEmpty          0
     IsPrinterIdle            0
     MaxHeatDotsAdj           0
     SetDesity                8
     TIM3_IRQ_Handle          8
     TPAdjustStepTime        16
     TPCheckBuf               8
     TPCheckBusy              0
     TPDataDMAShiftToPrn      8
     TPDataShiftCntProc      32
     TPDataShiftOut          16
     TPFeedLine               8
     TPFeedStart              8
     TPFeedStep               8
     TPFeedStop               0
     TPFeedToMark             8
     TPFeedToMarkStart        8
     TPForwardStep            8
     TPGetStepTime            0
     TPHeatDotsAdj           32
     TPHeatPreLineAdj         0
     TPHeatThermalAdj         0
     TPHeatVoltageAdj         0
     TPISRProc                8
     TPInit                  24
     TPIntSetIdle             8
     TPIntSetPreIdle          0
     TPPrintAsciiLine         8
     TPPrintCmdToBuf         24
     TPPrintLine              8
     TPPrintTestPage         80
     TPReStart                8
     TPSelfTest2             64
     TPSetSpeed              48
     TPSetTimeCnt             0
     TPStart                  8
     WakeUpTP_MODE1          16
     Wake_up                  8
     test_motor               8


   Section sizes:

     Function/Label                                 Bytes
     --------------                                 -----
     tp                                              392
     TP_dot                                          784
     Byte2DotNumTbl                                  256
     clr_all_dot                                       1
     TPInit                                          312
     WakeUpTP_MODE1                                  208
     TPForwardStep                                   384
     TpAccelerationSteps                             336
     TPHeatVoltageAdj                                  2
     TPHeatThermalAdj                                 76
     Temperater_Ratio                                108
     TPHeatPreLineAdj                                  2
     TPHeatDotsAdj                                    68
     TPAdjustStepTime                                272
     TPGetStepTime                                    48
     TPSetTimeCnt                                     16
     TPFeedStep                                       72
     TPIntSetPreIdle                                  34
     TPIntSetIdle                                     40
     MaxHeatDotsAdj                                   34
     TPDataShiftCntProc                              388
     TPDataShiftOut                                   28
     TPDataDMAShiftToPrn                              26
     TPCheckBuf                                      382
     TPISRProc                                       892
     TIM3_IRQ_Handle                                  28
     TPSetSpeed                                       48
     SetDesity                                        10
     Wake_up                                          68
     TPStart                                         116
     TPReStart                                       144
     TPPrintCmdToBuf                                 128
     TPPrintLine                                      14
     TPFeedLine                                       24
     TPFeedToMark                                     24
     TPCheckBusy                                      20
     TPFeedStart                                      24
     TPFeedToMarkStart                                24
     TPFeedStop                                       12
     IsPrintBufEmpty                                  24
     TPPrintAsciiLine                                  8
     IsPrinterIdle                                    20
     TPPrintTestPage                                 616
     TPSelfTest2                                      56
     test_motor                                       96
     ??DataTable14                                     4
     ??DataTable19                                     4
     ??DataTable41                                     4
     ??DataTable46                                     4
     ??DataTable65                                     4
     ??DataTable69                                     4
     ??DataTable80                                     4
     ??DataTable119                                    4
     ??DataTable123                                    4
     ??DataTable131                                    4
     ??DataTable141                                    4
     ?<Constant {70, 74, 78, 82, 86, 88, 90, 92, 93   16
     ?<Constant {499, 599, 699, 799, 899, 999, 1199   36
     ?<Constant "\n">                                  2
     ?<Constant "System: HJ_PT486_KT100\n">           24
     ?<Constant "Firmware:%d.%02d.%02d \n">           24
     ?<Constant "Build date: %s\n">                   16
     ?<Constant "Dec 10 2015">                        12
     ?<Constant "Build time: %s\n">                   16
     ?<Constant "18:37:18">                           12
     ?<Constant "[BT Module config]\n">               20
     ?<Constant "%d BT Module Support\n">             24
     ?<Constant "    Seq      |    Nam...">           36
     ?<Constant "BT Module(%d):|HJ Pri...">           36
     ?<Constant "[Install Fonts]\n">                  20
     ?<Constant "ID  Font Name\n">                    16
     ?<Constant " 0  SYSTEM 12x24\n">                 20
     ?<Constant " 1  SYSTEM 8x16\n">                  20
     ?<Constant " 2  GBK 24x24\n">                    16
     ?<Constant " 3  GBK 16x16\n">                    16
     ?<Constant "[ASCII Samples]\n">                  20
     ?<Constant "\n\n">                                4
     ?<Constant "[GBK Samples]\n">                    16
     ?<Constant "\326\320\316\304\327\326\277\342\2   32
     ?<Constant "Selftest Finished.\n">               20
     ?<Constant "\n\n\n\n\n">                          8

 
 1 177 bytes in section .bss
 1 182 bytes in section .rodata
 4 832 bytes in section .text
 
 4 832 bytes of CODE  memory
 1 182 bytes of CONST memory
 1 177 bytes of DATA  memory

Errors: none
Warnings: 3
