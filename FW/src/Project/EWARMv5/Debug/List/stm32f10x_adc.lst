###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     10/Dec/2015  18:37:28 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\BT Printer\FW\src\Lib\src\stm32f10x_adc.c             #
#    Command line =  "E:\BT Printer\FW\src\Lib\src\stm32f10x_adc.c" -D        #
#                    DEBUG_VER -lcN "E:\BT Printer\FW\src\Project\EWARMv5\Deb #
#                    ug\List\" -o "E:\BT Printer\FW\src\Project\EWARMv5\Debug #
#                    \Obj\" --no_cse --no_unroll --no_inline                  #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None -I "E:\BT Printer\FW\src\Project\EWARMv5\. #
#                    .\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\App\" #
#                     -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\Drivers\ #
#                    " -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\FatFs\" #
#                     -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\Lib\inc\ #
#                    " -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS\uC #
#                    -CPU\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uC #
#                    OS\uC-LIB\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\ #
#                    ..\uCOS\uCOS-II\Ports\" -I "E:\BT                        #
#                    Printer\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Source #
#                    \" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\..\uCOS\u #
#                    C-Probe\" -I "E:\BT Printer\FW\src\Project\EWARMv5\..\.. #
#                    \usb_lib\" -I "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 5.4\arm\INC\" -Ol                              #
#    List file    =  E:\BT Printer\FW\src\Project\EWARMv5\Debug\List\stm32f10 #
#                    x_adc.lst                                                #
#    Object file  =  E:\BT Printer\FW\src\Project\EWARMv5\Debug\Obj\stm32f10x #
#                    _adc.o                                                   #
#                                                                             #
#                                                                             #
###############################################################################

E:\BT Printer\FW\src\Lib\src\stm32f10x_adc.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : stm32f10x_adc.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.0.3
      5          * Date               : 09/22/2008
      6          * Description        : This file provides all the ADC firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          /* Includes ------------------------------------------------------------------*/
     17          #include "stm32f10x_adc.h"
     18          #include "stm32f10x_rcc.h"
     19          
     20          /* Private typedef -----------------------------------------------------------*/
     21          /* Private define ------------------------------------------------------------*/
     22          /* ADC DISCNUM mask */
     23          #define CR1_DISCNUM_Reset           ((u32)0xFFFF1FFF)
     24          
     25          /* ADC DISCEN mask */
     26          #define CR1_DISCEN_Set              ((u32)0x00000800)
     27          #define CR1_DISCEN_Reset            ((u32)0xFFFFF7FF)
     28          
     29          /* ADC JAUTO mask */
     30          #define CR1_JAUTO_Set               ((u32)0x00000400)
     31          #define CR1_JAUTO_Reset             ((u32)0xFFFFFBFF)
     32          
     33          /* ADC JDISCEN mask */
     34          #define CR1_JDISCEN_Set             ((u32)0x00001000)
     35          #define CR1_JDISCEN_Reset           ((u32)0xFFFFEFFF)
     36          
     37          /* ADC AWDCH mask */
     38          #define CR1_AWDCH_Reset             ((u32)0xFFFFFFE0)
     39          
     40          /* ADC Analog watchdog enable mode mask */
     41          #define CR1_AWDMode_Reset           ((u32)0xFF3FFDFF)
     42          
     43          /* CR1 register Mask */
     44          #define CR1_CLEAR_Mask              ((u32)0xFFF0FEFF)
     45          
     46          /* ADC ADON mask */
     47          #define CR2_ADON_Set                ((u32)0x00000001)
     48          #define CR2_ADON_Reset              ((u32)0xFFFFFFFE)
     49          
     50          /* ADC DMA mask */
     51          #define CR2_DMA_Set                 ((u32)0x00000100)
     52          #define CR2_DMA_Reset               ((u32)0xFFFFFEFF)
     53          
     54          /* ADC RSTCAL mask */
     55          #define CR2_RSTCAL_Set              ((u32)0x00000008)
     56          
     57          /* ADC CAL mask */
     58          #define CR2_CAL_Set                 ((u32)0x00000004)
     59          
     60          /* ADC SWSTART mask */
     61          #define CR2_SWSTART_Set             ((u32)0x00400000)
     62          
     63          /* ADC EXTTRIG mask */
     64          #define CR2_EXTTRIG_Set             ((u32)0x00100000)
     65          #define CR2_EXTTRIG_Reset           ((u32)0xFFEFFFFF)
     66          
     67          /* ADC Software start mask */
     68          #define CR2_EXTTRIG_SWSTART_Set     ((u32)0x00500000)
     69          #define CR2_EXTTRIG_SWSTART_Reset   ((u32)0xFFAFFFFF)
     70          
     71          /* ADC JEXTSEL mask */
     72          #define CR2_JEXTSEL_Reset           ((u32)0xFFFF8FFF)
     73          
     74          /* ADC JEXTTRIG mask */
     75          #define CR2_JEXTTRIG_Set            ((u32)0x00008000)
     76          #define CR2_JEXTTRIG_Reset          ((u32)0xFFFF7FFF)
     77          
     78          /* ADC JSWSTART mask */
     79          #define CR2_JSWSTART_Set            ((u32)0x00200000)
     80          
     81          /* ADC injected software start mask */
     82          #define CR2_JEXTTRIG_JSWSTART_Set   ((u32)0x00208000)
     83          #define CR2_JEXTTRIG_JSWSTART_Reset ((u32)0xFFDF7FFF)
     84          
     85          /* ADC TSPD mask */
     86          #define CR2_TSVREFE_Set             ((u32)0x00800000)
     87          #define CR2_TSVREFE_Reset           ((u32)0xFF7FFFFF)
     88          
     89          /* CR2 register Mask */
     90          #define CR2_CLEAR_Mask              ((u32)0xFFF1F7FD)
     91          
     92          /* ADC SQx mask */
     93          #define SQR3_SQ_Set                 ((u32)0x0000001F)
     94          #define SQR2_SQ_Set                 ((u32)0x0000001F)
     95          #define SQR1_SQ_Set                 ((u32)0x0000001F)
     96          
     97          /* SQR1 register Mask */
     98          #define SQR1_CLEAR_Mask             ((u32)0xFF0FFFFF)
     99          
    100          /* ADC JSQx mask */
    101          #define JSQR_JSQ_Set                ((u32)0x0000001F)
    102          
    103          /* ADC JL mask */
    104          #define JSQR_JL_Set                 ((u32)0x00300000)
    105          #define JSQR_JL_Reset               ((u32)0xFFCFFFFF)
    106          
    107          /* ADC SMPx mask */
    108          #define SMPR1_SMP_Set               ((u32)0x00000007)
    109          #define SMPR2_SMP_Set               ((u32)0x00000007)
    110          
    111          /* ADC JDRx registers offset */
    112          #define JDR_Offset                  ((u8)0x28)
    113          
    114          /* ADC1 DR register base address */
    115          #define DR_ADDRESS                  ((u32)0x4001244C)
    116          
    117          /* Private macro -------------------------------------------------------------*/
    118          /* Private variables ---------------------------------------------------------*/
    119          /* Private function prototypes -----------------------------------------------*/
    120          /* Private functions ---------------------------------------------------------*/
    121          
    122          /*******************************************************************************
    123          * Function Name  : ADC_DeInit
    124          * Description    : Deinitializes the ADCx peripheral registers to their default
    125          *                  reset values.
    126          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    127          * Output         : None
    128          * Return         : None
    129          *******************************************************************************/
    130          void ADC_DeInit(ADC_TypeDef* ADCx)
    131          {
    132            /* Check the parameters */
    133            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    134          
    135            switch (*(u32*)&ADCx)
    136            {
    137              case ADC1_BASE:
    138                /* Enable ADC1 reset state */
    139                RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
    140                /* Release ADC1 from reset state */
    141                RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
    142                break;
    143              
    144              case ADC2_BASE:
    145                /* Enable ADC2 reset state */
    146                RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
    147                /* Release ADC2 from reset state */
    148                RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
    149                break;
    150                
    151              case ADC3_BASE:
    152                /* Enable ADC3 reset state */
    153                RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
    154                /* Release ADC3 from reset state */
    155                RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
    156                break; 
    157          
    158              default:
    159                break;
    160            }
    161          }
    162          
    163          /*******************************************************************************
    164          * Function Name  : ADC_Init
    165          * Description    : Initializes the ADCx peripheral according to the specified parameters
    166          *                  in the ADC_InitStruct.
    167          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    168          *                  - ADC_InitStruct: pointer to an ADC_InitTypeDef structure that
    169          *                    contains the configuration information for the specified
    170          *                    ADC peripheral.
    171          * Output         : None
    172          * Return         : None
    173          ******************************************************************************/
    174          void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
    175          {
    176            u32 tmpreg1 = 0;
    177            u8 tmpreg2 = 0;
    178          
    179            /* Check the parameters */
    180            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    181            assert_param(IS_ADC_MODE(ADC_InitStruct->ADC_Mode));
    182            assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
    183            assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));  		    
    184            assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));   
    185            assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
    186            assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));
    187          
    188            /*---------------------------- ADCx CR1 Configuration -----------------*/
    189            /* Get the ADCx CR1 value */
    190            tmpreg1 = ADCx->CR1;
    191            /* Clear DUALMOD and SCAN bits */
    192            tmpreg1 &= CR1_CLEAR_Mask;
    193            /* Configure ADCx: Dual mode and scan conversion mode */
    194            /* Set DUALMOD bits according to ADC_Mode value */
    195            /* Set SCAN bit according to ADC_ScanConvMode value */
    196            tmpreg1 |= (u32)(ADC_InitStruct->ADC_Mode | ((u32)ADC_InitStruct->ADC_ScanConvMode << 8));
    197            /* Write to ADCx CR1 */
    198            ADCx->CR1 = tmpreg1;
    199          
    200            /*---------------------------- ADCx CR2 Configuration -----------------*/
    201            /* Get the ADCx CR2 value */
    202            tmpreg1 = ADCx->CR2;
    203            /* Clear CONT, ALIGN and EXTSEL bits */
    204            tmpreg1 &= CR2_CLEAR_Mask;
    205            /* Configure ADCx: external trigger event and continuous conversion mode */
    206            /* Set ALIGN bit according to ADC_DataAlign value */
    207            /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
    208            /* Set CONT bit according to ADC_ContinuousConvMode value */
    209            tmpreg1 |= (u32)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
    210                      ((u32)ADC_InitStruct->ADC_ContinuousConvMode << 1));
    211            /* Write to ADCx CR2 */
    212            ADCx->CR2 = tmpreg1;
    213          
    214            /*---------------------------- ADCx SQR1 Configuration -----------------*/
    215            /* Get the ADCx SQR1 value */
    216            tmpreg1 = ADCx->SQR1;
    217            /* Clear L bits */
    218            tmpreg1 &= SQR1_CLEAR_Mask;
    219            /* Configure ADCx: regular channel sequence length */
    220            /* Set L bits according to ADC_NbrOfChannel value */
    221            tmpreg2 |= (ADC_InitStruct->ADC_NbrOfChannel - 1);
    222            tmpreg1 |= ((u32)tmpreg2 << 20);
    223            /* Write to ADCx SQR1 */
    224            ADCx->SQR1 = tmpreg1;
    225          }
    226          
    227          /*******************************************************************************
    228          * Function Name  : ADC_StructInit
    229          * Description    : Fills each ADC_InitStruct member with its default value.
    230          * Input          : ADC_InitStruct : pointer to an ADC_InitTypeDef structure
    231          *                  which will be initialized.
    232          * Output         : None
    233          * Return         : None
    234          *******************************************************************************/
    235          void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
    236          {
    237            /* Reset ADC init structure parameters values */
    238            /* Initialize the ADC_Mode member */
    239            ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
    240          
    241            /* initialize the ADC_ScanConvMode member */
    242            ADC_InitStruct->ADC_ScanConvMode = DISABLE;
    243          
    244            /* Initialize the ADC_ContinuousConvMode member */
    245            ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
    246          
    247            /* Initialize the ADC_ExternalTrigConv member */
    248            ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
    249          
    250            /* Initialize the ADC_DataAlign member */
    251            ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
    252          
    253            /* Initialize the ADC_NbrOfChannel member */
    254            ADC_InitStruct->ADC_NbrOfChannel = 1;
    255          }
    256          
    257          /*******************************************************************************
    258          * Function Name  : ADC_Cmd
    259          * Description    : Enables or disables the specified ADC peripheral.
    260          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    261          *                  - NewState: new state of the ADCx peripheral. This parameter
    262          *                    can be: ENABLE or DISABLE.
    263          * Output         : None
    264          * Return         : None
    265          *******************************************************************************/
    266          void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    267          {
    268            /* Check the parameters */
    269            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    270            assert_param(IS_FUNCTIONAL_STATE(NewState));
    271          
    272            if (NewState != DISABLE)
    273            {
    274              /* Set the ADON bit to wake up the ADC from power down mode */
    275              ADCx->CR2 |= CR2_ADON_Set;
    276            }
    277            else
    278            {
    279              /* Disable the selected ADC peripheral */
    280              ADCx->CR2 &= CR2_ADON_Reset;
    281            }
    282          }
    283          
    284          /*******************************************************************************
    285          * Function Name  : ADC_DMACmd
    286          * Description    : Enables or disables the specified ADC DMA request.
    287          * Input          : - ADCx: where x can be 1 or 3 to select the ADC peripheral.
    288          *                    Note: ADC2 hasn't a DMA capability.
    289          *                  - NewState: new state of the selected ADC DMA transfer.
    290          *                    This parameter can be: ENABLE or DISABLE.
    291          * Output         : None
    292          * Return         : None
    293          *******************************************************************************/
    294          void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    295          {
    296            /* Check the parameters */
    297            assert_param(IS_ADC_DMA_PERIPH(ADCx));
    298            assert_param(IS_FUNCTIONAL_STATE(NewState));
    299          
    300            if (NewState != DISABLE)
    301            {
    302              /* Enable the selected ADC DMA request */
    303              ADCx->CR2 |= CR2_DMA_Set;
    304            }
    305            else
    306            {
    307              /* Disable the selected ADC DMA request */
    308              ADCx->CR2 &= CR2_DMA_Reset;
    309            }
    310          }
    311          
    312          /*******************************************************************************
    313          * Function Name  : ADC_ITConfig
    314          * Description    : Enables or disables the specified ADC interrupts.
    315          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    316          *                  - ADC_IT: specifies the ADC interrupt sources to be enabled
    317          *                    or disabled. 
    318          *                    This parameter can be any combination of the following values:
    319          *                       - ADC_IT_EOC: End of conversion interrupt mask
    320          *                       - ADC_IT_AWD: Analog watchdog interrupt mask
    321          *                       - ADC_IT_JEOC: End of injected conversion interrupt mask
    322          *                  - NewState: new state of the specified ADC interrupts.
    323          *                    This parameter can be: ENABLE or DISABLE.
    324          * Output         : None
    325          * Return         : None
    326          *******************************************************************************/
    327          void ADC_ITConfig(ADC_TypeDef* ADCx, u16 ADC_IT, FunctionalState NewState)
    328          {
    329            u8 itmask = 0;
    330          
    331            /* Check the parameters */
    332            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    333            assert_param(IS_FUNCTIONAL_STATE(NewState));
    334            assert_param(IS_ADC_IT(ADC_IT));
    335          
    336            /* Get the ADC IT index */
    337            itmask = (u8)ADC_IT;
    338          
    339            if (NewState != DISABLE)
    340            {
    341              /* Enable the selected ADC interrupts */
    342              ADCx->CR1 |= itmask;
    343            }
    344            else
    345            {
    346              /* Disable the selected ADC interrupts */
    347              ADCx->CR1 &= (~(u32)itmask);
    348            }
    349          }
    350          
    351          /*******************************************************************************
    352          * Function Name  : ADC_ResetCalibration
    353          * Description    : Resets the selected ADC calibration registers.
    354          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    355          * Output         : None
    356          * Return         : None
    357          *******************************************************************************/
    358          void ADC_ResetCalibration(ADC_TypeDef* ADCx)
    359          {
    360            /* Check the parameters */
    361            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    362          
    363            /* Resets the selected ADC calibartion registers */  
    364            ADCx->CR2 |= CR2_RSTCAL_Set;
    365          }
    366          
    367          /*******************************************************************************
    368          * Function Name  : ADC_GetResetCalibrationStatus
    369          * Description    : Gets the selected ADC reset calibration registers status.
    370          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    371          * Output         : None
    372          * Return         : The new state of ADC reset calibration registers (SET or RESET).
    373          *******************************************************************************/
    374          FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)
    375          {
    376            FlagStatus bitstatus = RESET;
    377          
    378            /* Check the parameters */
    379            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    380          
    381            /* Check the status of RSTCAL bit */
    382            if ((ADCx->CR2 & CR2_RSTCAL_Set) != (u32)RESET)
    383            {
    384              /* RSTCAL bit is set */
    385              bitstatus = SET;
    386            }
    387            else
    388            {
    389              /* RSTCAL bit is reset */
    390              bitstatus = RESET;
    391            }
    392          
    393            /* Return the RSTCAL bit status */
    394            return  bitstatus;
    395          }
    396          
    397          /*******************************************************************************
    398          * Function Name  : ADC_StartCalibration
    399          * Description    : Starts the selected ADC calibration process.
    400          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    401          * Output         : None
    402          * Return         : None
    403          *******************************************************************************/
    404          void ADC_StartCalibration(ADC_TypeDef* ADCx)
    405          {
    406            /* Check the parameters */
    407            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    408          
    409            /* Enable the selected ADC calibration process */  
    410            ADCx->CR2 |= CR2_CAL_Set;
    411          }
    412          
    413          /*******************************************************************************
    414          * Function Name  : ADC_GetCalibrationStatus
    415          * Description    : Gets the selected ADC calibration status.
    416          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    417          * Output         : None
    418          * Return         : The new state of ADC calibration (SET or RESET).
    419          *******************************************************************************/
    420          FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)
    421          {
    422            FlagStatus bitstatus = RESET;
    423          
    424            /* Check the parameters */
    425            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    426          
    427            /* Check the status of CAL bit */
    428            if ((ADCx->CR2 & CR2_CAL_Set) != (u32)RESET)
    429            {
    430              /* CAL bit is set: calibration on going */
    431              bitstatus = SET;
    432            }
    433            else
    434            {
    435              /* CAL bit is reset: end of calibration */
    436              bitstatus = RESET;
    437            }
    438          
    439            /* Return the CAL bit status */
    440            return  bitstatus;
    441          }
    442          
    443          /*******************************************************************************
    444          * Function Name  : ADC_SoftwareStartConvCmd
    445          * Description    : Enables or disables the selected ADC software start conversion .
    446          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    447          *                  - NewState: new state of the selected ADC software start conversion.
    448          *                    This parameter can be: ENABLE or DISABLE.
    449          * Output         : None
    450          * Return         : None
    451          *******************************************************************************/
    452          void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    453          {
    454            /* Check the parameters */
    455            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    456            assert_param(IS_FUNCTIONAL_STATE(NewState));
    457          
    458            if (NewState != DISABLE)
    459            {
    460              /* Enable the selected ADC conversion on external event and start the selected
    461                 ADC conversion */
    462              ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
    463            }
    464            else
    465            {
    466              /* Disable the selected ADC conversion on external event and stop the selected
    467                 ADC conversion */
    468              ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
    469            }
    470          }
    471          
    472          /*******************************************************************************
    473          * Function Name  : ADC_GetSoftwareStartConvStatus
    474          * Description    : Gets the selected ADC Software start conversion Status.
    475          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    476          * Output         : None
    477          * Return         : The new state of ADC software start conversion (SET or RESET).
    478          *******************************************************************************/
    479          FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
    480          {
    481            FlagStatus bitstatus = RESET;
    482          
    483            /* Check the parameters */
    484            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    485          
    486            /* Check the status of SWSTART bit */
    487            if ((ADCx->CR2 & CR2_SWSTART_Set) != (u32)RESET)
    488            {
    489              /* SWSTART bit is set */
    490              bitstatus = SET;
    491            }
    492            else
    493            {
    494              /* SWSTART bit is reset */
    495              bitstatus = RESET;
    496            }
    497          
    498            /* Return the SWSTART bit status */
    499            return  bitstatus;
    500          }
    501          
    502          /*******************************************************************************
    503          * Function Name  : ADC_DiscModeChannelCountConfig
    504          * Description    : Configures the discontinuous mode for the selected ADC regular
    505          *                  group channel.
    506          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    507          *                  - Number: specifies the discontinuous mode regular channel
    508          *                    count value. This number must be between 1 and 8.
    509          * Output         : None
    510          * Return         : None
    511          *******************************************************************************/
    512          void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, u8 Number)
    513          {
    514            u32 tmpreg1 = 0;
    515            u32 tmpreg2 = 0;
    516          
    517            /* Check the parameters */
    518            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    519            assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
    520          
    521            /* Get the old register value */
    522            tmpreg1 = ADCx->CR1;
    523            /* Clear the old discontinuous mode channel count */
    524            tmpreg1 &= CR1_DISCNUM_Reset;
    525            /* Set the discontinuous mode channel count */
    526            tmpreg2 = Number - 1;
    527            tmpreg1 |= tmpreg2 << 13;
    528            /* Store the new register value */
    529            ADCx->CR1 = tmpreg1;
    530          }
    531          
    532          /*******************************************************************************
    533          * Function Name  : ADC_DiscModeCmd
    534          * Description    : Enables or disables the discontinuous mode on regular group
    535          *                  channel for the specified ADC
    536          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    537          *                  - NewState: new state of the selected ADC discontinuous mode
    538          *                    on regular group channel.
    539          *                    This parameter can be: ENABLE or DISABLE.
    540          * Output         : None
    541          * Return         : None
    542          *******************************************************************************/
    543          void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    544          {
    545            /* Check the parameters */
    546            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    547            assert_param(IS_FUNCTIONAL_STATE(NewState));
    548          
    549            if (NewState != DISABLE)
    550            {
    551              /* Enable the selected ADC regular discontinuous mode */
    552              ADCx->CR1 |= CR1_DISCEN_Set;
    553            }
    554            else
    555            {
    556              /* Disable the selected ADC regular discontinuous mode */
    557              ADCx->CR1 &= CR1_DISCEN_Reset;
    558            }
    559          }
    560          
    561          /*******************************************************************************
    562          * Function Name  : ADC_RegularChannelConfig
    563          * Description    : Configures for the selected ADC regular channel its corresponding
    564          *                  rank in the sequencer and its sample time.
    565          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    566          *                  - ADC_Channel: the ADC channel to configure. 
    567          *                    This parameter can be one of the following values:
    568          *                       - ADC_Channel_0: ADC Channel0 selected
    569          *                       - ADC_Channel_1: ADC Channel1 selected
    570          *                       - ADC_Channel_2: ADC Channel2 selected
    571          *                       - ADC_Channel_3: ADC Channel3 selected
    572          *                       - ADC_Channel_4: ADC Channel4 selected
    573          *                       - ADC_Channel_5: ADC Channel5 selected
    574          *                       - ADC_Channel_6: ADC Channel6 selected
    575          *                       - ADC_Channel_7: ADC Channel7 selected
    576          *                       - ADC_Channel_8: ADC Channel8 selected
    577          *                       - ADC_Channel_9: ADC Channel9 selected
    578          *                       - ADC_Channel_10: ADC Channel10 selected
    579          *                       - ADC_Channel_11: ADC Channel11 selected
    580          *                       - ADC_Channel_12: ADC Channel12 selected
    581          *                       - ADC_Channel_13: ADC Channel13 selected
    582          *                       - ADC_Channel_14: ADC Channel14 selected
    583          *                       - ADC_Channel_15: ADC Channel15 selected
    584          *                       - ADC_Channel_16: ADC Channel16 selected
    585          *                       - ADC_Channel_17: ADC Channel17 selected
    586          *                  - Rank: The rank in the regular group sequencer. This parameter
    587          *                    must be between 1 to 16.
    588          *                  - ADC_SampleTime: The sample time value to be set for the
    589          *                    selected channel. 
    590          *                    This parameter can be one of the following values:
    591          *                       - ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
    592          *                       - ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
    593          *                       - ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
    594          *                       - ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
    595          *                       - ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
    596          *                       - ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
    597          *                       - ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
    598          *                       - ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
    599          * Output         : None
    600          * Return         : None
    601          *******************************************************************************/
    602          void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
    603          {
    604            u32 tmpreg1 = 0, tmpreg2 = 0;
    605          
    606            /* Check the parameters */
    607            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    608            assert_param(IS_ADC_CHANNEL(ADC_Channel));
    609            assert_param(IS_ADC_REGULAR_RANK(Rank));
    610            assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
    611          
    612            /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
    613            if (ADC_Channel > ADC_Channel_9)
    614            {
    615              /* Get the old register value */
    616              tmpreg1 = ADCx->SMPR1;
    617              /* Calculate the mask to clear */
    618              tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
    619              /* Clear the old discontinuous mode channel count */
    620              tmpreg1 &= ~tmpreg2;
    621              /* Calculate the mask to set */
    622              tmpreg2 = (u32)ADC_SampleTime << (3 * (ADC_Channel - 10));
    623              /* Set the discontinuous mode channel count */
    624              tmpreg1 |= tmpreg2;
    625              /* Store the new register value */
    626              ADCx->SMPR1 = tmpreg1;
    627            }
    628            else /* ADC_Channel include in ADC_Channel_[0..9] */
    629            {
    630              /* Get the old register value */
    631              tmpreg1 = ADCx->SMPR2;
    632              /* Calculate the mask to clear */
    633              tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
    634              /* Clear the old discontinuous mode channel count */
    635              tmpreg1 &= ~tmpreg2;
    636              /* Calculate the mask to set */
    637              tmpreg2 = (u32)ADC_SampleTime << (3 * ADC_Channel);
    638              /* Set the discontinuous mode channel count */
    639              tmpreg1 |= tmpreg2;
    640              /* Store the new register value */
    641              ADCx->SMPR2 = tmpreg1;
    642            }
    643            /* For Rank 1 to 6 */
    644            if (Rank < 7)
    645            {
    646              /* Get the old register value */
    647              tmpreg1 = ADCx->SQR3;
    648              /* Calculate the mask to clear */
    649              tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
    650              /* Clear the old SQx bits for the selected rank */
    651              tmpreg1 &= ~tmpreg2;
    652              /* Calculate the mask to set */
    653              tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 1));
    654              /* Set the SQx bits for the selected rank */
    655              tmpreg1 |= tmpreg2;
    656              /* Store the new register value */
    657              ADCx->SQR3 = tmpreg1;
    658            }
    659            /* For Rank 7 to 12 */
    660            else if (Rank < 13)
    661            {
    662              /* Get the old register value */
    663              tmpreg1 = ADCx->SQR2;
    664              /* Calculate the mask to clear */
    665              tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
    666              /* Clear the old SQx bits for the selected rank */
    667              tmpreg1 &= ~tmpreg2;
    668              /* Calculate the mask to set */
    669              tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 7));
    670              /* Set the SQx bits for the selected rank */
    671              tmpreg1 |= tmpreg2;
    672              /* Store the new register value */
    673              ADCx->SQR2 = tmpreg1;
    674            }
    675            /* For Rank 13 to 16 */
    676            else
    677            {
    678              /* Get the old register value */
    679              tmpreg1 = ADCx->SQR1;
    680              /* Calculate the mask to clear */
    681              tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
    682              /* Clear the old SQx bits for the selected rank */
    683              tmpreg1 &= ~tmpreg2;
    684              /* Calculate the mask to set */
    685              tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 13));
    686              /* Set the SQx bits for the selected rank */
    687              tmpreg1 |= tmpreg2;
    688              /* Store the new register value */
    689              ADCx->SQR1 = tmpreg1;
    690            }
    691          }
    692          
    693          /*******************************************************************************
    694          * Function Name  : ADC_ExternalTrigConvCmd
    695          * Description    : Enables or disables the ADCx conversion through external trigger.
    696          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    697          *                  - NewState: new state of the selected ADC external trigger
    698          *                    start of conversion.
    699          *                    This parameter can be: ENABLE or DISABLE.
    700          * Output         : None
    701          * Return         : None
    702          *******************************************************************************/
    703          void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    704          {
    705            /* Check the parameters */
    706            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    707            assert_param(IS_FUNCTIONAL_STATE(NewState));
    708          
    709            if (NewState != DISABLE)
    710            {
    711              /* Enable the selected ADC conversion on external event */
    712              ADCx->CR2 |= CR2_EXTTRIG_Set;
    713            }
    714            else
    715            {
    716              /* Disable the selected ADC conversion on external event */
    717              ADCx->CR2 &= CR2_EXTTRIG_Reset;
    718            }
    719          }
    720          
    721          /*******************************************************************************
    722          * Function Name  : ADC_GetConversionValue
    723          * Description    : Returns the last ADCx conversion result data for regular channel.
    724          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    725          * Output         : None
    726          * Return         : The Data conversion value.
    727          *******************************************************************************/
    728          u16 ADC_GetConversionValue(ADC_TypeDef* ADCx)
    729          {
    730            /* Check the parameters */
    731            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    732          
    733            /* Return the selected ADC conversion value */
    734            return (u16) ADCx->DR;
    735          }
    736          
    737          /*******************************************************************************
    738          * Function Name  : ADC_GetDualModeConversionValue
    739          * Description    : Returns the last ADC1 and ADC2 conversion result data in dual mode.
    740          * Output         : None
    741          * Return         : The Data conversion value.
    742          *******************************************************************************/
    743          u32 ADC_GetDualModeConversionValue(void)
    744          {
    745            /* Return the dual mode conversion value */
    746            return (*(vu32 *) DR_ADDRESS);
    747          }
    748          
    749          /*******************************************************************************
    750          * Function Name  : ADC_AutoInjectedConvCmd
    751          * Description    : Enables or disables the selected ADC automatic injected group
    752          *                  conversion after regular one.
    753          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    754          *                  - NewState: new state of the selected ADC auto injected
    755          *                    conversion
    756          *                    This parameter can be: ENABLE or DISABLE.
    757          * Output         : None
    758          * Return         : None
    759          *******************************************************************************/
    760          void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    761          {
    762            /* Check the parameters */
    763            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    764            assert_param(IS_FUNCTIONAL_STATE(NewState));
    765          
    766            if (NewState != DISABLE)
    767            {
    768              /* Enable the selected ADC automatic injected group conversion */
    769              ADCx->CR1 |= CR1_JAUTO_Set;
    770            }
    771            else
    772            {
    773              /* Disable the selected ADC automatic injected group conversion */
    774              ADCx->CR1 &= CR1_JAUTO_Reset;
    775            }
    776          }
    777          
    778          /*******************************************************************************
    779          * Function Name  : ADC_InjectedDiscModeCmd
    780          * Description    : Enables or disables the discontinuous mode for injected group
    781          *                  channel for the specified ADC
    782          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    783          *                  - NewState: new state of the selected ADC discontinuous mode
    784          *                    on injected group channel.
    785          *                    This parameter can be: ENABLE or DISABLE.
    786          * Output         : None
    787          * Return         : None
    788          *******************************************************************************/
    789          void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    790          {
    791            /* Check the parameters */
    792            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    793            assert_param(IS_FUNCTIONAL_STATE(NewState));
    794          
    795            if (NewState != DISABLE)
    796            {
    797              /* Enable the selected ADC injected discontinuous mode */
    798              ADCx->CR1 |= CR1_JDISCEN_Set;
    799            }
    800            else
    801            {
    802              /* Disable the selected ADC injected discontinuous mode */
    803              ADCx->CR1 &= CR1_JDISCEN_Reset;
    804            }
    805          }
    806          
    807          /*******************************************************************************
    808          * Function Name  : ADC_ExternalTrigInjectedConvConfig
    809          * Description    : Configures the ADCx external trigger for injected channels conversion.
    810          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    811          *                  - ADC_ExternalTrigInjecConv: specifies the ADC trigger to
    812          *                    start injected conversion. 
    813          *                    This parameter can be one of the following values:
    814          *                       - ADC_ExternalTrigInjecConv_T1_TRGO: Timer1 TRGO event 
    815          *                         selected (for ADC1, ADC2 and ADC3)
    816          *                       - ADC_ExternalTrigInjecConv_T1_CC4: Timer1 capture
    817          *                         compare4 selected (for ADC1, ADC2 and ADC3)
    818          *                       - ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event
    819          *                         selected (for ADC1 and ADC2)
    820          *                       - ADC_External TrigInjecConv_T2_CC1: Timer2 capture
    821          *                         compare1 selected (for ADC1 and ADC2)
    822          *                       - ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture
    823          *                         compare4 selected (for ADC1 and ADC2)
    824          *                       - ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event
    825          *                         selected (for ADC1 and ADC2)
    826          *                       - ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4: External
    827          *                         interrupt line 15 or Timer8 capture compare4 event selected
    828          *                         (for ADC1 and ADC2)                       
    829          *                       - ADC_External TrigInjecConv_T4_CC3: Timer4 capture
    830          *                         compare3 selected (for ADC3 only)
    831          *                       - ADC_External TrigInjecConv_T8_CC2: Timer8 capture
    832          *                         compare2 selected (for ADC3 only)                         
    833          *                       - ADC_External TrigInjecConv_T8_CC4: Timer8 capture
    834          *                         compare4 selected (for ADC3 only)
    835          *                       - ADC_ExternalTrigInjecConv_T5_TRGO: Timer5 TRGO event
    836          *                         selected (for ADC3 only)                         
    837          *                       - ADC_External TrigInjecConv_T5_CC4: Timer5 capture
    838          *                         compare4 selected (for ADC3 only)                        
    839          *                       - ADC_ExternalTrigInjecConv_None: Injected conversion
    840          *                         started by software and not by external trigger (for 
    841          *                         ADC1, ADC2 and ADC3)
    842          * Output         : None
    843          * Return         : None
    844          *******************************************************************************/
    845          void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, u32 ADC_ExternalTrigInjecConv)
    846          {
    847            u32 tmpreg = 0;
    848          
    849            /* Check the parameters */
    850            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    851            assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
    852          
    853            /* Get the old register value */
    854            tmpreg = ADCx->CR2;
    855            /* Clear the old external event selection for injected group */
    856            tmpreg &= CR2_JEXTSEL_Reset;
    857            /* Set the external event selection for injected group */
    858            tmpreg |= ADC_ExternalTrigInjecConv;
    859            /* Store the new register value */
    860            ADCx->CR2 = tmpreg;
    861          }
    862          
    863          /*******************************************************************************
    864          * Function Name  : ADC_ExternalTrigInjectedConvCmd
    865          * Description    : Enables or disables the ADCx injected channels conversion
    866          *                  through external trigger
    867          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    868          *                  - NewState: new state of the selected ADC external trigger
    869          *                    start of injected conversion.
    870          *                    This parameter can be: ENABLE or DISABLE.
    871          * Output         : None
    872          * Return         : None
    873          *******************************************************************************/
    874          void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    875          {
    876            /* Check the parameters */
    877            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    878            assert_param(IS_FUNCTIONAL_STATE(NewState));
    879          
    880            if (NewState != DISABLE)
    881            {
    882              /* Enable the selected ADC external event selection for injected group */
    883              ADCx->CR2 |= CR2_JEXTTRIG_Set;
    884            }
    885            else
    886            {
    887              /* Disable the selected ADC external event selection for injected group */
    888              ADCx->CR2 &= CR2_JEXTTRIG_Reset;
    889            }
    890          }
    891          
    892          /*******************************************************************************
    893          * Function Name  : ADC_SoftwareStartInjectedConvCmd
    894          * Description    : Enables or disables the selected ADC start of the injected 
    895          *                  channels conversion.
    896          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    897          *                  - NewState: new state of the selected ADC software start
    898          *                    injected conversion.
    899          *                    This parameter can be: ENABLE or DISABLE.
    900          * Output         : None
    901          * Return         : None
    902          *******************************************************************************/
    903          void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    904          {
    905            /* Check the parameters */
    906            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    907            assert_param(IS_FUNCTIONAL_STATE(NewState));
    908          
    909            if (NewState != DISABLE)
    910            {
    911              /* Enable the selected ADC conversion for injected group on external event and start the selected
    912                 ADC injected conversion */
    913              ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
    914            }
    915            else
    916            {
    917              /* Disable the selected ADC conversion on external event for injected group and stop the selected
    918                 ADC injected conversion */
    919              ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;
    920            }
    921          }
    922          
    923          /*******************************************************************************
    924          * Function Name  : ADC_GetSoftwareStartInjectedConvCmdStatus
    925          * Description    : Gets the selected ADC Software start injected conversion Status.
    926          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    927          * Output         : None
    928          * Return         : The new state of ADC software start injected conversion (SET or RESET).
    929          *******************************************************************************/
    930          FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
    931          {
    932            FlagStatus bitstatus = RESET;
    933          
    934            /* Check the parameters */
    935            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    936          
    937            /* Check the status of JSWSTART bit */
    938            if ((ADCx->CR2 & CR2_JSWSTART_Set) != (u32)RESET)
    939            {
    940              /* JSWSTART bit is set */
    941              bitstatus = SET;
    942            }
    943            else
    944            {
    945              /* JSWSTART bit is reset */
    946              bitstatus = RESET;
    947            }
    948          
    949            /* Return the JSWSTART bit status */
    950            return  bitstatus;
    951          }
    952          
    953          /*******************************************************************************
    954          * Function Name  : ADC_InjectedChannelConfig
    955          * Description    : Configures for the selected ADC injected channel its corresponding
    956          *                  rank in the sequencer and its sample time.
    957          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    958          *                  - ADC_Channel: the ADC channel to configure. 
    959          *                    This parameter can be one of the following values:
    960          *                       - ADC_Channel_0: ADC Channel0 selected
    961          *                       - ADC_Channel_1: ADC Channel1 selected
    962          *                       - ADC_Channel_2: ADC Channel2 selected
    963          *                       - ADC_Channel_3: ADC Channel3 selected
    964          *                       - ADC_Channel_4: ADC Channel4 selected
    965          *                       - ADC_Channel_5: ADC Channel5 selected
    966          *                       - ADC_Channel_6: ADC Channel6 selected
    967          *                       - ADC_Channel_7: ADC Channel7 selected
    968          *                       - ADC_Channel_8: ADC Channel8 selected
    969          *                       - ADC_Channel_9: ADC Channel9 selected
    970          *                       - ADC_Channel_10: ADC Channel10 selected
    971          *                       - ADC_Channel_11: ADC Channel11 selected
    972          *                       - ADC_Channel_12: ADC Channel12 selected
    973          *                       - ADC_Channel_13: ADC Channel13 selected
    974          *                       - ADC_Channel_14: ADC Channel14 selected
    975          *                       - ADC_Channel_15: ADC Channel15 selected
    976          *                       - ADC_Channel_16: ADC Channel16 selected
    977          *                       - ADC_Channel_17: ADC Channel17 selected
    978          *                  - Rank: The rank in the injected group sequencer. This parameter
    979          *                    must be between 1 to 4.
    980          *                  - ADC_SampleTime: The sample time value to be set for the
    981          *                    selected channel. 
    982          *                    This parameter can be one of the following values:
    983          *                       - ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
    984          *                       - ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
    985          *                       - ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
    986          *                       - ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
    987          *                       - ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
    988          *                       - ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
    989          *                       - ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
    990          *                       - ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
    991          * Output         : None
    992          * Return         : None
    993          *******************************************************************************/
    994          void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
    995          {
    996            u32 tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
    997          
    998            /* Check the parameters */
    999            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1000            assert_param(IS_ADC_CHANNEL(ADC_Channel));
   1001            assert_param(IS_ADC_INJECTED_RANK(Rank));
   1002            assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
   1003          
   1004            /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
   1005            if (ADC_Channel > ADC_Channel_9)
   1006            {
   1007              /* Get the old register value */
   1008              tmpreg1 = ADCx->SMPR1;
   1009              /* Calculate the mask to clear */
   1010              tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
   1011              /* Clear the old discontinuous mode channel count */
   1012              tmpreg1 &= ~tmpreg2;
   1013              /* Calculate the mask to set */
   1014              tmpreg2 = (u32)ADC_SampleTime << (3*(ADC_Channel - 10));
   1015              /* Set the discontinuous mode channel count */
   1016              tmpreg1 |= tmpreg2;
   1017              /* Store the new register value */
   1018              ADCx->SMPR1 = tmpreg1;
   1019            }
   1020            else /* ADC_Channel include in ADC_Channel_[0..9] */
   1021            {
   1022              /* Get the old register value */
   1023              tmpreg1 = ADCx->SMPR2;
   1024              /* Calculate the mask to clear */
   1025              tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
   1026              /* Clear the old discontinuous mode channel count */
   1027              tmpreg1 &= ~tmpreg2;
   1028              /* Calculate the mask to set */
   1029              tmpreg2 = (u32)ADC_SampleTime << (3 * ADC_Channel);
   1030              /* Set the discontinuous mode channel count */
   1031              tmpreg1 |= tmpreg2;
   1032              /* Store the new register value */
   1033              ADCx->SMPR2 = tmpreg1;
   1034            }
   1035          
   1036            /* Rank configuration */
   1037            /* Get the old register value */
   1038            tmpreg1 = ADCx->JSQR;
   1039            /* Get JL value: Number = JL+1 */
   1040            tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
   1041            /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
   1042            tmpreg2 = JSQR_JSQ_Set << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
   1043            /* Clear the old JSQx bits for the selected rank */
   1044            tmpreg1 &= ~tmpreg2;
   1045            /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
   1046            tmpreg2 = (u32)ADC_Channel << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
   1047            /* Set the JSQx bits for the selected rank */
   1048            tmpreg1 |= tmpreg2;
   1049            /* Store the new register value */
   1050            ADCx->JSQR = tmpreg1;
   1051          }
   1052          
   1053          /*******************************************************************************
   1054          * Function Name  : ADC_InjectedSequencerLengthConfig
   1055          * Description    : Configures the sequencer length for injected channels
   1056          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1057          *                  - Length: The sequencer length. 
   1058          *                    This parameter must be a number between 1 to 4.
   1059          * Output         : None
   1060          * Return         : None
   1061          *******************************************************************************/
   1062          void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, u8 Length)
   1063          {
   1064            u32 tmpreg1 = 0;
   1065            u32 tmpreg2 = 0;
   1066          
   1067            /* Check the parameters */
   1068            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1069            assert_param(IS_ADC_INJECTED_LENGTH(Length));
   1070            
   1071            /* Get the old register value */
   1072            tmpreg1 = ADCx->JSQR;
   1073            /* Clear the old injected sequnence lenght JL bits */
   1074            tmpreg1 &= JSQR_JL_Reset;
   1075            /* Set the injected sequnence lenght JL bits */
   1076            tmpreg2 = Length - 1; 
   1077            tmpreg1 |= tmpreg2 << 20;
   1078            /* Store the new register value */
   1079            ADCx->JSQR = tmpreg1;
   1080          }
   1081          
   1082          /*******************************************************************************
   1083          * Function Name  : ADC_SetInjectedOffset
   1084          * Description    : Set the injected channels conversion value offset
   1085          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1086          *                  - ADC_InjectedChannel: the ADC injected channel to set its
   1087          *                    offset. 
   1088          *                    This parameter can be one of the following values:
   1089          *                       - ADC_InjectedChannel_1: Injected Channel1 selected
   1090          *                       - ADC_InjectedChannel_2: Injected Channel2 selected
   1091          *                       - ADC_InjectedChannel_3: Injected Channel3 selected
   1092          *                       - ADC_InjectedChannel_4: Injected Channel4 selected
   1093          *                  - Offset: the offset value for the selected ADC injected channel
   1094          *                    This parameter must be a 12bit value.
   1095          * Output         : None
   1096          * Return         : None
   1097          *******************************************************************************/
   1098          void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel, u16 Offset)
   1099          {
   1100            /* Check the parameters */
   1101            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1102            assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   1103            assert_param(IS_ADC_OFFSET(Offset));  
   1104          
   1105            /* Set the selected injected channel data offset */
   1106            *((vu32 *)((*(u32*)&ADCx) + ADC_InjectedChannel)) = (u32)Offset;
   1107          }
   1108          
   1109          /*******************************************************************************
   1110          * Function Name  : ADC_GetInjectedConversionValue
   1111          * Description    : Returns the ADC injected channel conversion result
   1112          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1113          *                  - ADC_InjectedChannel: the converted ADC injected channel.
   1114          *                    This parameter can be one of the following values:
   1115          *                       - ADC_InjectedChannel_1: Injected Channel1 selected
   1116          *                       - ADC_InjectedChannel_2: Injected Channel2 selected
   1117          *                       - ADC_InjectedChannel_3: Injected Channel3 selected
   1118          *                       - ADC_InjectedChannel_4: Injected Channel4 selected
   1119          * Output         : None
   1120          * Return         : The Data conversion value.
   1121          *******************************************************************************/
   1122          u16 ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel)
   1123          {
   1124            /* Check the parameters */
   1125            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1126            assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   1127          
   1128            /* Returns the selected injected channel conversion data value */
   1129            return (u16) (*(vu32*) (((*(u32*)&ADCx) + ADC_InjectedChannel + JDR_Offset)));
   1130          }
   1131          
   1132          /*******************************************************************************
   1133          * Function Name  : ADC_AnalogWatchdogCmd
   1134          * Description    : Enables or disables the analog watchdog on single/all regular
   1135          *                  or injected channels
   1136          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1137          *                  - ADC_AnalogWatchdog: the ADC analog watchdog configuration.
   1138          *                    This parameter can be one of the following values:
   1139          *                       - ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on
   1140          *                         a single regular channel
   1141          *                       - ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on
   1142          *                         a single injected channel
   1143          *                       - ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog 
   1144          *                         watchdog on a single regular or injected channel
   1145          *                       - ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on
   1146          *                         all regular channel
   1147          *                       - ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on
   1148          *                         all injected channel
   1149          *                       - ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog
   1150          *                         on all regular and injected channels
   1151          *                       - ADC_AnalogWatchdog_None: No channel guarded by the
   1152          *                         analog watchdog
   1153          * Output         : None
   1154          * Return         : None	  
   1155          *******************************************************************************/
   1156          void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, u32 ADC_AnalogWatchdog)
   1157          {
   1158            u32 tmpreg = 0;
   1159          
   1160            /* Check the parameters */
   1161            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1162            assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
   1163          
   1164            /* Get the old register value */
   1165            tmpreg = ADCx->CR1;
   1166            /* Clear AWDEN, AWDENJ and AWDSGL bits */
   1167            tmpreg &= CR1_AWDMode_Reset;
   1168            /* Set the analog watchdog enable mode */
   1169            tmpreg |= ADC_AnalogWatchdog;
   1170            /* Store the new register value */
   1171            ADCx->CR1 = tmpreg;
   1172          }
   1173          
   1174          /*******************************************************************************
   1175          * Function Name  : ADC_AnalogWatchdogThresholdsConfig
   1176          * Description    : Configures the high and low thresholds of the analog watchdog.
   1177          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1178          *                  - HighThreshold: the ADC analog watchdog High threshold value.
   1179          *                    This parameter must be a 12bit value.
   1180          *                  - LowThreshold: the ADC analog watchdog Low threshold value.
   1181          *                    This parameter must be a 12bit value.
   1182          * Output         : None
   1183          * Return         : None
   1184          *******************************************************************************/
   1185          void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, u16 HighThreshold,
   1186                                                  u16 LowThreshold)
   1187          {
   1188            /* Check the parameters */
   1189            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1190            assert_param(IS_ADC_THRESHOLD(HighThreshold));
   1191            assert_param(IS_ADC_THRESHOLD(LowThreshold));
   1192          
   1193            /* Set the ADCx high threshold */
   1194            ADCx->HTR = HighThreshold;
   1195            /* Set the ADCx low threshold */
   1196            ADCx->LTR = LowThreshold;
   1197          }
   1198          
   1199          /*******************************************************************************
   1200          * Function Name  : ADC_AnalogWatchdogSingleChannelConfig
   1201          * Description    : Configures the analog watchdog guarded single channel
   1202          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1203          *                  - ADC_Channel: the ADC channel to configure for the analog
   1204          *                    watchdog. 
   1205          *                    This parameter can be one of the following values:
   1206          *                       - ADC_Channel_0: ADC Channel0 selected
   1207          *                       - ADC_Channel_1: ADC Channel1 selected
   1208          *                       - ADC_Channel_2: ADC Channel2 selected
   1209          *                       - ADC_Channel_3: ADC Channel3 selected
   1210          *                       - ADC_Channel_4: ADC Channel4 selected
   1211          *                       - ADC_Channel_5: ADC Channel5 selected
   1212          *                       - ADC_Channel_6: ADC Channel6 selected
   1213          *                       - ADC_Channel_7: ADC Channel7 selected
   1214          *                       - ADC_Channel_8: ADC Channel8 selected
   1215          *                       - ADC_Channel_9: ADC Channel9 selected
   1216          *                       - ADC_Channel_10: ADC Channel10 selected
   1217          *                       - ADC_Channel_11: ADC Channel11 selected
   1218          *                       - ADC_Channel_12: ADC Channel12 selected
   1219          *                       - ADC_Channel_13: ADC Channel13 selected
   1220          *                       - ADC_Channel_14: ADC Channel14 selected
   1221          *                       - ADC_Channel_15: ADC Channel15 selected
   1222          *                       - ADC_Channel_16: ADC Channel16 selected
   1223          *                       - ADC_Channel_17: ADC Channel17 selected
   1224          * Output         : None
   1225          * Return         : None
   1226          *******************************************************************************/
   1227          void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel)
   1228          {
   1229            u32 tmpreg = 0;
   1230          
   1231            /* Check the parameters */
   1232            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1233            assert_param(IS_ADC_CHANNEL(ADC_Channel));
   1234          
   1235            /* Get the old register value */
   1236            tmpreg = ADCx->CR1;
   1237            /* Clear the Analog watchdog channel select bits */
   1238            tmpreg &= CR1_AWDCH_Reset;
   1239            /* Set the Analog watchdog channel */
   1240            tmpreg |= ADC_Channel;
   1241            /* Store the new register value */
   1242            ADCx->CR1 = tmpreg;
   1243          }
   1244          
   1245          /*******************************************************************************
   1246          * Function Name  : ADC_TempSensorVrefintCmd
   1247          * Description    : Enables or disables the temperature sensor and Vrefint channel.
   1248          * Input          : - NewState: new state of the temperature sensor.
   1249          *                    This parameter can be: ENABLE or DISABLE.
   1250          * Output         : None
   1251          * Return         : None
   1252          *******************************************************************************/
   1253          void ADC_TempSensorVrefintCmd(FunctionalState NewState)
   1254          {
   1255            /* Check the parameters */
   1256            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1257          
   1258            if (NewState != DISABLE)
   1259            {
   1260              /* Enable the temperature sensor and Vrefint channel*/
   1261              ADC1->CR2 |= CR2_TSVREFE_Set;
   1262            }
   1263            else
   1264            {
   1265              /* Disable the temperature sensor and Vrefint channel*/
   1266              ADC1->CR2 &= CR2_TSVREFE_Reset;
   1267            }
   1268          }
   1269          
   1270          /*******************************************************************************
   1271          * Function Name  : ADC_GetFlagStatus
   1272          * Description    : Checks whether the specified ADC flag is set or not.
   1273          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1274          *                  - ADC_FLAG: specifies the flag to check. 
   1275          *                    This parameter can be one of the following values:
   1276          *                       - ADC_FLAG_AWD: Analog watchdog flag
   1277          *                       - ADC_FLAG_EOC: End of conversion flag
   1278          *                       - ADC_FLAG_JEOC: End of injected group conversion flag
   1279          *                       - ADC_FLAG_JSTRT: Start of injected group conversion flag
   1280          *                       - ADC_FLAG_STRT: Start of regular group conversion flag
   1281          * Output         : None
   1282          * Return         : The new state of ADC_FLAG (SET or RESET).
   1283          *******************************************************************************/
   1284          FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, u8 ADC_FLAG)
   1285          {
   1286            FlagStatus bitstatus = RESET;
   1287          
   1288            /* Check the parameters */
   1289            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1290            assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
   1291          
   1292            /* Check the status of the specified ADC flag */
   1293            if ((ADCx->SR & ADC_FLAG) != (u8)RESET)
   1294            {
   1295              /* ADC_FLAG is set */
   1296              bitstatus = SET;
   1297            }
   1298            else
   1299            {
   1300              /* ADC_FLAG is reset */
   1301              bitstatus = RESET;
   1302            }
   1303          
   1304            /* Return the ADC_FLAG status */
   1305            return  bitstatus;
   1306          }
   1307          
   1308          /*******************************************************************************
   1309          * Function Name  : ADC_ClearFlag
   1310          * Description    : Clears the ADCx's pending flags.
   1311          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1312          *                  - ADC_FLAG: specifies the flag to clear. 
   1313          *                    This parameter can be any combination of the following values:
   1314          *                       - ADC_FLAG_AWD: Analog watchdog flag
   1315          *                       - ADC_FLAG_EOC: End of conversion flag
   1316          *                       - ADC_FLAG_JEOC: End of injected group conversion flag
   1317          *                       - ADC_FLAG_JSTRT: Start of injected group conversion flag
   1318          *                       - ADC_FLAG_STRT: Start of regular group conversion flag
   1319          * Output         : None
   1320          * Return         : None
   1321          *******************************************************************************/
   1322          void ADC_ClearFlag(ADC_TypeDef* ADCx, u8 ADC_FLAG)
   1323          {
   1324            /* Check the parameters */
   1325            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1326            assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
   1327          
   1328            /* Clear the selected ADC flags */
   1329            ADCx->SR = ~(u32)ADC_FLAG;
   1330          }
   1331          
   1332          /*******************************************************************************
   1333          * Function Name  : ADC_GetITStatus
   1334          * Description    : Checks whether the specified ADC interrupt has occurred or not.
   1335          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1336          *                  - ADC_IT: specifies the ADC interrupt source to check. 
   1337          *                    This parameter can be one of the following values:
   1338          *                       - ADC_IT_EOC: End of conversion interrupt mask
   1339          *                       - ADC_IT_AWD: Analog watchdog interrupt mask
   1340          *                       - ADC_IT_JEOC: End of injected conversion interrupt mask
   1341          * Output         : None
   1342          * Return         : The new state of ADC_IT (SET or RESET).
   1343          *******************************************************************************/
   1344          ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, u16 ADC_IT)
   1345          {
   1346            ITStatus bitstatus = RESET;
   1347            u32 itmask = 0, enablestatus = 0;
   1348          
   1349            /* Check the parameters */
   1350            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1351            assert_param(IS_ADC_GET_IT(ADC_IT));
   1352          
   1353            /* Get the ADC IT index */
   1354            itmask = ADC_IT >> 8;
   1355          
   1356            /* Get the ADC_IT enable bit status */
   1357            enablestatus = (ADCx->CR1 & (u8)ADC_IT) ;
   1358          
   1359            /* Check the status of the specified ADC interrupt */
   1360            if (((ADCx->SR & itmask) != (u32)RESET) && enablestatus)
   1361            {
   1362              /* ADC_IT is set */
   1363              bitstatus = SET;
   1364            }
   1365            else
   1366            {
   1367              /* ADC_IT is reset */
   1368              bitstatus = RESET;
   1369            }
   1370          
   1371            /* Return the ADC_IT status */
   1372            return  bitstatus;
   1373          }
   1374          
   1375          /*******************************************************************************
   1376          * Function Name  : ADC_ClearITPendingBit
   1377          * Description    : Clears the ADCxs interrupt pending bits.
   1378          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1379          *                  - ADC_IT: specifies the ADC interrupt pending bit to clear.
   1380          *                    This parameter can be any combination of the following values:
   1381          *                       - ADC_IT_EOC: End of conversion interrupt mask
   1382          *                       - ADC_IT_AWD: Analog watchdog interrupt mask
   1383          *                       - ADC_IT_JEOC: End of injected conversion interrupt mask
   1384          * Output         : None
   1385          * Return         : None
   1386          *******************************************************************************/
   1387          void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, u16 ADC_IT)
   1388          {
   1389            u8 itmask = 0;
   1390          
   1391            /* Check the parameters */
   1392            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1393            assert_param(IS_ADC_IT(ADC_IT));
   1394          
   1395            /* Get the ADC IT index */
   1396            itmask = (u8)(ADC_IT >> 8);
   1397          
   1398            /* Clear the selected ADC interrupt pending bits */
   1399            ADCx->SR = ~(u32)itmask;
   1400          }
   1401          
   1402          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     ADC_AnalogWatchdogCmd               0
     ADC_AnalogWatchdogSingleChannelConfig
                                         0
     ADC_AnalogWatchdogThresholdsConfig
                                         0
     ADC_AutoInjectedConvCmd             0
     ADC_ClearFlag                       0
     ADC_ClearITPendingBit               0
     ADC_Cmd                             0
     ADC_DMACmd                          0
     ADC_DeInit                          8
     ADC_DiscModeChannelCountConfig      8
     ADC_DiscModeCmd                     0
     ADC_ExternalTrigConvCmd             0
     ADC_ExternalTrigInjectedConvCmd
                                         0
     ADC_ExternalTrigInjectedConvConfig
                                         0
     ADC_GetCalibrationStatus            0
     ADC_GetConversionValue              0
     ADC_GetDualModeConversionValue      0
     ADC_GetFlagStatus                   0
     ADC_GetITStatus                     8
     ADC_GetInjectedConversionValue      0
     ADC_GetResetCalibrationStatus       0
     ADC_GetSoftwareStartConvStatus      0
     ADC_GetSoftwareStartInjectedConvCmdStatus
                                         0
     ADC_ITConfig                        0
     ADC_Init                            8
     ADC_InjectedChannelConfig          16
     ADC_InjectedDiscModeCmd             0
     ADC_InjectedSequencerLengthConfig
                                         8
     ADC_RegularChannelConfig           16
     ADC_ResetCalibration                0
     ADC_SetInjectedOffset               0
     ADC_SoftwareStartConvCmd            0
     ADC_SoftwareStartInjectedConvCmd
                                         0
     ADC_StartCalibration                0
     ADC_StructInit                      0
     ADC_TempSensorVrefintCmd            0


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     ADC_DeInit                      100
     ADC_Init                         80
     ADC_StructInit                   26
     ADC_Cmd                          26
     ADC_DMACmd                       26
     ADC_ITConfig                     32
     ADC_ResetCalibration             10
     ADC_GetResetCalibrationStatus    24
     ADC_StartCalibration             10
     ADC_GetCalibrationStatus         24
     ADC_SoftwareStartConvCmd         26
     ADC_GetSoftwareStartConvStatus   24
     ADC_DiscModeChannelCountConfig   30
     ADC_DiscModeCmd                  26
     ADC_RegularChannelConfig        218
     ADC_ExternalTrigConvCmd          26
     ADC_GetConversionValue            6
     ADC_GetDualModeConversionValue   12
     ADC_AutoInjectedConvCmd          26
     ADC_InjectedDiscModeCmd          26
     ADC_ExternalTrigInjectedConvConfig
                                      16
     ADC_ExternalTrigInjectedConvCmd
                                      26
     ADC_SoftwareStartInjectedConvCmd
                                      26
     ADC_GetSoftwareStartInjectedConvCmdStatus
                                      24
     ADC_InjectedChannelConfig       148
     ADC_InjectedSequencerLengthConfig
                                      30
     ADC_SetInjectedOffset             8
     ADC_GetInjectedConversionValue   10
     ADC_AnalogWatchdogCmd            20
     ADC_AnalogWatchdogThresholdsConfig
                                      10
     ADC_AnalogWatchdogSingleChannelConfig
                                      18
     ADC_TempSensorVrefintCmd         40
     ADC_GetFlagStatus                26
     ADC_ClearFlag                     8
     ADC_GetITStatus                  52
     ADC_ClearITPendingBit            16

 
 1 256 bytes in section .text
 
 1 256 bytes of CODE memory

Errors: none
Warnings: none
